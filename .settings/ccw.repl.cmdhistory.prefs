cmdhistory=[" (R->generate \\r\\n                 (R->def \:dog 4)\\r\\n                 (R->def \:m1 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\r\\n                 (R->def \:m2 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\r\\n                 (R->def \:m3 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\r\\n                 (R->stripchart (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3))))" "(R->generate (mean (R->vector 1 2 3)))" " (mean (R->vector 1 2 3))" "  (require '[codeGeneration.RC-code-generation \:refer [R->generate]]\\r\\n            '[dsl.primary-operations \:refer \:all]\\r\\n            '[dsl.composit-operations \:refer \:all])" " (mean (R->vector 1 2 3))" "(R->vector 1 2 3)" " (mean (R->vector 1 2 3))" "(R->vector 1 2 3)" " (mean (R->vector 1 2 3))" "(R->vector 1 2 3)" " (mean 1 2 3)" "(R->generate (mean 1 2 3))" "(R->vector 1 2 3)" "(apply assoc '({\:R-struct true, \:oper \:R->vector, \:parms []}) \:parms (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}))))" "(defn convert-raw-value [data-coll]\\r\\n  (into []\\r\\n        (map (fn [x] (cond\\r\\n                 (number? x) (dsl/R->number x)\\r\\n                 (keyword? x) (dsl/R->keyword x)\\r\\n                 \:default (throw (Exception. (str \\"Invalid parameter type in function.\\"))))) data-coll)))" "(require '[dsl.primary-operations \:as dsl])" "(defn convert-raw-value [data-coll]\\r\\n  (into []\\r\\n        (map (fn [x] (cond\\r\\n                 (number? x) (dsl/R->number x)\\r\\n                 (keyword? x) (dsl/R->keyword x)\\r\\n                 \:default (throw (Exception. (str \\"Invalid parameter type in function.\\"))))) data-coll)))" "(apply assoc '({\:R-struct true, \:oper \:R->vector, \:parms []}) \:parms (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}))))" " (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]})))" "(assoc '({\:R-struct true, \:oper \:R->vector, \:parms []}) \\n       \:parms (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}))))" "(apply assoc '({\:R-struct true, \:oper \:R->vector, \:parms []}) \\n       \:parms (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}))))" "(assoc (first '({\:R-struct true, \:oper \:R->vector, \:parms []})) \\n       \:parms (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}))))" " (-> '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}) first (assoc  \:parms \\n                                                                        \\n                                                                         (->> '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}) (apply \:parms) (convert-raw-value))))" " (-> '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}) first (assoc  \:parms \\n                                                                        \\n                                                                         (->> '({\:R-struct true, \:oper \:R->vector, \:parms [1 444 3]}) (apply \:parms) (convert-raw-value))))" " (mean (R->vector 1 2 3))" "(R->generate (mean (R->vector 1 2 3)))" "(R->stripchart 1 2 3)" "(R->stripchart (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3)))" "(R->generate (R->stripchart (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3))))" "(R->generate (R->mean (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3))))" "(require '[testDrivenDev.integration-test])" "  (require '[codeGeneration.RC-code-generation \:refer [R->generate]]\\r\\n            '[dsl.primary-operations \:refer \:all]\\r\\n            '[dsl.composit-operations \:refer \:all]\\r\\n            )" "(R->generate (R->mean 1 2 3))" "(R->generate (R->mean [1 2 3]))" "(R->generate (R->mean {\:x (R->vector 2 2 3)}))" "(R->generate (mean 1 2 3))" "(R->generate (mean {\:x (R->vector 2 2 3)}))" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(mean 1 2 3)" "(R->generate (mean 1 2 3))" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(into [] (->> {\:x (R->vector (R->number 1))}  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))" "(into [] (->> {\:x (R->vector (R->number 1))}  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))" " (R->vector (R->number 1))" "(->> {\:x (R->vector (R->number 1))}  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))" "(->> {\\"x\\" (R->vector (R->number 1))}  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))" "(->> {\:x (R->vector (R->number 1))}  (apply seq))" "(->> {\\"x\\" (R->vector (R->number 1)) \:y (R->vector (R->number 1))}  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))" "(->> {\\"x\\" (R->vector (R->number 1)) \:y (R->vector (R->number 1))}  \\n  (apply seq) )" "(->> '({\\"x\\" (R->vector (R->number 1)) \:y (R->vector (R->number 1))})\\n  (apply seq) )" "(->> [{\\"x\\" (R->vector (R->number 1)) \:y (R->vector (R->number 1))}]\\n  (apply seq) )" "(->> [{\\"x\\" (R->vector (R->number 1)) \:y (R->vector (R->number 1))}]\\n  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val)))))" "(->> [{\\"x\\" (R->vector (R->number 1)) \:y (R->vector (R->number 1))}]\\n  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(defn stnd-input-support \\r\\n  \\"Resolves common parameter input conversions such and numbers vectors and maps\\"\\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:raw \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)]\\r\\n      (cond          \\r\\n        (and \\r\\n          (some \#{\:raw} options-vec)\\r\\n          (> cardinality 1)) \\r\\n        (apply dsl/R->vector (convert-raw-value data)) \\r\\n        (and \\r\\n          (some \#{\:vec} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply vector? data))    \\r\\n        (apply dsl/R->vector (convert-raw-value (first data)))\\r\\n        (and \\r\\n          (some \#{\:r-str} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data)\\r\\n          (apply \:R-struct data)) \\r\\n        (-> data first (assoc  \:parms (->> data (apply \:parms) (convert-raw-value))))\\r\\n        (and \\r\\n          (some \#{\:map} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data))    \\r\\n        (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n        \:default                       \\r\\n        (throw (Exception. \\"Invalid element in function R->summary.\\"))))))" " (require '[dsl.primary-operations \:as dsl])\\n(defn stnd-input-support \\r\\n  \\"Resolves common parameter input conversions such and numbers vectors and maps\\"\\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:raw \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)]\\r\\n      (cond          \\r\\n        (and \\r\\n          (some \#{\:raw} options-vec)\\r\\n          (> cardinality 1)) \\r\\n        (apply dsl/R->vector (convert-raw-value data)) \\r\\n        (and \\r\\n          (some \#{\:vec} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply vector? data))    \\r\\n        (apply dsl/R->vector (convert-raw-value (first data)))\\r\\n        (and \\r\\n          (some \#{\:r-str} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data)\\r\\n          (apply \:R-struct data)) \\r\\n        (-> data first (assoc  \:parms (->> data (apply \:parms) (convert-raw-value))))\\r\\n        (and \\r\\n          (some \#{\:map} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data))    \\r\\n        (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n        \:default                       \\r\\n        (throw (Exception. \\"Invalid element in function R->summary.\\"))))))" "(defn convert-raw-value [data-coll]\\r\\n  \\"Converts raw numbers and keywords to R datastructs\\"\\r\\n  (into []\\r\\n        (map (fn [x] (cond\\r\\n                       (number? x) (dsl/R->number x)\\r\\n                       (keyword? x) (dsl/R->keyword x)\\r\\n                       \:default (throw (Exception. (str \\"Invalid parameter type in function.\\"))))) data-coll)))" " (require '[dsl.primary-operations \:as dsl])\\n(defn stnd-input-support \\r\\n  \\"Resolves common parameter input conversions such and numbers vectors and maps\\"\\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:raw \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)]\\r\\n      (cond          \\r\\n        (and \\r\\n          (some \#{\:raw} options-vec)\\r\\n          (> cardinality 1)) \\r\\n        (apply dsl/R->vector (convert-raw-value data)) \\r\\n        (and \\r\\n          (some \#{\:vec} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply vector? data))    \\r\\n        (apply dsl/R->vector (convert-raw-value (first data)))\\r\\n        (and \\r\\n          (some \#{\:r-str} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data)\\r\\n          (apply \:R-struct data)) \\r\\n        (-> data first (assoc  \:parms (->> data (apply \:parms) (convert-raw-value))))\\r\\n        (and \\r\\n          (some \#{\:map} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data))    \\r\\n        (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n        \:default                       \\r\\n        (throw (Exception. \\"Invalid element in function R->summary.\\"))))))" "(defn stnd-input-support \\r\\n  \\"Resolves common parameter input conversions such and numbers vectors and maps\\"\\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:raw \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)\\n          _ (println \\"success\\")]\\r\\n      (cond          \\r\\n        (and \\r\\n          (some \#{\:raw} options-vec)\\r\\n          (> cardinality 1)) \\r\\n        (apply dsl/R->vector (convert-raw-value data)) \\r\\n        (and \\r\\n          (some \#{\:vec} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply vector? data))    \\r\\n        (apply dsl/R->vector (convert-raw-value (first data)))\\r\\n        (and \\r\\n          (some \#{\:r-str} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data)\\r\\n          (apply \:R-struct data)) \\r\\n        (-> data first (assoc  \:parms (->> data (apply \:parms) (convert-raw-value))))\\r\\n        (and \\r\\n          (some \#{\:map} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data))    \\r\\n        (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n        \:default                       \\r\\n        (throw (Exception. \\"Invalid element in function R->summary.\\"))))))" "(mean 1 2 3)" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(->> '({\:x {\:R-struct true, \:oper \:R->vector, \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}}) \\n  (apply seq))" "(->> '({\:x {\:R-struct true, \:oper \:R->vector, \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}}) \\n  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val)))))" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(->> '({\:x {\:R-struct true, \:oper \:R->vector, \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}}) \\n  (apply seq) (map (fn [val] (dsl/R->\= (R->keyword (first val)) (second val)))))" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(->> '({\:x {\:R-struct true, \:oper \:R->vector, \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}}) \\n  (apply seq) (map (fn [val] (dsl/R->\= (R->keyword (first val)) (second val)))))" "(->> \\n  '({\:x {\:R-struct true, \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \\n                  \:parms [1]}]}}) \\n  (apply seq) (map (fn [val] \\n                     (dsl/R->\= (R->keyword (first val)) (second val)))))" "(->> \\n  '({\:x {\:R-struct true, \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \\n                  \:parms [1]}]}}) \\n  (apply seq))" "(->> \\n  '({\:x {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \\n                  \:parms [1]}]}}\\n     {\:y {\:R-struct true, \\r\\n         \:oper \:R->vector, \\r\\n         \:parms [{\:R-struct true, \:oper \:R->number, \\r\\n                  \:parms [1]}]}}) \\n  (apply seq))" "(->> \\n  '({\:x {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \\n                  \:parms [1]}]}\\n     \:y {\:R-struct true, \\r\\n         \:oper \:R->vector, \\r\\n         \:parms [{\:R-struct true, \:oper \:R->number, \\r\\n                  \:parms [1]}]}}) \\n  (apply seq))" "(->> '({\:x \\n        {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}}) \\n  (apply seq) (map (fn [val] (dsl/R->\= (R->keyword (first val)) (second val)))))" "(->> '({\:x \\n        {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}}) \\n  (apply seq) (map (fn [val] (println (first val) (second val)))))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}}\\n  (apply seq) (map (fn [val] (println (first val) (second val)))))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}}\\n  (apply seq))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n  (apply seq))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq)" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (map (fn [val] (println (first val) (second val)))))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (dsl/R->\=  (dsl/R->keyword (first val)) (second val)))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq )" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (map (fn [val] (println val))))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (map (fn [val] (println \\"\\"))))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (map (fn [val] (println val))))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (dsl/R->\=  (dsl/R->keyword (first val)) (second val)))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (dsl/R->\=  (first val) (second val)))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (map (dsl/R->\=  (dsl/R->keyword (first val)) (second val))))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (map (print (first val)) (second val)))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (map (dsl/R->\=  (dsl/R->keyword (first val)) (second val))))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq )" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (map (fn [val] (dsl/R->\=  (dsl/R->keyword (first val)) (second val)))))" "(->> '({\:x \\n        {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n        \:y 1})\\n   seq \\n   (map (fn [val] \\n          (dsl/R->\=  \\n            (dsl/R->keyword (first val)) \\n            (second val)))))" "(->> '({\:x \\n        {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n        \:y 1}))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   (apply seq ))" "(->> '({\:x \\n        {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n        \:y 1})\\n   (apply seq ))" "(->> '({\:x \\n        {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n        \:y 1})\\n   (apply seq)\\n   (map (fn [val] \\n          (dsl/R->\=  \\n            (dsl/R->keyword (first val)) \\n            (second val)))))" "(->> '({\:x \\n        {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n        \:y 1})\\n   (apply seq)\\n   (map (fn [val] \\n          (dsl/R->\=  \\n             (first val)\\n            (second val)))))" "(R->generate (->> '({\:x \\n             {\:R-struct true, \\n              \:oper \:R->vector, \\n              \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n             \:y 1})\\n       (apply seq)\\n       (map (fn [val] \\n              (dsl/R->\=  \\n                 (first val)\\n                (second val))))))" "(apply R->generate (->> '({\:x \\n                  {\:R-struct true, \\n                   \:oper \:R->vector, \\n                   \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n                  \:y 1})\\n       (apply seq)\\n       (map (fn [val] \\n              (dsl/R->\=  \\n                 (first val)\\n                (second val))))))" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" " \\n  (mean {\:x (R->vector (R->number 1))})" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(R->generate \\n  (summary {\:x (R->vector (R->number 1))}))" "(R->generate \\n  (summary 1 2 32  ))" "(R->generate \\n  (summary [1 2 32]))" "(R->generate \\n  (mean [1 2 32]))" "(R->generate \\n  (summary [1 2 32]))" "(R->generate \\n  (summary (R->vector 1 2 3)))" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(R->generate  (R->def \:m3 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) )))))" "(R->generate  (R->def \:m3 (R->mean \\r\\n                               (R->\= (R->keyword \:x) (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= (R->keyword \:y) (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) )))))" "InheritableThreadLocal" "(R->generate  (R->def \:m3 (R->mean \\r\\n                               (R->\= (R->keyword \:x) (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= (R->keyword \:y) (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) )))))" "(R->generate \\n  (summary (R->vector 1 2 3)))" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(R->generate (mean 1 2 3))" "(+ 1 1)" "(mean [1 1 1])" "(R->mean [1 1 1])" "(dsl.primary-operations/R->mean [1 1 1])" "(dsl.primary-operations/R->mean 1 1 1)" "(dsl.primary-operations/R->range 1 10)" "(dsl.composit-operations/" "(dsl.composit-operations/mean [1 1 1])" "(dsl.composit-operations/summary [1 1 1])" "(dsl.composit-operations/summary {\:x [1 1 1]})" "(dsl.composit-operations/summary {\:x (dsl.primary-operations/R->vector 1 1 1 )})" "(dsl.composit-operations/summary {\:x (dsl.composit-operations/ 1 1 1 )})" "(dsl.composit-operations/summary {\:x (dsl.composit-operations/dataframe 1 1 1 )})" " (dsl.primary-operations/R->vector 1 1 1 )" "(dsl.primary-operations/" "(dsl.primary-operations/R->boxplot 1 1 1 1)" "(dsl.primary-operations/R->boxplot [1 1 1 1])" "(dsl.primary-operations/R->rownames car)" "(dsl.primary-operations/R->rownames \\"car\\")" "(dsl.primary-operations/R->rownames 'car)" "(dsl.primary-operations/R->rownames \\"one\\" \\"two\\")" "(dsl.primary-operations/R->rownames \\"one\\")" "(codeGeneration.RC-code-generation/R->generate (dsl.composit-operations/mean 1 1 1))" "(codeGeneration.RC-code-generation/R->generate (dsl.composit-operations/matrix 1 1 1))" "(codeGeneration.RC-code-generation/R->generate (dsl.composit-operations/matrix [1 1 1]))" "(codeGeneration.RC-code-generation/R->generate (dsl.primary-operations/R->def \\"test\\" 1))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.primary-operations/R->def \\"test\\" \\n                                 (dsl.primary-operations/R->vector 1 1 1)))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.primary-operations/R->def\\n    \\"test\\" \\n    (dsl.primary-operations/R->vector [1 1 1])))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.primary-operations/R->def\\n    \\"test\\" \\n    (dsl.primary-operations/R->vector 1 1 1)))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.composit-operations/mean\\n    (dsl.primary-operations/R->def\\n        \\"test\\" \\n        (dsl.primary-operations/R->vector 1 1 1))))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.composit-operations/mean\\n    {(dsl.primary-operations/R->def\\n         \\"test\\" \\n         (dsl.primary-operations/R->vector 1 1 1))}))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.composit-operations/mean\\n    (dsl.primary-operations/R->def\\n        \\"test\\" \\n        (dsl.primary-operations/R->vector 1 1 1))))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.primary-operations/R->def \\"test\\" \\n                                 (dsl.primary-operations/R->vector 1 1 1)))" "(dsl.primary-operations/R->matrix 1 1 1)" "(codeGeneration.RC-code-generation (dsl.primary-operations/R->matrifx 1 1 1))" "(codeGeneration.RC-code-generation/ (dsl.primary-operations/R->matrifx 1 1 1))" "(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.primary-operations/R->matrifx 1 1 1))" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->matrifx 1 1 1))" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->matrix 1 1 1))" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->matrix (dsl.primary-operations/R->\= \\"x\\" 1)))" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->matrix \\n    (dsl.primary-operations/R->\= \\"x\\" \\n                                 (dsl.primary-operations/R->vector 1 1 1 1))))" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->matrix\\n    (dsl.primary-operations/R->\= \\"nrow\\" 2)\\n    (dsl.primary-operations/R->\= \\"ncol\\" 2)\\n    (dsl.primary-operations/R->\= \\"x\\" \\n                                 (dsl.primary-operations/R->vector 1 1 1 1))))" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->\=\\n    \\"myMatrix\\"\\n    (dsl.primary-operations/R->matrix\\n              (dsl.primary-operations/R->\= \\"nrow\\" 2)\\n              (dsl.primary-operations/R->\= \\"ncol\\" 2)\\n              (dsl.primary-operations/R->\= \\"x\\" \\n                                           (dsl.primary-operations/R->vector 1 1 1 1)))))" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->def\\n    \\"myMatrix\\"\\n    (dsl.primary-operations/R->matrix\\n              (dsl.primary-operations/R->\= \\"nrow\\" 2)\\n              (dsl.primary-operations/R->\= \\"ncol\\" 2)\\n              (dsl.primary-operations/R->\= \\"x\\" \\n                                           (dsl.primary-operations/R->vector 1 1 1 1)))))" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->def\\n    \\"myMatrix\\"\\n    (dsl.primary-operations/R->matrix\\n              (dsl.primary-operations/R->\= \\"nrow\\" 2)\\n              (dsl.primary-operations/R->\= \\"ncol\\" 2)\\n              (dsl.primary-operations/R->\= \\"data\\" \\n                                           (dsl.primary-operations/R->vector 1 1 1 1)))))" "(codeGeneration.RC-code-generation/R->generate\\r\\n  (dsl.primary-operations/R->def\\r\\n    \\"myMatrix\\"\\r\\n    (dsl.primary-operations/R->matrix\\r\\n      (dsl.primary-operations/R->\= \\"nrow\\" 2)\\r\\n      (dsl.primary-operations/R->\= \\"ncol\\" 2)\\r\\n      (dsl.primary-operations/R->\= \\r\\n        \\"data\\" \\r\\n        (dsl.primary-operations/R->vector 1 1 1 1)))))" "(defn matrix [num-row num-col data-vec]\\r\\n    (dsl.primary-operations/R->matrix\\r\\n      (dsl.primary-operations/R->\= \\"nrow\\" num-row)\\r\\n      (dsl.primary-operations/R->\= \\"ncol\\" num-col)\\r\\n      (dsl.primary-operations/R->\= \\r\\n        \\"data\\" \\r\\n        (dsl.primary-operations/R->vector data-vec))))" "(matrix 2 2 [1 2 3 4 5])" "(codeGeneration.RC-code-generation/R->generate (matrix 2 2 [1 2 3 4 5]))" "(defn matrix [num-row num-col data-vec]\\r\\n    (dsl.primary-operations/R->matrix\\r\\n      (dsl.primary-operations/R->\= \\"nrow\\" num-row)\\r\\n      (dsl.primary-operations/R->\= \\"ncol\\" num-col)\\r\\n      (dsl.primary-operations/R->\= \\r\\n        \\"data\\" \\r\\n        (apply dsl.primary-operations/R->vector data-vec))))" "(codeGeneration.RC-code-generation/R->generate (matrix 2 2 [1 2 3 4 5]))" "(defn matrix [num-row num-col data-vec]\\r\\n  (dsl.primary-operations/R->matrix\\r\\n    (dsl.primary-operations/R->\= \\"nrow\\" num-row)\\r\\n    (dsl.primary-operations/R->\= \\"ncol\\" num-col)\\r\\n    (dsl.primary-operations/R->\= \\r\\n      \\"data\\" \\r\\n      (apply dsl.primary-operations/R->vector data-vec))))" "(defn matrix [& data]\\r\\n  \\"attribute map\\"\\r\\n  (apply R/R->matrix (sup/stnd-input-support data [\:map \:r-srt])))" "(matrix 1 1 1 )" "(r-matrix nrow\=3 ncol\=4 (r-vec 1 2 3))" "(codeGeneration.base-operators/R->\= \\"one\\" 1)" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->def\\n    \\"myMatrix\\"\\n    (dsl.primary-operations/R->matrix\\n              (dsl.primary-operations/R->\= \\"nrow\\" 2)\\n              (dsl.primary-operations/R->\= \\"ncol\\" 2)\\n              (dsl.primary-operations/R->\= \\"x\\" \\n                                           (dsl.primary-operations/R->vector 1 1 1 1)))))" "(codeGeneration.RC-code-generation/R->generate\\r\\n  (dsl.primary-operations/R->def\\r\\n    \\"myMatrix\\"\\r\\n    (dsl.primary-operations/R->matrix\\r\\n      (dsl.primary-operations/R->\= \\"nrow\\" 2)\\r\\n      (dsl.primary-operations/R->\= \\"ncol\\" 2)\\r\\n      (dsl.primary-operations/R->\= \\r\\n        \\"data\\" \\r\\n        (dsl.primary-operations/R->vector 1 1 1 1)))))" "(codeGeneration.RC-code-generation/R->generate\\r\\n  (dsl.primary-operations/R->def\\r\\n    \\"myMatrix\\"\\r\\n    (codeGeneration.base-operators/R->matrix\\r\\n      (codeGeneration.base-operators/R->\= \\"nrow\\" 2)\\r\\n      (codeGeneration.base-operators/R->\= \\"ncol\\" 2)\\r\\n      (codeGeneration.base-operators/R->\= \\r\\n        \\"data\\" \\r\\n        (codeGeneration.base-operators/R->vector 1 1 1 1)))))" "(codeGeneration.RC-code-generation/R->generate\\r\\n  (codeGeneration.base-operators/R->def\\r\\n    \\"myMatrix\\"\\r\\n    (codeGeneration.base-operators/R->matrix\\r\\n      (codeGeneration.base-operators/R->\= \\"nrow\\" 2)\\r\\n      (codeGeneration.base-operators/R->\= \\"ncol\\" 2)\\r\\n      (codeGeneration.base-operators/R->\= \\r\\n        \\"data\\" \\r\\n        (codeGeneration.base-operators/R->vector 1 1 1 1)))))" "(defn quick-matrix [num-row num-col data-vec]\\r\\n  (codeGeneration.base-operators/R->matrix\\r\\n    (codeGeneration.base-operators/R->\= \\"nrow\\" num-row)\\r\\n    (codeGeneration.base-operators/R->\= \\"ncol\\" num-col)\\r\\n    (codeGeneration.base-operators/R->\= \\r\\n      \\"data\\" \\r\\n      (apply codeGeneration.base-operators/R->vector data-vec))))" "(quick-matrix 20 20 [3 3 3])" "(quick-matrix 20 20 (range 1 10))" "(codeGeneration.RC-code-generation/R->generate (quick-matrix 20 20 (range 1 10)))" "(codeGeneration.RC-code-generation/R->generate (quick-matrix 20 20 (R->vector 2 3 4 5)))" "(R->vector 2 3 4 5)" "(codeGeneration.RC-code-generation/R->generate (quick-matrix 20 20 (R->vector 2 3 4 5)))" "(defn matrix-simple [num-row num-col data-vec]\\r\\n  (R/R->matrix\\r\\n    (R/R->\= \\"nrow\\" num-row)\\r\\n    (R/R->\= \\"ncol\\" num-col)\\r\\n    (R/R->\= \\r\\n      \\"data\\" \\n      (cond \\n        (or (vector? data-vec) (set? data-vec)) \\r\\n        (apply R/R->vector data-vec)\\n        (\:R-struct data-vec)\\n         data-vec))))" "(require [codeGeneration.base-operators \:as R])" "(require '[codeGeneration.base-operators \:as R])" "(defn matrix-simple [num-row num-col data-vec]\\r\\n  (R/R->matrix\\r\\n    (R/R->\= \\"nrow\\" num-row)\\r\\n    (R/R->\= \\"ncol\\" num-col)\\r\\n    (R/R->\= \\r\\n      \\"data\\" \\n      (cond \\n        (or (vector? data-vec) (set? data-vec)) \\r\\n        (apply R/R->vector data-vec)\\n        (\:R-struct data-vec)\\n         data-vec))))" "(codeGeneration.RC-code-generation/R->generate (quick-matrix 20 20 (R->vector 2 3 4 5)))" "(codeGeneration.RC-code-generation/R->generate \\n  (quick-matrix 20 \\n                20 \\n                (R->vector 2 3 4 5)))" "(defn matrix-simple [num-row num-col data-vec]\\r\\n  (R/R->matrix\\r\\n    (R/R->\= \\"nrow\\" num-row)\\r\\n    (R/R->\= \\"ncol\\" num-col)\\r\\n    (R/R->\= \\r\\n      \\"data\\" \\n      (cond \\n        (or (vector? data-vec) (set? data-vec)) \\r\\n        (do (println \\"one\\" ) (apply R/R->vector data-vec))\\n        (\:R-struct data-vec)\\n         (do (println \\"two\\") data-vec)))))" "(codeGeneration.RC-code-generation/R->generate \\n  (quick-matrix 20 \\n                20 \\n                (R->vector 2 3 4 5)))" "(defn matrix-simple [num-row num-col data-vec]\\r\\n  (R/R->matrix\\r\\n    (R/R->\= \\"nrow\\" num-row)\\r\\n    (R/R->\= \\"ncol\\" num-col)\\r\\n    (R/R->\= \\r\\n      \\"data\\" \\n      (cond \\n        (or (vector? data-vec) (set? data-vec)) \\r\\n        (do (println \\"one\\" ) (apply R/R->vector data-vec))\\n        (\:R-struct data-vec)\\n         (do (println \\"two\\") data-vec)))))" "(codeGeneration.RC-code-generation/R->generate (matrix-simple 20 20 (R->vector 2 3 4 5)))" "(codeGeneration.RC-code-generation/R->generate (matrix-simple 20 20 [1 1 3 4]))" "(codeGeneration.RC-code-generation/R->generate (matrix-simple 20 20 \#{1 1 3 4}))" "(codeGeneration.RC-code-generation/R->generate (matrix-simple 20 20 {1 1 3 4}))" "(codeGeneration.RC-code-generation/R->generate (matrix-simple 20 20 \#(1 1 3 4)))" "(codeGeneration.RC-code-generation/R->generate (matrix-simple 20 20 \#{1 1 3 4}))" "(codeGeneration.RC-code-generation/R->generate (matrix-simple 20 20 \#{1  3 4}))" "(defn matrix-simple [num-row num-col data-vec]\\r\\n  \\"Creates a matrix with num-rows, num-cols and data as vector, set or R vector\\"\\r\\n  (R/R->matrix\\r\\n    (R/R->\= \\"nrow\\" num-row)\\r\\n    (R/R->\= \\"ncol\\" num-col)\\r\\n    (R/R->\= \\r\\n      \\"data\\" \\r\\n      (cond \\r\\n        (or (vector? data-vec) (set? data-vec)) \\r\\n        (apply R/R->vector data-vec)\\r\\n        (\:R-struct data-vec) \\r\\n        data-vec\\r\\n        \:default\\r\\n        (throw (Exception. (str \\"Invalid data type to matrix\\")))))))" "(codeGeneration.RC-code-generation/R->generate (matrix-simple 20 20 \#{1  3 4}))" "\\r\\n(testing \\"mean structure taking map and vector failed\\"\\r\\n         (is\\r\\n           (\= \\"matrix(nrow\=20,ncol\=20,data\=c(1,4,3))\\" \\r\\n              (gen/R->generate (mat/matrix-simple 20 20 [1  3 4])))))" "(defn matrix-configured [attribute-map]\\n  (map \#(codeGeneration.base-operators/R->\= (first %) (second %)) attribute-map))" "(matrix-configured {\:one 1 \:two 2})" "(defn matrix-configured [attribute-map]\\n  (map \#(codeGeneration.base-operators/R->\= (name (first %)) (second %)) attribute-map))" "(matrix-configured {\:one 1 \:two 2})" "(defn matrix-configured [attribute-map]\\n  (R/R-matrix \\n    (map \#(codeGeneration.base-operators/R->\= (name (first %)) (second %)) attribute-map)))" "(mat/matrix-configured {\:rnum 20 \:cnum 20 \:data (R/R->vector 1 4 3)})" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (R/R->vector 1 4 3)})" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (R->vector 1 4 3)})" "(defn matrix-configured [attribute-map]\\n  (R/R-matrix \\n    (map \#(codeGeneration.base-operators/R->\= (name (first %)) (second %)) attribute-map)))" "(mat/matrix-configured {\:rnum 20 \:cnum 20 \:data (R/R->vector 1 4 3)})" "(defn matrix-configured [attribute-map]\\r\\n  (R/R->matrix \\r\\n    (map \#(R/R->\= (name (first %)) (second %)) attribute-map)))" "(mat/matrix-configured {\:rnum 20 \:cnum 20 \:data (R/R->vector 1 4 3)})" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (R/R->vector 1 4 3)})" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (R->vector 1 4 3)})" "(matrix-configured {\:one 1 \:two 2})" "\\r\\n(defn matrix-configured [attribute-map]\\r\\n  (apply R/R->matrix \\r\\n    (map \#(fn [x] (R/R->\= (name (first x)) (second x))) attribute-map)))" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (R->vector 1 4 3)})" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (codeGeneration.base-operators/R->vector 1 4 3)})" "(matrix-configured {\:rnum 20 \:cnum 20 \:data 1})" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (codeGeneration.base-operators/R->vector 1 4 3)})" "(map \#(println (first %) (second %)) {\:one 1})" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (codeGeneration.base-operators/R->vector 1 4 3)})" "(defn matrix-configured [attribute-map]\\r\\n  (apply codeGeneration.base-operators/R->matrix \\r\\n    (map (fn [v] (codeGeneration.base-operators/R->\= (name (first v)) (second v))) attribute-map)))" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (codeGeneration.base-operators/R->vector 1 4 3)})" "(codeGeneration.RC-code-generation/R->generate\\n  (matrix-configured {\:rnum 20 \:cnum 20 \:data (codeGeneration.base-operators/R->vector 1 4 3)}))" "(codeGeneration.base-operators/R->mean [1 1])" "(defn mean-simple [& data] \\n  (codeGeneration.base-operators/R->mean\\n    (cond \\n      (> (count data) 1)\\n      (" "(codeGeneration.base-operators/R->vector 1)" "(codeGeneration.base-operators/R->vector 1 1)" "(apply codeGeneration.base-operators/R->vector [1 1])" "(apply codeGeneration.base-operators/R->vector [1 1 5 4])" "(defn mean-simple [& data] \\n    (cond\\n      (> (count data) 1)\\n      (apply codeGeneration.base-operators/R->mean data)\\n      (or (vector? (first data)) (set? (first data)))\\n      (apply codeGeneration.base-operators/R->mean (first data))))" "(mean-simple 1 3 4)" "(codeGeneration.RC-code-generation/R->generate (mean-simple 1 3 4))" "(codeGeneration.RC-code-generation/R->generate (mean-simple [1 3 4]))" "(codeGeneration.RC-code-generation/R->generate (mean-simple \#{1 3 4}))" "(codeGeneration.RC-code-generation/R->generate (mean-simple (codeGeneration.base-operators/R->vector 1 1 1)))" "(defn mean-simple [& data] \\n    (cond\\n      (> (count data) 1)\\n      (apply codeGeneration.base-operators/R->mean data)\\n      (or (vector? (first data)) (set? (first data)))\\n      (apply codeGeneration.base-operators/R->mean (first data))\\n      (\:R-struct (first data))\\n      (codeGeneration.base-operators/R->mean (first data))))" "(codeGeneration.RC-code-generation/R->generate (mean-simple (codeGeneration.base-operators/R->vector 1 1 1)))" "(defn mean-simple [& data] \\r\\n  \\"Gets mean of data, data can be numbers, vector, set or r-vector\\"\\r\\n    (cond\\r\\n      (> (count data) 1)\\r\\n      (apply codeGeneration.base-operators/R->mean data)\\r\\n      (or (vector? (first data)) (set? (first data)))\\r\\n      (apply codeGeneration.base-operators/R->mean (first data))\\r\\n      (\:R-struct (first data))\\r\\n      (codeGeneration.base-operators/R->mean (first data))))" "(codeGeneration.RC-code-generation/R->generate (mean-simple (codeGeneration.base-operators/R->vector 1 1 1)))" "(mean-simple 1 1 1)" "(codeGeneration.RC-code-generation/R->generate (mean-simple (codeGeneration.base-operators/R->vector 1 1 1)))" "(codeGeneration.RC-code-generation/R->generate (mean-simple 1 1 1))" "(defn mean-simple [& data] \\r\\n  \\"Gets mean of data, data can be numbers, vector, set or r-vector\\"\\r\\n    (cond\\r\\n      (> (count data) 1)\\r\\n      (codeGeneration.base-operators/R->mean \\r\\n       (apply codeGeneration.base-operators/R->vector data))\\r\\n      (or (vector? (first data)) (set? (first data)))\\r\\n      (codeGeneration.base-operators/R->mean \\r\\n        (apply codeGeneration.base-operators/R->vector (first data)))\\r\\n      (\:R-struct (first data))\\r\\n      (codeGeneration.base-operators/R->mean (first data))))" "(codeGeneration.RC-code-generation/R->generate (mean-simple 1 1 1))" "mean-simple 1 1 1)" "(mean-simple 1 1 1)" "(codeGeneration.base-operators/R->mean 1 1 1)" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->mean 1 1 1))" "(codeGeneration.base-operators/R->mean 1 1 1)" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->mean 1 1 1))" "(mat/matrix-configured {\:nrow 20 \:ncol 20 \:data (R/R->vector 1 4 3)}" "(mat/matrix-configured {\:nrow 20 \:ncol 20 \:data (R/R->vector 1 4 3)})" "(dsl.dsl-matrix/matrix-configured {\:nrow 20 \:ncol 20 \:data (R/R->vector 1 4 3)})" "\\r\\n(defn R->raw [data]\\r\\n  (gen/gen-R-struct \:R->mean [ data]))" "(mat/matrix-configured {\:nrow 20 \:ncol 20 \:data (R/R->vector 1 4 3)})" "(dsl.dsl-matrix/matrix-configured {\:nrow 20 \:ncol 20 \:data (R/R->vector 1 4 3)})" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->mean 1 1 1))" "(codeGeneration.RC-code-generation/R->generate (mean-simple 1 1 1))" "(mat/matrix-configured {\:nrow 20 \:ncol 20 \:data (R/R->vector 1 4 3)})" "(codeGeneration.RC-code-generation/R->generate (dsl.dsl-matrix/matrix-simple 20 20 \#{1 4 3}))" "(dsl.dsl-matrix/matrix-simple 20 20 \#{1 4 3})" "(codeGeneration.RC-code-generation/R->generate (dsl.dsl-matrix/matrix-simple 20 20 \#{1 4 3}))" "(dsl.dsl-matrix/matrix-simple 20 20 \#{1 4 3})" "(codeGeneration.RC-code-generation/R->generate {\:R-struct true, \:oper \:R->matrix, \:parms [{\:R-struct true, \:oper \:R->\=, \:parms [{\:R-struct true, \:oper \:R->raw, \:parms [\\"nrow\\"]} {\:R-struct true, \:oper \:R->raw, \:parms [20]}]} {\:R-struct true, \:oper \:R->\=, \:parms [{\:R-struct true, \:oper \:R->raw, \:parms [\\"ncol\\"]} {\:R-struct true, \:oper \:R->raw, \:parms [20]}]} {\:R-struct true, \:oper \:R->\=, \:parms [{\:R-struct true, \:oper \:R->raw, \:parms [\\"data\\"]} {\:R-struct true, \:oper \:R->vector, \:parms [{\:R-struct true, \:oper \:R->raw, \:parms [1]} {\:R-struct true, \:oper \:R->raw, \:parms [4]} {\:R-struct true, \:oper \:R->raw, \:parms [3]}]}]}]})" "(codeGeneration.RC-code-generation/R->generate \\n  {\:R-struct true, \:oper \:R->matrix, \:parms [{\:R-struct true, \:oper \:R->\=, \:parms [{\:R-struct true, \:oper \:R->raw, \:parms [\\"nrow\\"]} {\:R-struct true, \:oper \:R->raw, \:parms [20]}]} {\:R-struct true, \:oper \:R->\=, \:parms [{\:R-struct true, \:oper \:R->raw, \:parms [\\"ncol\\"]} {\:R-struct true, \:oper \:R->raw, \:parms [20]}]} {\:R-struct true, \:oper \:R->\=, \:parms [{\:R-struct true, \:oper \:R->raw, \:parms [\\"data\\"]} {\:R-struct true, \:oper \:R->vector, \:parms [{\:R-struct true, \:oper \:R->raw, \:parms [1]} {\:R-struct true, \:oper \:R->raw, \:parms [4]} {\:R-struct true, \:oper \:R->raw, \:parms [3]}]}]}]})" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->\= 1 1))" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->\= \\n                                                 (codeGeneration.base-operators/R->raw 1)\\n                                                 (codeGeneration.base-operators/R->raw 1)))" " (codeGeneration.base-operators/R->\= \\n   (codeGeneration.base-operators/R->raw 1)\\n   (codeGeneration.base-operators/R->raw 1))" "\\r\\n(defn R->raw [data]\\r\\n  (assoc (gen/gen-R-struct \:R->raw [ data]) \:raw true))" "(R->raw 4)" "\\r\\n(defn R->raw [data]\\r\\n  (assoc (gen/gen-R-struct \:R->raw [ data]) \:raw true))" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->\= \\n                                                 (codeGeneration.base-operators/R->raw 1)\\n                                                 (codeGeneration.base-operators/R->raw 1)))" "(codeGeneration.base-operators/R->\= \\n  (codeGeneration.base-operators/R->raw 1)\\n  (codeGeneration.base-operators/R->raw 1))" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->\= \\n                                                 (codeGeneration.base-operators/R->raw 1)\\n                                                 (codeGeneration.base-operators/R->raw 1)))" "(codeGeneration.base-operators/R->\= \\n  (codeGeneration.base-operators/R->raw 1)\\n  (codeGeneration.base-operators/R->raw 1))" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->\= \\n                                                 (codeGeneration.base-operators/R->raw 1)\\n                                                 (codeGeneration.base-operators/R->raw 1)))" "(codeGeneration.RC-code-generation/R->generate\\n                                                (codeGeneration.base-operators/R->raw 1))" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->raw 1))" " (codeGeneration.base-operators/R->raw 1)" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->raw 1))" " (codeGeneration.base-operators/R->raw 1)" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->raw 1))" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->\= \\n                                                 (codeGeneration.base-operators/R->raw 1)\\n                                                 (codeGeneration.base-operators/R->raw 1)))" "(codeGeneration.RC-code-generation/R->generate (dsl.dsl-matrix/matrix-simple 20 20 \#{1 4 3}))" "(dsl.dsl-matrix/matrix-simple 10 10 [1 2 3])" "(codeGeneration.RC-code-generation/R->generate (dsl.dsl-matrix/matrix-simple 20 20 \#{1 4 3}))" "(codeGeneration.RC-code-generation/R->generate (dsl.dsl-matrix/matrix-simple 20 20 [1 4 3]))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.dsl-matrix/matrix-simple 20 20 (codeGeneration.base-operators/R->vector 1 2 3))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.dsl-matrix/matrix-simple 20 20 (codeGeneration.base-operators/R->vector 1 2 3)))" "\\n  (dsl.dsl-matrix/matrix-simple 20 20 (codeGeneration.base-operators/R->vector 1 2 3))" "(dsl.dsl-vector 1 2 3)" "(dsl.dsl-vector/vector-simple 1 2 3)" "(codeGeneration.RC-code-generation/R->generate  (dsl.dsl-vector/vector-simple 1 2 3))" "(dsl.dsl-vector/vector-simple 1 2 3)" "(codeGeneration.RC-code-generation/R->generate  (dsl.dsl-vector/vector-simple 1 2 3))" "\\n  (dsl.dsl-matrix/matrix-simple 20 20 (dsl.dsl-vector/vector-simple 1 2 3))" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-simple 20 20 (dsl.dsl-vector/vector-simple 1 2 3)))" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured 20 20 (dsl.dsl-vector/vector-simple 1 2 3)))" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f 40}))" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)}))" "\\n;(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)})" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)}))" "\\n;(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)})" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)}))" "\\n;(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)})" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)}))" "\\n;(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)})" "(seq? {})" "\\n;(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)})" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)}))" "(dsl.dsl-mean (dsl.dsl-vector 1 2 34))" "(dsl.dsl-mean/mean-simple (dsl.dsl-vector 1 2 34))" "(dsl.dsl-mean/mean-simple (dsl.dsl-vector/vector-simple 1 2 34))" "(dsl.dsl-mean/mean-simple 1 2 3)" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)}))" "(mean/mean-simple 1 1 1)" "(gen/R->generate (mean/mean-simple 1 1 1))" "(R->generate (mean/mean-simple 1 2 3))" "(R->generate (mean/mean-simple 1 2 3)(mean/mean-simple 1 2 3))" "(generate (mean/mean-simple 2 3 4))" "(mean-configured {\:one 1})" "(class [])" "(defmulti mean [& x]\\n (cond \\n   (and (\= (count x) 1) (map? (first x)))\\n   \\"map\\"))" "(defmulti mean (fn [& x]\\n (cond \\n   (and (\= (count x) 1) (map? (first x)))\\n   \\"map\\")))" "(defmethod mean \\"map\\"  (fn [x] x))" "(defmethod mean \\"map\\"  [x] x)" "(mean {\:test 1})" "(defmulti mean (fn [& x]\\n (cond \\n   (and (\= (count x) 1) (map? (first x)))\\n   \\"map\\")))" "(defmethod mean \\"map\\"  [x] x)" "(mean {\:test 1})" "(defmethod mean \\"raw\\"  [x] x)" "(defmulti mean (fn [& x]\\n (cond \\n   (and (\= (count x) 1) (map? (first x)))\\n   \\"map\\"\\n   (and (map )))" "(defmulti mean (fn [& x]\\n (cond \\n   (and (\= (count x) 1) (map? (first x)))\\n   \\"map\\"\\n   (and (map \#(not (coll? x)) x))\\n   \\"raw\\"))" "(defmulti mean (fn [& x]\\n (cond \\n   (and (\= (count x) 1) (map? (first x)))\\n   \\"map\\"\\n   (and (map \#(not (coll? x)) x))\\n   \\"raw\\")))" "(mean {\:test 1})" "(mean 1 1 1)" "(defmulti mean (fn [& x]\\n (cond \\n   (and (\= (count x) 1) (map? (first x)))\\n   \\"map\\"\\n   (and (map \#(not (coll? x)) x))\\n   \\"raw\\"\\n   \:default\\n   \\"error\\")))" "(defmethod mean \\"error\\"  [x] (println \\"Error has occured\: \\" x))" "(mean 1 1 1)" "(defmulti mean (fn [& x]\\n (cond \\n   (and (\= (count x) 1) (map? (first x)))\\n   \\"map\\"\\n   (and (map \#(not (coll? x)) x))\\n   \\"raw\\"\\n   \:default\\n   \\"error\\")))" "(mean [1 1 1])" "(defmulti mean (fn [& x]\\n (cond \\n   (and (\= (count x) 1) (map? (first x)))\\n   \\"map\\"\\n   (and (map \#(not (coll? %)) x))\\n   \\"raw\\"\\n   \:default\\n   \\"error\\")))" "(mean [1 1 1])" "(mean 1 1 1)" "(defmulti mean (fn [& x]\\n (cond \\n   (and (\= (count x) 1) (map? (first x)))\\n   \\"map\\"\\n   (and (map \#(not (coll? %)) x))\\n   \\"raw\\"\\n   \:default\\n   \\"error\\")))" "(mean 1 1 1)" "(defmulti mean \\n  (fn [& x]\\n  (do (println x)  \\n   (cond \\n     (and (\= (count x) 1) (map? (first x)))\\n     \\"map\\"\\n     (and (map \#(not (coll? %)) x))\\n     \\"raw\\"\\n     \:default\\n     \\"error\\"))))" "(mean 1 1 1)" "(mean {\:test 1})" "(defmulti mean \\n  (fn [& x]\\n  (do (println x)  \\n   (cond \\n     (and (\= (count x) 1) (map? (first x)))\\n     \\"map\\"\\n     (and (map \#(not (coll? %)) x))\\n     \\"raw\\"\\n     \:default\\n     \\"error\\"))))" "(mean {\:test 1})" "(defmulti mean \\n  (fn [& x]\\n  (do (println x)  \\n   (cond \\n     (and (\= (count x) 1) (map? (first x)))\\n     \\"map\\"\\n     (and (map \#(not (coll? %)) x))\\n     \\"raw\\"\\n     \:default\\n     \\"error\\"))))" "(defmethod mean \\"error\\"  [x] (println \\"Error has occured\: \\" x))" "(defmethod mean \\"raw\\"  [x] x)" "(defmethod mean \\"map\\"  [x] x)" "(mean {\:test 1})" "(mean 1 1 1)" "(mean {})" "(defmethod mean \\"error\\"  [x] (println \\"Error has occured\: \\" x))" "(defmulti mean \\n  (fn [& x]\\n  (do (println x)  \\n   (cond \\n     (and (\= (count x) 1) (map? (first x)))\\n     \\"map\\"\\n     (string? (first x))\\n     \\"string\\"\\n     (and (map \#(not (coll? %)) x))\\n     \\"raw\\"\\n     \:default\\n     \\"error\\"))))" "(defmethod mean \\"string\\"  [x] (println \\"strg\: \\" x))" "(mean \\"t\\")" "(defmethod mean \\"string\\"  [x] x)" "(mean \\"t\\")" "(defmulti mean \\n  (fn [& x]\\n  (do (println x)  \\n   (cond \\n     (and (\= (count x) 1) (map? (first x)))\\n     \\"map\\"\\n     (string? (first x))\\n     \\"string\\"\\n     (and (map \#(not (coll? %)) x))\\n     \\"raw\\"\\n     \:default\\n     \\"error\\"))))" "(mean \\"t\\")" "(defmulti mean \\n  (fn [& x]  \\n   (cond \\n     (and (\= (count x) 1) (map? (first x)))\\n     \\"map\\"\\n     (string? (first x))\\n     \\"string\\"\\n     (and (map \#(not (coll? %)) x))\\n     \\"raw\\"\\n     \:default\\n     \\"error\\")))" "(mean \\"t\\")" "(defmethod mean nil  [x] \\"test\\"\\n  )" "(mean \\"t\\")" "(defmulti mean \\n  (fn [& x]  \\n   (cond  \\n     (string? (first x))\\n     \\"string\\"\\n     (and (\= (count x) 1) (map? (first x)))\\r\\n     \\"map\\"\\n     (and (map \#(not (coll? %)) x))\\n     \\"raw\\"\\n     \:default\\n     \\"error\\")))" "(mean {\:test 1})" "(mean \\"t\\")" "(mean 1 1 1)" "(defmulti mean \\n  (fn [& x]  \\n   (if  \\n     (string? (first x))\\n     \\"string\\"\\n     (if\\n       (and (\= (count x) 1) (map? (first x)))\\r\\n       \\"map\\"\\n       (if\\n         (and (map \#(not (coll? %)) x))\\n         \\"raw\\"\\n         \\"error\\")))))" "(mean 1 1 1)" "(mean \\"t\\")" "(mean {\:test 1})" "(mapv class [1 \\"s\\"])" "(defmulti mean \\n  (fn [& x]  \\n   (cond  \\n     (string? (first x))\\n     \\"string\\"\\n     (and (\= (count x) 1) (map? (first x)))\\r\\n     \\"map\\"\\n     (and (map \#(not (coll? %)) x))\\n     \\"raw\\"\\n     \:default\\n     \\"error\\")))" "(defmethod mean \\"string\\"  [& x] x)" "(defmethod mean \\"error\\"  [& x] (println \\"Error has occured\: \\" x))" "(defmethod mean \\"map\\"  [& x] x)" "(mean {\:test 1})" "(mean \\"t\\")" "(defmulti mean \\n  (fn [& x]  \\n   (cond  \\n     (string? (first x))\\n     \\"string\\"\\n     (and (\= (count x) 1) (map? (first x)))\\r\\n     \\"map\\"\\n     (and (map \#(not (coll? %)) x))\\n     \\"raw\\"\\n     \:default\\n     \\"error\\")))" "(mean {\:test 1})" "(let  [ x '(1)]\\n   (cond  \\n     (string? (first x))\\n     \\"string\\"\\n     (and (\= (count x) 1) (map? (first x)))\\r\\n     \\"map\\"\\n     (and (map \#(not (coll? %)) x))\\n     \\"raw\\"\\n     \:default\\n     \\"error\\"))" "(let  [ x []]\\n   (cond  \\n     (string? (first x))\\n     \\"string\\"\\n     (and (\= (count x) 1) (map? (first x)))\\r\\n     \\"map\\"\\n     (and (map \#(not (coll? %)) x))\\n     \\"raw\\"\\n     \:default\\n     \\"error\\"))" "(let  [ x \\"s\\"]\\n   (cond  \\n     (string? (first x))\\n     \\"string\\"\\n     (and (\= (count x) 1) (map? (first x)))\\r\\n     \\"map\\"\\n     (and (map \#(not (coll? %)) x))\\n     \\"raw\\"\\n     \:default\\n     \\"error\\"))" "(let  [ x '(\\"s\\")]\\n   (cond  \\n     (string? (first x))\\n     \\"string\\"\\n     (and (\= (count x) 1) (map? (first x)))\\r\\n     \\"map\\"\\n     (and (map \#(not (coll? %)) x))\\n     \\"raw\\"\\n     \:default\\n     \\"error\\"))" "(defmulti mean \\n  (fn [x]  \\n   (cond  \\n     (string? (first x))\\n     \\"string\\"\\n     (and (\= (count x) 1) (map? (first x)))\\r\\n     \\"map\\"\\n     (and (map \#(not (coll? %)) x))\\n     \\"raw\\"\\n     \:default\\n     \\"error\\")))" "(mean '({}))" "(mean {})" "(mean \\"t\\")" "(mean '(\\"t\\"))" "(defmulti mean (fn[x] x))" "(defmethod \\"one\\" [x] \\"one\\")" "(defmethod mean \\"one\\" [x] \\"one\\")" "(defmethod mean \\"two\\" [x] \\"two\\")" "(mean \\"one\\")" "(defmethod mean \\"one\\" [x] \\"one\\")" "(defmulti mean \\n  (fn [x]  \\n   (cond  \\n     (string? (first x))\\n     \\"string\\"\\n     (and (\= (count x) 1) (map? (first x)))\\r\\n     \\"map\\"\\n     (and (map \#(not (coll? %)) x))\\n     \\"raw\\"\\n     \:default\\n     \\"error\\")))" "(defmethod mean \\"error\\"  [x] (println \\"Error has occured\: \\" x))" "(defmethod mean \\"string\\"  [& x] x)" "(defmethod mean \\"map\\"  [& x] x)" "(mean \\"one\\")" "(defmethod mean \\"raw\\"  [x] x)" "(mean \\"one\\")" "(mean {\:test 1})" "(mean 2 1 1)" "(and (map \#(not (coll? %)) [1 2 3]))" "(apply and (map \#(not (coll? %)) [1 2 3]))" "(reduce  \#(\= (not (coll? %1)) (not (coll? %2)))  [1 2 3])" "(reduce  \#(\= (not (coll? %1)) (not (coll? %2)))  [1 2 [3]])" "(reduce  \#(\= (not (coll? %1)) (not (coll? %2)))  [[1] 2 3])" "(reduce  \#(\= %1 (not (coll? %2))) true [ 2 3])" "(reduce  \#(\= %1 (not (coll? %2))) true [ 4 3])" "(reduce  \#(\= %1 (not (coll? %2))) true [ [4] 3])" "(reduce  \#(\= %1 (not (coll? %2))) true [4 [3]])" "(reduce  \#(\= %1 (not (coll? %2))) true [4 \\"e\\"])" "(defmulti mean \\n  (fn [x]  \\n   (cond  \\n     (string? (first x))\\n     \\"string\\"\\n     (and (\= (count x) 1) (map? (first x)))\\r\\n     \\"map\\"\\n     (reduce  \#(\= %1 (not (coll? %2))) true x)\\n     \\"raw\\"\\n     \:default\\n     \\"error\\")))" "(mean 2 1 1)" "(defmulti mean \\n  (fn [x]  \\n   (cond  \\n     (string? (first x))\\n     \\"string\\"\\n     (and (\= (count x) 1) (map? (first x)))\\r\\n     \\"map\\"\\n     \:default\\n     \\"error\\")))" "(mean 2 1 1)" "(defmulti mean \\n  (fn [& x]  \\n   (cond  \\n     (string? (first x))\\n     \\"string\\"\\n     (and (\= (count x) 1) (map? (first x)))\\r\\n     \\"map\\"\\n     \:default\\n     \\"error\\")))" "(mean 2 1 1)" "(defmethod mean \\"raw\\"  [& x] x)" "(mean 2 1 1)" "(defmethod mean \\"raw\\"  [& x] x)" "(defmethod mean \\"map\\"  [& x] x)" "(defmulti mean \\n  (fn [& x]  \\n   (cond  \\n     (string? (first x))\\n     \\"string\\"\\n     (and (\= (count x) 1) (map? (first x)))\\r\\n     \\"map\\"\\n     \:default\\n     \\"error\\")))" "(mean 2 1 1)" "(defmethod mean \\"error\\"  [& x] (println \\"Error has occured\: \\" x))" "(mean 2 1 1)" "(defmulti mean (fn[& x] \\n                 (cond \\n                   (map? (first x))\\n                   \\"map\\")))" "(defmulti mean \\"map\\" [x] x)" "(defmethod mean \\"map\\" [x] x)" "(mean {\:one 1})" "(defmulti mean (fn[& x] \\n                 (cond \\n                   (map? (first x))\\n                   \\"map\\"\\n                   (vec? (first x))\\n                   \\"vec\\")))" "(defmulti mean (fn[& x] \\n                 (cond \\n                   (map? (first x))\\n                   \\"map\\"\\n                   (vector? (first x))\\n                   \\"vec\\")))" "(mean [2 ])" "(defmulti mean (fn[& x] \\n                 (if\\n                   (map? (first x))\\n                   \\"map\\"\\n                   \\"vec\\")))" "(defmulti mean \\"map\\" [& x] x)" "(defmethod mean \\"map\\" [x] x)" "(defmethod mean \\"vec\\" [x] x)" "(defmulti mean (fn[& x] \\n                 (if\\n                   (map? (first x))\\n                   \\"map\\"\\n                   \\"vec\\")))" "(mean [2 ])" "(defmulti mean (fn[& x] \\n                 (if\\n                   (map? (first x))\\n                   \\"map\\"\\n                   \\"vec\\")))" "(mean {\:one 1})" "(defmulti mean (fn[& x] \\n                 (if\\n                   (map? (first x))\\n                   \\"map\\"\\n                   \\"vec\\")))" "(mean [2])" "(defn tm [& x] \\n  (cond \\n    (map? (first x))\\n    \\"map\\"\\n    (vector? (first x))\\n    \\"vec\\"))" "(tm \\"one\\")" "(tm {})" "(tm [])" "(defmulti mean (fn[& x] \\n                 (cond \\n                   (map? (first x))\\n                   \\"map\\"\\n                   (vector? (first x))\\n                   \\"vec\\")))" "(defmethod mean \\"map\\" [x] x)" "(defmethod mean \\"map\\" [& x] x)" "(defmethod mean \\"vec\\" [& x] x)" "(tm [])" "(mean [])" "(defmulti mean (fn[& x] \\n                 (first x)))" "(mean \\"vec\\")" "(mean \\"map\\")" "(defmulti mean (fn [& x] \\n                  x))" "(mean \\"map\\")" "(defmulti mean (fn [ x] \\n                  x))" "(mean \\"map\\")" "(defmulti mean (fn [ x] \\n                  \\"map\\"))" "(mean \\"map\\")" "(defmulti greeting\\r\\n  (fn[x] (x \\"language\\")))\\r\\n\\r\\n;params is not used, so we could have used [_]\\r\\n(defmethod greeting \\"English\\" [params]\\r\\n \\"Hello\!\\")\\r\\n\\r\\n(defmethod greeting \\"French\\" [params]\\r\\n \\"Bonjour\!\\")" "(def english-map {\\"id\\" \\"1\\", \\"language\\" \\"English\\"})\\r\\n(def  french-map {\\"id\\" \\"2\\", \\"language\\" \\"French\\"})\\r\\n(def spanish-map {\\"id\\" \\"3\\", \\"language\\" \\"Spanish\\"})" "(greeting english-map)" "(defmulti tm (fn[x] x))" "(defmulti tm \\"x\\" [x] (println x))" "(defmethod tm \\"x\\" [x] (println x))" "(tm \\"x\\")" "(defmulti tm (fn[x] x))" "(defmethod tm \\"x\\" [x] (println x))" "(tm \\"x\\")" "(defmulti tm (fn[x]\\n               (cond \\n                 (\= \\"x\\" x)\\n                 x)))" "(tm \\"x\\")" "(defmulti tm (fn[x]\\n               (cond \\n                 (\= \\"x\\" x)\\n                 x\\n                 \:default\\n                 \\"default\\")))" "(tm \\"x\\")" "(tm \\"d\\")" "(defmulti tm (fn[x]\\n               (cond \\n                 (\= \\"x\\" x)\\n                 x\\n                 \:default\\n                 \\"error\\")))" "(defmethod tm \\"error\\" [x] (println x))" "(tm \\"error\\")" "(defmulti tm (fn[& x]\\n               (cond \\n                 (\= \\"x\\" (first x))\\n                 x\\n                 \:default\\n                 \\"error\\")))" "(tm \\"error\\")" "(tm \\"x\\")" "(defmulti mean (fn[& x]\\n                 (cond \\n                   (\= \\"x\\" (first x))\\n                   x\\n                   \:default\\n                   \\"error\\")))" "(defmethod mean \\"error\\" [x] (println x))" "(defmethod mean \\"x\\" [x] (println x))" "(mean \\"x\\")" "(defmethod mean-gen \\"x\\" [x] (println x))" "(defmulti mean-gen (fn[& x]\\n             (cond \\n               (\= \\"x\\" (first x))\\n               x\\n               \:default\\n               \\"error\\")))" "(defmethod mean-gen \\"x\\" [x] (println x))" "(defmethod mean-gen \\"error\\" [x] (println x))" "(mean-gen \\"x\\")" "(tm \\"x\\")" "(defmulti mean-gen (fn[& x]\\n             (cond \\n               (\= \\"x\\" (first x))\\n               x\\n               \:default\\n               \\"error\\")))" "(defmethod mean-gen \\"error\\" [x] (println x))" "(defmethod mean-gen \\"x\\" [x] (println x))" "(mean-gen \\"x\\")" "(tm \\"x\\")" "(defmulti tm (fn[& x]\\n               (cond \\n                 (\= \\"x\\" (first x))\\n                 x\\n                 \:default\\n                 \\"error\\")))" "(defmethod tm \\"error\\" [x] (println x))" "(defmethod tm \\"x\\" [x] (println x))" "(tm \\"x\\")" "(defmulti tm (fn[& x]\\n               (cond \\n                 (map? (first x))\\n                 x\\n                 \:default\\n                 \\"error\\")))" "(defmethod tm \\"map\\" [x] (println x))" "(defmethod tm \\"error\\" [x] (println \\"error\: \\" x))" "(defmulti tm (fn[& x]\\n               (cond \\n                 (map? (first x))\\n                 \\"map\\"\\n                 \:default\\n                 \\"error\\")))" "(tm {\:test 1})" "(tm \\"one\\")" "(defmethod tm \\"map\\" [x] (println x))" "(tm {\:test 1})" "(defmulti tm (fn[& x]\\n               (cond \\n                 (map? (first x))\\n                 \\"map\\"\\n                 \:default\\n                 \\"error\\")))" "(defmethod tm \\"map\\" [x] (println x))" "(tm {\:test 1})" "(defmulti tm (fn[& x]\\n               (cond \\n                 (map? (first x))\\n                 \\"map\\"\\n                 \:default\\n                 \\"error\\")))" "(tm {\:test 1})" "(defmulti tm (fn[& x]\\n               (cond \\n                 (map? (first x))\\n                 \\"map\\"\\n                 \:default\\n                 \\"error\\")))" "(tm {\:test 1})" "(defmulti tm (fn[& x]\\n               (cond \\n                 (map? (first x))\\n                 \\"map\\"\\n                 \:default\\n                 \\"error\\")))" "(defmethod tm \\"map\\" [x] (println x))" "(tm {\:test 1})" "(tm 1)" "(defmethod tm \\"error\\" [x] (println x))" "(tm 1)" "(defmethod tm \\"error\\" [x] (println x))" "(tm 1)" "(tm {\:test 1})" "(defmulti tm (fn[& x]\\n               (cond \\n                 (map? (first x))\\n                 \\"map\\"\\n                 (String (first x))\\n                 \\"str\\"\\n                 \:default\\n                 \\"error\\")))" "(defmulti tm (fn[& x]\\n               (cond \\n                 (map? (first x))\\n                 \\"map\\"\\n                 (string? (first x))\\n                 \\"str\\"\\n                 \:default\\n                 \\"error\\")))" "(defmethod tm \\"str\\" [x] (println \\"str\: \\"  x))" "(defmethod tm \\"error\\" [x] (println \\"Error\: \\" x))" "(defmethod tm \\"map\\" [x] (println \\"map \: \\" x))" "(tm {\:test 1})" "(tm 1)" "(tm \\"s\\")" "(defmulti tm (fn[& x]\\n               (cond \\n                 (map? (first x))\\n                 \\"map\\"\\n                 (string? (first x))\\n                 \\"str\\"\\n                 \:default\\n                 \\"error\\")))" "(defmethod tm \\"str\\" [x] (println \\"str\: \\"  x))" "(tm \\"s\\")" "(tm \\"sf\\")" "(tm {\:test 1})" "(defmulti tm (fn[& x]\\n               (cond \\n                 (map? (first x))\\n                 \\"map\\"\\n                 (string? (first x))\\n                 \\"str\\"\\n                 \:default\\n                 \\"error\\")))" "(defmethod tm \\"str\\" [x] (println \\"str\: \\"  x))" "(defmethod tm \\"map\\" [x] (println \\"map \: \\" x))" "(defmethod tm \\"error\\" [x] (println \\"Error\: \\" x))" "(tm \\"s\\")" "(tm 1)" "(tm {})" "(defmulti tm (fn[& x]\\n               (cond \\n                 (map? (first x))\\n                 \\"map\\"\\n                 (reduce \#(\= %1 (not (coll? %2))) true x)\\n                 (string? (first x))\\n                 \\"str\\"\\n                 \:default\\n                 \\"error\\")))" "(defmulti tm (fn[& x]\\n               (cond \\n                 (map? (first x))\\n                 \\"map\\"\\n                 (reduce \#(\= %1 (not (coll? %2))) true x)\\n                 \\"raw\\"\\n                 (string? (first x))\\n                 \\"str\\"\\n                 \:default\\n                 \\"error\\")))" "(defmethod tm \\"raw\\" [x] (println \\"raw\: \\" x))" "(tm 1 1 1)" "(tm [1 1 1])" "(defmethod tm \\"raw\\" [& x] (println \\"raw\: \\" x))" "(tm [1 1 1])" "(tm 1 1 1)" "(defmulti tm (fn[& x]\\n               (cond \\n                 (map? (first x))\\n                 \\"map\\"\\n                 (reduce \#(\= %1 (not (coll? %2))) true x)\\n                 \\"raw\\"\\n                 (string? (first x))\\n                 \\"str\\"\\n                 \:default\\n                 \\"error\\")))" "(tm 1 1 1)" "(defmulti tm (fn[& x]\\n               (cond \\n                 (map? (first x))\\n                 \\"map\\"\\n                 (reduce \#(\= %1 (not (coll? %2))) true x)\\n                 \\"raw\\"\\n                 (string? (first x))\\n                 \\"str\\"\\n                 \:default\\n                 \\"error\\")))" "(defmethod tm \\"raw\\" [& x] (println \\"raw\: \\" x))" "(tm 1 1 1)" "(defmethod tm \\"error\\" [x] (println \\"Error\: \\" x))" "(defmethod tm \\"map\\" [x] (println \\"map \: \\" x))" "(defmethod tm \\"str\\" [x] (println \\"str\: \\"  x))" "(defmulti tm (fn[& x]\\n               (cond \\n                 (map? (first x))\\n                 \\"map\\"\\n                 (reduce \#(\= %1 (not (coll? %2))) true x)\\n                 \\"raw\\"\\n                 (string? (first x))\\n                 \\"str\\"\\n                 \:default\\n                 \\"error\\")))" "(tm {})" "(tm \\"gt\\")" "(defmacro r-funct-dispatch [name]\\n  `(defmulti ~name (fn[& x]\\n                     (cond \\n                       (and (map? (first x) (\:r-struct (first x))))\\n                       \:map\\n                       (reduce \#(\= %1 (not (coll? %2))) true x)\\n                       \:raw\\n                       (string? (first x))\\n                       \:str\\n                       (vector? (first x))\\n                       \:vec\\n                       (\:r-struct (first x))\\n                       \:r-struct\\n                       \:default\\n                       \:error))))" "(macroexpand r-funct-dispatch \\"test\\")" "(macroexpand r-funct-dispatch test)" "(macroexpand '(r-funct-dispatch \\"test\\"))" "(macroexpand '(r-funct-dispatch test))" "(r-funct-dispatch tt)" "(defmacro r-funct-dispatch [name]\\n  (let [name-var (gensym)]\\n  `(defmulti ~name (fn[& ~name-var]\\n                     (cond \\n                       (and (map? (first ~name-var) (\:r-struct (first ~name-var))))\\n                       \:map\\n                       (reduce \#(\= %1 (not (coll? %2))) true ~name-var)\\n                       \:raw\\n                       (string? (first ~name-var))\\n                       \:str\\n                       (vector? (first ~name-var))\\n                       \:vec\\n                       (\:r-struct (first ~name-var))\\n                       \:r-struct\\n                       \:default\\n                       \:error))))" "(defmacro r-funct-dispatch [name]\\n  (let [name-var (gensym)]\\n  `(defmulti ~name (fn[& ~name-var]\\n                     (cond \\n                       (and (map? (first ~name-var) (\:r-struct (first ~name-var))))\\n                       \:map\\n                       (reduce \#(\= %1 (not (coll? %2))) true ~name-var)\\n                       \:raw\\n                       (string? (first ~name-var))\\n                       \:str\\n                       (vector? (first ~name-var))\\n                       \:vec\\n                       (\:r-struct (first ~name-var))\\n                       \:r-struct\\n                       \:default\\n                       \:error)))))" "(r-funct-dispatch tt)" "(defmethod tt \:map [x] (println \\"t\: \\" x))" "(tt {})" "\\r\\n(defmacro r-funct-dispatch [name]\\r\\n  (let [name-var (gensym)]\\r\\n  `(defmulti ~name (fn[& ~name-var]\\r\\n                     (cond \\r\\n                       (and (map? (first ~name-var)) (\:r-struct (first ~name-var)))\\r\\n                       \:map\\r\\n                       (reduce \#(\= %1 (not (coll? %2))) true ~name-var)\\r\\n                       \:raw\\r\\n                       (string? (first ~name-var))\\r\\n                       \:str\\r\\n                       (vector? (first ~name-var))\\r\\n                       \:vec\\r\\n                       (\:r-struct (first ~name-var))\\r\\n                       \:r-struct\\r\\n                       \:default\\r\\n                       \:error)))))" "(defmethod tt \:map [x] (println \\"t\: \\" x))" "(tt {})" "(r-funct-dispatch aa)" "(defmethod aa \:map [x] (println x))" "(aa {})" "\\r\\n(defmacro r-funct-dispatch [name]\\r\\n  (let [name-var (gensym)]\\r\\n  `(defmulti ~name (fn[& ~name-var]\\r\\n                     (cond \\r\\n                       (and (map? (first ~name-var)) (not (\:r-struct (first ~name-var))))\\r\\n                       \:map\\r\\n                       (reduce \#(\= %1 (not (coll? %2))) true ~name-var)\\r\\n                       \:raw\\r\\n                       (string? (first ~name-var))\\r\\n                       \:str\\r\\n                       (vector? (first ~name-var))\\r\\n                       \:vec\\r\\n                       (\:r-struct (first ~name-var))\\r\\n                       \:r-struct\\r\\n                       \:default\\r\\n                       \:error)))))" "(r-funct-dispatch ab)" "(defmethod ab \:map [x] (println x))" "(ab {})" "(support.RC-support/r-funct-dispatch boxplot)" "(boxplot {\:one 1})" "(support.RC-support/r-funct-dispatch boxplot)" "(defmethod boxplot \:map [x] (println \\"test\\"))" "(boxplot \\"test\\")" "(boxplot {})" "(dsl.dsl-boxplot/boxplot {})" "(box/boxplot {\:x (vector/vector-simple 1 1 1) })" "(generate (box/boxplot {\:x (vector/vector-simple 1 1 1) }))" "(generate (box/boxplot {\:x (vector/vector-simple 1 2 3 4 54) }))" "(generate (dsl.dsl-dotchart {\:x (dsl.dsl-vector 1 2 3)}))" "(generate (dsl.dsl-dotchart/dotchart-attributes {\:x (dsl.dsl-vector 1 2 3)}))" "(generate (dsl.dsl-dotchart/dotchart-attributes {\:x (dsl.dsl-vector/ 1 2 3)}))" "(generate (dsl.dsl-dotchart/dotchart-attributes {\:x (dsl.dsl-vector/vector-simple 1 2 3)}))" "(box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})" "(generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)}))" "(first (generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "(str (generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "(apply str (generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "(class (generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "(doall (generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "(do (generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "(force (generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "(seq (generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "(doseq (generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "(do (generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "(do (str (generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)}))))" "(do str (generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "(def w (generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "w" "(first w)" "(str w)" "(seq w)" "(box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})" "(def data (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)}))" "data" "(generate data)" "(transformation.code-generation/R->generate data)" "(transformation.code-generation/R->generate-command data)" "(transformation.code-generation/R->generate data)" "(count (transformation.code-generation/R->generate data))" "(transformation.code-generation/R->generate data)" "(doall (transformation.code-generation/R->generate data))" "(transformation.code-generation/R->generate-command data)" "(generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)}))" "(transformation.code-generation/R->generate-command (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)}))" "(transformation.code-generation/R->generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)}))" "(realized? (transformation.code-generation/R->generate \\n             (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "(transformation.code-generation/R->generate (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)}))" "(realized? (transformation.code-generation/R->generate \\n             (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "(seq (transformation.code-generation/R->generate \\n       (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "(string (transformation.code-generation/R->generate \\n          (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "( (transformation.code-generation/R->generate \\n    (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "(transformation.code-generation/R->generate \\n  (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)}))" "(first (transformation.code-generation/R->generate \\n         (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})))" "(transformation.code-generation/R->generate \\n  (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)}))" "(transformation.code-generation/R->generate \\n  (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)})(box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)}))" "(transformation.code-generation/R->generate \\n  (box/boxplot-attributes {\:x (vector/vector-simple 1 2 3)}))" "(dsl.dsl-boxplot {\:x (dsl.dsl-vector (range 10)) \:y (dsl.dsl-vector (range 10))})" "(dsl.dsl-boxplot/boxplot-attributes {\:x (dsl.dsl-vector/vector-simple (range 10)) \:y (dsl.dsl-vector/sim (range 10))})" "(dsl.dsl-boxplot/boxplot-attributes {\:x (dsl.dsl-vector/vector-simple (range 10)) \\n                                     \:y (dsl.dsl-vector/vector-simple (range 10))})" "(generate (dsl.dsl-boxplot/boxplot-attributes {\:x (dsl.dsl-vector/vector-simple (range 10)) \\n                                          \:y (dsl.dsl-vector/vector-simple (range 10))}))" "(generate (dsl.dsl-mean/mean-simple (dsl.dsl-vector (range 1 10))))" "(generate (dsl.dsl-mean/mean-simple (dsl.dsl-vector/vector-simple (range 1 10))))" "(dsl.dsl-histogram/dotchart-attributes {\:x (dsl.dsl-vector/vector-simple 1 3 4 4)})" "(generate (dsl.dsl-histogram/dotchart-attributes {\:x (dsl.dsl-vector/vector-simple 1 3 4 4)}))" "(generate (dsl.dsl-boxplot/boxplot-attributes {\:x (dsl.dsl-vector 1 2 3 4 5 6)}))" "(generate (dsl.dsl-boxplot/boxplot-attributes {\:x (dsl.dsl-vector/ 1 2 3 4 5 6)}))" "(generate (dsl.dsl-boxplot/boxplot-attributes {\:x (dsl.dsl-vector/vector-simple 1 2 3 4 5 6)}))" "(dsl.dsl-boxplot/boxplot-attributes {\:x (dsl.dsl-vector/vector-simple 1 2 3 4 5 6)})" "(dsl.dsl-mean/mean-simple (dsl.dsl-vector 1 2 3 4))" "(dsl.dsl-mean/mean-simple (dsl.dsl-vector/vector-simple 1 2 3 4))" "(generate (dsl.dsl-mean/mean-simple (dsl.dsl-vector/vector-simple 1 2 3 4)))" "(let [vectors [[1 1 2][3 4 5]]]\\n     (transformation.R-struct-gen/R->dataframe \\n       (for [a-vec vectors]\\n         (a-vect))))" "(let [vectors [[1 1 2][3 4 5]]]\\n     (transformation.R-struct-gen/R->dataframe \\n       (for [a-vec vectors]\\n         (str a-vec))))" "(let [vectors [[1 1 2][3 4 5]]]\\n     (transformation.R-struct-gen/R->dataframe \\n       (for [a-vec vectors]\\n         (transformation.R-struct-gen/R->vector a-vec))))" "(let [vectors [[1 1 2][3 4 5]]]\\n     (transformation.R-struct-gen/R->dataframe \\n       (for [a-vec vectors]\\n         (transformation.R-struct-gen/R->vector \\n           (map transformation.R-struct-gen/R->raw a-vec)))))" "(generate (let [vectors [[1 1 2][3 4 5]]]\\n           (transformation.R-struct-gen/R->dataframe \\n             (for [a-vec vectors]\\n               (transformation.R-struct-gen/R->vector \\n                 (map transformation.R-struct-gen/R->raw a-vec))))))" "(generate (let [vectors [[1 1 2][3 4 5]]]\\n           (transformation.R-struct-gen/R->dataframe \\n             (for [a-vec vectors]\\n               (appy transformation.R-struct-gen/R->vector \\n                 (map transformation.R-struct-gen/R->raw a-vec))))))" "(generate (let [vectors [[1 1 2][3 4 5]]]\\n           (transformation.R-struct-gen/R->dataframe \\n             (for [a-vec vectors]\\n               (apply transformation.R-struct-gen/R->vector \\n                 (map transformation.R-struct-gen/R->raw a-vec))))))" "(let [vectors [[1 1 2][3 4 5]]]\\n (transformation.R-struct-gen/R->dataframe \\n   (for [a-vec vectors]\\n     (apply transformation.R-struct-gen/R->vector \\n       (map transformation.R-struct-gen/R->raw a-vec)))))" "(let [vectors [[1 1 2][3 4 5]]]\\n (appy transformation.R-struct-gen/R->dataframe \\n   (for [a-vec vectors]\\n     (apply transformation.R-struct-gen/R->vector \\n       (map transformation.R-struct-gen/R->raw a-vec)))))" "(let [vectors [[1 1 2][3 4 5]]]\\n (apply transformation.R-struct-gen/R->dataframe \\n   (for [a-vec vectors]\\n     (apply transformation.R-struct-gen/R->vector \\n       (map transformation.R-struct-gen/R->raw a-vec)))))" "(generate \\n  (let [vectors [[1 1 2][3 4 5]]]\\n   (apply transformation.R-struct-gen/R->dataframe \\n     (for [a-vec vectors]\\n       (apply transformation.R-struct-gen/R->vector \\n         (map transformation.R-struct-gen/R->raw a-vec))))))" "testDrivenDev.dsl-dataframe-test/perform-test" "(testDrivenDev.dsl-dataframe-test/perform-test)" "(gen/R->generate (df/dataframe-vec [1 1 2][3 4 5])" "(gen/R->generate (df/dataframe-vec [1 1 2][3 4 5]))" "(generate (df/dataframe-vec [1 1 2][3 4 5]))" "(generate (dsl.dsl-dataframe/dataframe-vec [1 1 2][3 4 5]))" "(generate (df/dataframe-vec [1 1 2][3 4 5]))" "(testDrivenDev.dsl-dataframe-test/perform-test)" "(defn dataframe-variables [& vectors]\\r\\n  \\"takes clojure vectors or sets and creates a dataframe\\"\\r\\n   (apply transformation.R-struct-gen/R->dataframe vectors))" "(generate (dotchart-attributes {\:data (dataframe-vec [1 23] [3 5])}))" "(generate (dotchart-attributes {\:x (dataframe-vec [1 23] [3 5])}))" "(generate (boxplot-attributes {\:x (dataframe-vec [1 23] [3 5])}))" "(generate (boxplot-attributes {\:x (dataframe-vec  [3 5])}))" "(repeatedly 5 (rand-int 10))" "(rand-int 10)" "(take 10 (repeatedly(rand-int 10)))" "(take 10 (rand-int 10))" "(repeat 10 (rand-int 10))" "(repeatedly 10 (rand-int 10))" "(repeatedly 10 \#(rand-int 10))" "(generate (boxplot-attributes \\n            {\:x (dataframe-vec (into [] (repeatedly 10 \#(rand-int 10)))\\n                               (into [] (repeatedly 20 \#(rand-int 10))))}))" "(generate (boxplot-attributes \\n            {\:x (dataframe-vec \\n                  (repeatedly 5\\n                              (into [] (repeatedly 100 \#(rand-int 10)))))}))" "(generate (boxplot-attributes \\n            {\:x (apply dataframe-vec \\n                  (repeatedly 5\\n                              (into [] (repeatedly 100 \#(rand-int 10)))))}))" "(generate (boxplot-attributes \\n            {\:x (apply dataframe-vec \\n                  (repeatedly 5\\n                              \#(into [] (repeatedly 100 \#(rand-int 10)))))}))" "(generate (boxplot-attributes \\n            {\:x (apply dataframe-vec \\n                  (repeatedly 5\\n                              (fn [] (into [] (repeatedly 100 \#(rand-int 10))))))}))" "(testDrivenDev.integration-test/box-and-frame)" "(generate (boxplot-attributes \\n            {\:x (apply dataframe-vec \\n                  (repeatedly 5\\n                              (fn [] (into [] (repeatedly 10 \#(rand-int 100))))))}))" "(generate\\n  (dsl.dsl-dataframe/dataframe-variables \\n    (dsl.dsl-vector/vector-simple 1 2 3)\\n    (dsl.dsl-vector/vector-simple 1 2 3)))" "(generate\\n  (dsl.dsl-dataframe/dataframe-variables \\n    (transformation.R-thin-client/R->\=\\n      \\"test1\\" (dsl.dsl-vector/vector-simple 1 2 3))\\n    (transformation.R-thin-client/R->\=\\n      \\"test2\\"\\n      (dsl.dsl-vector/vector-simple 1 2 3))))" "(generate\\n  (dsl.dsl-dataframe/dataframe-variables \\n    (transformation.R-struct-gen/R->\=\\n      \\"test1\\" (dsl.dsl-vector/vector-simple 1 2 3))\\n    (transformation.R-struct-gen/R->\=\\n      \\"test2\\"\\n      (dsl.dsl-vector/vector-simple 1 2 3))))" "(generate\\n  (dsl.dsl-dataframe/dataframe-variables \\n    (transformation.R-struct-gen/R->\=\\n      (transformation.R-struct-gen/R->raw \\"test1\\")\\n      (dsl.dsl-vector/vector-simple 1 2 3))\\n    (transformation.R-struct-gen/R->\=\\n      (transformation.R-struct-gen/R->raw \\"test2\\")\\n      (dsl.dsl-vector/vector-simple 1 2 3))))" "(generate\\n  (dataframe-variables \\n    (R->\=\\n      (R->raw \\"test1\\")\\n      (vector-simple 1 2 3))\\n    (R->\=\\n      (R->raw \\"test2\\")\\n      (vector-simple 1 2 3))))" "  (dataframe-variables \\n    (R->\=\\n      (R->raw \\"test1\\")\\n      (vector-simple 1 2 3))\\n    (R->\=\\n      (R->raw \\"test2\\")\\n      (vector-simple 1 2 3)))" "(generate\\n  (dataframe-variables \\n    (sg/R->\=\\n      (sg/R->raw \\"test1\\")\\n      (vector-simple 1 2 3))\\n    (sg/R->\=\\n      (sg/R->raw \\"test2\\")\\n      (vector-simple 1 2 3))))" "  (dataframe-variables \\n    (R->\=\\n      (R->raw \\"test1\\")\\n      (vector-simple 1 2 3))\\n    (R->\=\\n      (R->raw \\"test2\\")\\n      (vector-simple 1 2 3)))" "(generate\\n  (dataframe-variables \\n    (R->\=\\n      (R->raw \\"test1\\")\\n      (vector-simple 1 2 3))\\n    (R->\=\\n      (R->raw \\"test2\\")\\n      (vector-simple 1 2 3))))" " (require \\r\\n    '[transformation.code-generation \:refer [R->generate] \:rename {R->generate generate}]\\r\\n    '[dsl.dsl-mean \:refer \:all]\\r\\n    '[dsl.dsl-matrix \:refer \:all]\\r\\n    '[dsl.dsl-vector \:refer \:all]\\r\\n    '[dsl.dsl-boxplot \:refer \:all]\\r\\n    '[dsl.dsl-dotchart \:refer \:all]\\r\\n    '[dsl.dsl-dataframe \:refer \:all]\\r\\n    '[transformation.R-struct-gen \:refer \:all]\\r\\n    '[transformation.R-thin-client \:as tc])" "(generate\\n  (dataframe-variables \\n    (R->\=\\n      (R->raw \\"test1\\")\\n      (vector-simple 1 2 3))\\n    (R->\=\\n      (R->raw \\"test2\\")\\n      (vector-simple 1 2 3))))" "(transformation.code-generation \\"fail\\")" "(transformation.code-generation/R->generate \\"fail\\")" "(generate\\n  (dataframe-variables \\n    (R->\=\\n      (R->raw \\"test1\\")\\n      (vector-simple 1 2 3))\\n    (R->\=\\n      (R->raw \\"test2\\")\\n      (vector-simple 1 2 3))))" "(generate\\n  (dataframe-variables \\n    (R->\=\\n      (R->raw \\"test1\\")\\n      (vector-simple 1 2 3))\\n    (R->\=\\n      \\"test2\\"\\n      (vector-simple 1 2 3))))" "(generate\\n  (dataframe-variables \\n    (R->\=\\n      (R->raw \\"test1\\")\\n      (vector-simple 1 2 3))\\n    (R->\=\\n      (R->raw \\"test2\\")\\n      (vector-simple 1 2 3))))" "(slurp \\"cran-config.txt\\")" "(slurp \\"config/cran-config.txt\\")" "(split \\"\\\\n\\" (slurp \\"config/cran-config.txt\\")" "(split \\"\\\\n\\" (slurp \\"config/cran-config.txt\\"))" "(.split \\"\\\\n\\" (slurp \\"config/cran-config.txt\\"))" "(clojure.string/split (slurp \\"config/cran-config.txt\\") \\"\\\\n\\")" "(clojure.string/split (slurp \\"config/cran-config.txt\\") \#\\"\\\\n\\")" "(clojure.string/split (clojure.string/replace (slurp \\"config/cran-config.txt\\") \#\\"\\\\n\\") \#\\"\\\\r\\" \\"\\")" "(clojure.string/split (clojure.string/replace (slurp \\"config/cran-config.txt\\") \#\\"\\\\r\\" \\"\\") \#\\"\\\\n\\")" "(read (slurp \\"config/cran-config.txt\\"))" "(eval (slurp \\"config/cran-config.txt\\"))" "(read (slurp \\"config/cran-config.txt\\"))" "(read-string (slurp \\"config/cran-config.txt\\"))" "(integration.apps.interface-cran/cran-config-map)" "integration.apps.interface-cran/cran-config-map" "(slurp \\"clojure-R-config.txt\\")" "(slurp \\"cran-config.txt\\")" "(slurp \\"config/clojure-R-config.txt\\")" "(read-string (slurp \\"config/clojure-R-config.txt\\"))" "\\r\\n(defn get-config []\\r\\n  (try\\r\\n    (read-string (slurp \\"config/clojure-R-config.txt\\"))\\r\\n    (catch Exception ex \\r\\n      (log/error \\"cannot load clojure-R-config will default to dev instance\\"))))" "    \\r\\n(defn handler [request]\\r\\n  (do (str request)\\r\\n  {\:status 200\\r\\n   \:headers {\\"Content-Type\\" \\"text/html\\"}\\r\\n   \:body \\"Hello World\\"}))" "(defn handler [request]\\r\\n  (do (println request)\\r\\n  {\:status 200\\r\\n   \:headers {\\"Content-Type\\" \\"text/html\\"}\\r\\n   \:body \\"Hello World\\"}))" "\\r\\n(defn handler [request]\\r\\n  {\:status 200\\r\\n   \:headers {\\"Content-Type\\" \\"text/html\\"}\\r\\n   \:body request})" "(+ 1 1)" "cran-config-map" "(def cran-config-map\\r\\n  (try\\r\\n    (read-string (slurp \\"config/cran-config.txt\\"))\\r\\n  (catch Exception ex\\r\\n    (do (log/error \\"Cannot load cran config from file. Loading default configuration.\\")\\r\\n      default-cran-config-map))))" "cran-config-map" "(read-string (slurp \\"config/cran-config.txt\\"))" "  (try\\r\\n    (read-string (slurp \\"config/cran-config.txt\\"))\\r\\n  (catch Exception ex\\r\\n    (do (log/error \\"Cannot load cran config from file. Loading default configuration.\\")\\r\\n      default-cran-config-map)))" "  (try\\r\\n    (read-string (slurp \\"config/cran-config.txt\\"))\\r\\n  (catch Exception ex\\r\\n    (do (clojure.tools.logging/error \\"Cannot load cran config from file. Loading default configuration.\\")\\r\\n      default-cran-config-map)))" "  (try\\r\\n    (read-string (slurp \\"config/cran-config.txt\\"))\\r\\n  (catch Exception ex\\r\\n    (do (clojure.tools.logging/error \\"Cannot load cran config from file. Loading default configuration.\\")\\r\\n     {})))" "(def cran-config-map\\r\\n  (try\\r\\n    (read-string (slurp \\"config/cran-config.txt\\"))\\r\\n  (catch Exception ex\\r\\n    (do (log/error \\"Cannot load cran config from file. Loading default configuration.\\")\\r\\n      default-cran-config-map))))" "cran-config-map" "(cran-config-map)" "(def cran-config-map\\r\\n  (try\\r\\n    (read-string (slurp \\"config/crran-config.txt\\"))\\r\\n  (catch Exception ex\\r\\n    (do (log/error \\"Cannot load cran config from file. Loading default configuration.\\")\\r\\n      default-cran-config-map))))" "  (try\\r\\n    (read-string (slurp \\"config/dcran-config.txt\\"))\\r\\n  (catch Exception ex\\r\\n    (do (clojure.tools.logging/error \\"Cannot load cran config from file. Loading default configuration.\\")\\r\\n     {})))" "cran-config-map" "(get-request-clojure {\:query-string  \\"cljin\=test\\"})" "(defn get-request-clojure [request]\\r\\n  (clojure.string/replace \\r\\n   (\:query-string request) \\r\\n    \#(str (\:param-name cran-config-map) \\"\=\\") \\"\\"))" "\\r\\n  (clojure.string/replace \\r\\n   (\:query-string  {\:query-string  \\"cljin\=test\\"}) \\r\\n    \#(str (\:param-name cran-config-map) \\"\=\\") \\"\\")" "\\r\\n  (clojure.string/replace \\r\\n   (\:query-string  {\:query-string  \\"cljin\=test\\"}) \\r\\n    (str (\:param-name cran-config-map) \\"\=\\") \\"\\")" "(get-request-clojure {\:query-string  \\"cljin\=test\\"})" "\\r\\n(defn clojure-R-transform [clojure-string]\\r\\n  (read-string clojure-string))" "(rc.core/clojure-R-transform \\"(println \\\\\\"test\\\\\\")\\")" "(eval (rc.core/clojure-R-transform \\"(println \\\\\\"test\\\\\\")\\"))" "(rc.core/clojure-R-transform \\"(println \\\\\\"test\\\\\\")\\")" "(rc.core/clojure-R-transform \\"(mean-simple 1 2 3)\\")" "(ser/run-jetty handler {\:port (\:port cran-config-map)})" "(code/percent-decode \\"(mean-simple%203%204%205)\\")" "(rc.core/clojure-R-transform (code/percent-decode \\"(mean-simple%203%204%205)\\"))" "(rc.core/clojure-R-transform \\"(mean-simple 3 4 5)\\" )" "(rc.core/clojure-R-transform \\"(println \\\\\\"test\\\\\\")\\")" "(rc.core/clojure-R-transform \\"(+ 1 1)\\")" "(rc.core/clojure-R-transform (code/percent-decode \\"(mean-simple%203%204%205)\\"))" "(rc.core/clojure-R-transform \\"(mean-simple 3 4 5)\\" )" "(rc.core/clojure-R-transform \\"(dsl.dsl-mean/mean-simple 3 4 5)\\" )" "(rc.core/clojure-R-transform \\"(mean-simple 3 4 5)\\" )" "(rc.core/clojure-R-transform \\"(dsl.dsl-mean/mean-simple 3 4 5)\\" )" "(rc.core/clojure-R-transform \\"(mean-simple 3 4 5)\\" )" "(mean-simple 1 2 3)" "(clojure-R-transform \\"(mean-simple 1 2 3)\\")" "(code/percent-decode \\"(mean-simple%203%204%205)\\")" "(ser/run-jetty handler {\:port (\:port cran-config-map)})" "(rc.core/clojure-R-transform \\"(mean-simple 3 4 5)\\" )" "(ns 'rc.core)" "(ns rc.core)" "(clojure-R-transform \\"(mean-simple 3 4 5)\\" )" "(rc.core/clojure-R-transform \\"(mean-simple 3 4 5)\\" )" "(ns rc.core)" "(rc.core/clojure-R-transform \\"(mean-simple 3 4 5)\\" )" "(use 'rc.core)" "(rc.core/clojure-R-transform \\"(mean-simple 3 4 5)\\" )" "(require 'rc.core)" "(rc.core/clojure-R-transform \\"(mean-simple 3 4 5)\\" )" "(require 'rc.core \:load)" "(import 'rc.core)" "(require 'rc.core \:reload)" "(rc.core/clojure-R-transform \\"(mean-simple 3 4 5)\\" )" "(require 'rc.core \:reload-all)" "(rc.core/clojure-R-transform \\"(mean-simple 3 4 5)\\" )" "(ns-publics transformation.R-struct-gen)" "(ns-publics 'transformation.R-struct-gen)" "(ns-publics 'rc.core)" "(ns-refers 'rc.core)" "(ns-imports 'rc.core)" "(ns-refers 'rc.core)" "(filter \#(clojure.string/%2) (ns-refers 'rc.corea)" "(instance? clojure.core 'clojure.core/refer )" "(instance? 'clojure.core 'clojure.core/refer )" "\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n(+ 1 1)" "(defn \= (print \\"test\\"))" "(defn \= [] \\n  (println \\"test\\"))" "(\=)" "(defn \= [left right] \\n  (str left \\"\=\\" right))" "(\= 1 3)" "(read-string \\"(+ 1 1)\\")" "(read-string \\"(+ 1 (+ 1 1))\\")" "(flatten (read-string \\"(+ 1 (+ 1 1))\\"))" " (clojure.string/replace (read-string \\"(+ 1 (+ 1 1))\\") \\"(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 (+ 1 1))\\") \#\\"(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 (+ 1 1))\\") \#\\"\\\\(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ( + 1 1))\\") \#\\"\\\\(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 (    + 1 1))\\") \#\\"\\\\(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ((+ 1 1))\\") \#\\"\\\\(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ((+ 1 1)))\\") \#\\"\\\\(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ((+ 1 1)))\\") \#\\"\\\\(?<\!()(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ((+ 1 1)))\\") \#\\"\\\\(?<\!\\\\()\\\\(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ((+ 1 1)))\\") \#\\"(?<\!\\\\()\\\\(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ((+ 1 1)))\\") \#\\"(?<\=\\\\()\\\\(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ((((+ 1 1)))))\\") \#\\"(?<\=\\\\()\\\\(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ((((+ 1 1)))))\\") \#\\"(?<\!\\\\()\\\\(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ((((+ 1 1)))))\\") \#\\"(?\=\!\\\\()\\\\(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ((((+ 1 1)))))\\") \#\\"(?\=\\\\()\\\\(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ((((+ 1 1)))))\\") \#\\"(?\=\!\\\\()\\\\(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ((((+ 1 1)))))\\") \#\\"(?\=\\\\()\\\\(\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ((((+ 1 1)))))\\") \#\\"\\\\((?\=\\\\()\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ((((+ 1 1)))))\\") \#\\"\\\\((?\=\!\\\\()\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ((((+ 1 1)))))\\") \#\\"\\\\((?\!\\\\()\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"\#(+ 1 ((((+ 1 1)))))\\") \#\\"\\\\((?\!\\\\()\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"\#(1 1)\\") \#\\"\\\\((?\!\\\\()\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 ((((+ 1 1)))))\\") \#\\"\\\\((?\!\\\\()\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ 1 (+ 1 1))\\") \#\\"\\\\((?\!\\\\()\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ (- 1 1) (+ 1 1))\\") \#\\"\\\\((?\!\\\\()\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ (- 1 1) (+ 1 1))\\") \#\\"\\\\((?\!\\\\() && \\\\((?\!~)\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ (- 1 1) (+ 1 1))\\") \#\\"\\\\((?\!\\\\() || \\\\((?\!~)\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ (- 1 1) (+ 1 1))\\") \#\\"\\\\((?\!\\\\() && \\\\((?\!\\\\~)\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ (- 1 1) (+ 1 1))\\") \#\\"\\\\((?\!\\\\()\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ (- 1 1) (+ 1 1))\\") \#\\"\\\\([(?\!\\\\() (?\!\\\\~)\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ (- 1 1) (+ 1 1))\\") \#\\"\\\\([(?\!\\\\() (?\!\\\\~)]\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ (- 1 1) (+ 1 1))\\") \#\\"\\\\(^[(?\!\\\\() (?\!\\\\~)]\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ (- 1 1) (+ 1 1))\\") \#\\"(?\!\\\\~)\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ (- 1 1) (+ 1 1))\\") \#\\"(?\!~)\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ (- 1 1) (+ 1 1))\\") \#\\"\\\\( (?\!~)\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ (- 1 1) (+ 1 1))\\") \#\\"\\\\( (?~)\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ (- 1 1) (+ 1 1))\\") \#\\"\\\\((?\=~)\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(+ (- 1 1) (+ 1 1))\\") \#\\"\\\\((?\!\=~)\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"(~+ (- 1 1) (+ 1 1))\\") \#\\"\\\\((?\!\=~)\\" \\"(R->\\")" " (clojure.string/replace (read-string \\"~(+ (- 1 1) (+ 1 1))\\") \#\\"\\\\((?\!\=~)\\" \\"(R->\\")" " (clojure.string/replace ~(+ (- 1 1) (+ 1 1)) \#\\"\\\\((?\!\=~)\\" \\"(R->\\")" " (clojure.string/replace \\"~(+ (- 1 1) (+ 1 1))\\" \#\\"\\\\((?\!\=~)\\" \\"(R->\\")" " (clojure.string/replace \\"(~ + (- 1 1) (+ 1 1))\\" \#\\"\\\\((?\!\=~)\\" \\"(R->\\")" " (clojure.string/replace \\"(~+ (- 1 1) (+ 1 1))\\" \#\\"\\\\((?\!\=~)\\" \\"(R->\\")" " (clojure.string/replace \\"(~+ (- 1 1) (+ 1 1))\\" \#\\"\\\\((?\=~)\\" \\"(R->\\")" " (clojure.string/replace \\"(~+ (- 1 1) (+ 1 1))\\" \#\\"\\\\ ^((?\=~)\\" \\"(R->\\")" " (clojure.string/replace \\"(~+ (- 1 1) (+ 1 1))\\" \#\\"\\\\(^(?\=~)\\" \\"(R->\\")" " (clojure.string/replace \\"(~+ (- 1 1) (+ 1 1))\\" \#\\"\\\\((?\!\=~)\\" \\"(R->\\")" " (clojure.string/replace \\"~(+ (- 1 1) (+ 1 1))\\" \#\\"\\\\((?\!\=~)\\" \\"(R->\\")" " (clojure.string/replace \\"~(+ (- 1 1) (+ 1 1))\\" \#\\"(?\!\=~)\\\\(\\" \\"(R->\\")" " (clojure.string/replace \\"~(+ (- 1 1) (+ 1 1))\\" \#\\"(?\!~)\\\\(\\" \\"(R->\\")" " (clojure.string/replace \\"~(+ (- 1 1) (+ 1 1))\\" \#\\"(?<\!~)\\\\(\\" \\"(R->\\")" " (clojure.string/replace \\"~(+ (- 1 1) (+ 1 1))\\" \#\\"(?<\!~)\\\\((?\!\\\\))\\" \\"(R->\\")" " (clojure.string/replace \\"~(+ (- 1 1) (((+ 1 1))))\\" \#\\"(?<\!~)\\\\((?\!\\\\))\\" \\"(R->\\")" " (clojure.string/replace \\"~(+ (- 1 1) (((+ 1 1))))\\" \#\\"(?<\!~)\\\\((?\!\\\\()\\" \\"(R->\\")" "(defn condition-string [in-str]\\r\\n (clojure.string/remove \\r\\n  (clojure.string/replace in-str \#\\"(?<\!\#\#)\\\\((?\!\\\\()\\" \\"(R->\\")\\r\\n  \#\\"\#\#(\\" \\"(\\"))" "(defn condition-string [in-str]\\r\\n (clojure.string/remove \\r\\n  (clojure.string/replace in-str \#\\"(?<\!\#\#)\\\\((?\!\\\\()\\" \\"(R->\\")\\r\\n  \#\\"\#\#\\\\(\\" \\"(\\"))" "(defn condition-string [in-str]\\r\\n (clojure.string/replace\\r\\n  (clojure.string/replace in-str \#\\"(?<\!\#\#)\\\\((?\!\\\\()\\" \\"(R->\\")\\r\\n  \#\\"\#\#\\\\(\\" \\"(\\"))" "(defn condition-string [in-str]\\r\\n  (clojure.string/replace\\r\\n    (clojure.string/replace in-str \#\\"(?<\!\#\#)\\\\((?\!\\\\()\\" \\"(R->\\")\\r\\n    \#\\"\#\#\\\\(\\" \\"(\\"))" "(condition-string \\"(+ 1 ~(range 20))\\")" "(condition-string \\"(+ 1 \#\#(range 20))\\")" "(condition-string \\"((+ 1 \#\#(range 20)))\\")" "(clojure-R-transform \\"(+ 1 1)\\")" "(clojure-R-transform \\"\#\#(+ 1 1)\\")" "(clojure-R-transform \\"(raw \#\#(+ 1 1))\\")" "(clojure-R-transform \\"(range 1 2)\\")" "(clojure-R-transform \\"(range (raw 1) (raw 2))\\")" "(clojure-R-transform \\"(mean-simple (range (raw 1) (raw 2)))\\")" "\\r\\n(defn R->number [val]\\r\\n  (assoc (gen-R-struct \:R->number [val]) \:type \:num))" "(rc.core/clojure-R-transform \\"(range 1 20)\\")" "(dsl.dsl-R-core/R->range 34 30)" "(rc.core/clojure-R-transform \\"(range 1 20)\\")" "(R->generate {\:R-struct true, \:oper \:R->range, \:parms [{\:R-struct true, \:oper \:R->number, \:parms [34]} {\:R-struct true, \:oper \:R->number, \:parms [30]}]})" "(rc.core/clojure-R-transform \\"(range 1 20)\\")" "(R->range 1 10)" "(clojure-R-transform \\"(range 1 10)\\")" "(R->def a 4)" "(R->def 'a 4)" "(R->def \\"a\\" 4)" "(R/R->def \\"a\\" 4)" "(R/R->def (R/R->raw \\"a\\") (R/R->raw 4))" "(R/R->raw 4)" "(R/R->raw \\"a\\")" "(R/R->def (R/R->raw \\"a\\") (R/R->raw 4))" "(R->print \\"test\\")" "(defmacro testM [val]\\n  `(print (str ~val)))" "(testM a)" "(testM \:a)" "(testM 'a)" "(eval \\"(vector \\\\\\"te\\\\\\"\\")" "(read-string \\"(vector \\\\\\"te\\\\\\"\\")" "(read-string \\"(vector \\\\\\"te\\\\\\")\\")" "(rc.core/clojure-R-transform \\"(print \\\\\\"test\\\\\\")\\")" "(read-string \\"(print \\\\\\"test\\\\\\")\\")" "(R->print \\"test\\")" "(R->generate (R->print \\"test\\"))" "(str \\"\\\\\\"\\" \\"test\\" \\"\\\\\\"\\")" "(str (str \\"\\\\\\"\\" \\"test\\" \\"\\\\\\"\\") \\"stuff\\")" "(R->generate (R->print \\"test\\"))" "(read-string \\"(def 'a \\\\\\"test\\\\\\")\\")" "(R->def (quote a) \\"test\\")" "(R->generate (R->def (quote a) \\"test\\"))" "(condition-string \\"(mean 1 2 3)\\")" "(condition-string \\"(\!r-mean 1 2 3)\\")" "\\r\\n(defn condition-string [in-str]\\r\\n  (clojure.string/replace\\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\!\\\\\!r-)\\" \\"(R->\\")\\r\\n    \#\\"\\\\((?\\\\p{\!}r-)\\" \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\r\\n  (clojure.string/replace\\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\!\\\\\!r-)\\" \\"(R->\\")\\r\\n    \#\\"\\\\((?\\\\p{punc}r-)\\" \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\r\\n  (clojure.string/replace\\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\!\\\\\!r-)\\" \\"(R->\\")\\r\\n    \#\\"\\\\((?\\\\p{Punct}r-)\\" \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  \\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\!\\\\\!r-)\\" \\"(R->\\"))" "(condition-string \\"(mean 1 2 3)\\")" "(condition-string \\"(\!r-mean 1 2 3)\\")" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\!\\\\\!r-)\\" \\"(R->\\")\\n  \#\\"\\\\((?\!\\\\\!r-)\\" \\n  \\"(R->\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\!\\\\\!r-)\\" \\"(R->\\")\\n  \#\\"\\\\((?\\\\\!r-)\\" \\n  \\"(R->\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\!\\\\\!r-)\\" \\"(R->\\")\\n  \#\\"\\\\((?\!r-)\\" \\n  \\"(R->\\"))" "(condition-string \\"(\!r-mean 1 2 3)\\")" "(condition-string \\"(mean 1 2 3)\\")" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\!\\\\\!r-)\\" \\"(R->\\")\\n  \#\\"\\\\((? \!r-)\\" \\n  \\"(R->\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\!\\\\\!r-)\\" \\"(R->\\")\\n  \#\\"\\\\((?\\\\\!r-)\\" \\n  \\"(R->\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\!\\\\\!r-)\\" \\"(R->\\")\\n  \#\\"\\\\((?r-)\\" \\n  \\"(R->\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\!\\\\\!r-)\\" \\"(R->\\")\\n    \#\\"\\\\((?\=r-)\\" \\n  \\"(R->\\"))" "(condition-string \\"(mean 1 2 3)\\")" "(condition-string \\"(\!r-mean 1 2 3)\\")" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\!\\\\\!r-)\\" \\"(R->\\")\\n    \#\\"\\\\((?\=r-)\\" \\n  \\"(\\"))" "(condition-string \\"(\!r-mean 1 2 3)\\")" "(condition-string \\"(mean 1 2 3)\\")" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\!\\\\\!r-)\\" \\"(R->\\")\\n    \#\\"\\\\((?\=\!r-)\\" \\n  \\"(\\"))" "(condition-string \\"(mean 1 2 3)\\")" "(condition-string \\"(\!r-mean 1 2 3)\\")" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\!\\\\\!r-)\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "(condition-string \\"(\!r-mean 1 2 3)\\")" "(condition-string \\"(mean 1 2 3)\\")" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\!\\\\\!r-)\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "(condition-string \\"(mean 1 2 3)\\")" "(condition-string \\"((((mean 1 2 3)\\")" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\([(?\=\!r-)(?\=\\\\()]\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\([(?\=\\\\\!r-)(?\=\\\\()]\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\([(?\=\\\\\!r-) (?\=\\\\()]\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\([(?\=\!r-) (?\=()]\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\([(?\=\!r-) (?\=\\\\()]\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\([(?\=\!r-)]\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\=\!r-)\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\( (?\=\!r-)\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\([(?\=\!r-)]\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\=\!r-) || \\\\((?\=\!r-)\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\=\!r-) || \\\\((?\=\!\\\\(\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\((?\=\!r-) || \\\\((?\=\\\\()\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "(condition-string \\"(mean 1 2 3)\\")" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\([(?\=\!r-) || (?\=\\\\()]\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\(((?\=\!r-) || (?\=\\\\())&&r\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\(((?\=\!r-) || (?\=\\\\())&&/(\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\(((?\=\!r-) || (?\=\\\\())&&\\\\(\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "(condition-string \\"(mean 1 2 3)\\")" "(condition-string \\"(\!r-mean 1 2 3)\\")" "(condition-string \\"(mean 1 2 3)\\")" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"\\\\(^((?\=\!r-) || (?\=\\\\())&&\\\\(\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "(condition-string \\"(mean 1 2 3)\\")" "(condition-string \\"(\!r-mean 1 2 3)\\")" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"^(\\\\((?\=\!r-) || |((?\=\\\\())&&\\\\(\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"^(\\\\((?\=\!r-) || |\\\\((?\=\\\\())&&\\\\(\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "(condition-string \\"(\!r-mean 1 2 3)\\")" "(condition-string \\"(mean 1 2 3)\\")" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"^((\\\\((?\=\!r-)) || |(\\\\((?\=\\\\()))&&\\\\(\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "(condition-string \\"(mean 1 2 3)\\")" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"^((\\\\((?\=\!r-)) || (\\\\((?\=\\\\()))&&\\\\(\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "(condition-string \\"(mean 1 2 3)\\")" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"^((\\\\((?\=\!r-)) || (\\\\((?\=\\\\()))\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "(condition-string \\"(mean 1 2 3)\\")" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"^((\\\\((?\=\!r-)) || (\\\\((?\=\\\\()))&&(?\=/()\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"^((\\\\((?\=\!r-)) || (\\\\((?\=\\\\()))&&(?\=()\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"^((\\\\((?\=\!r-)) || (\\\\((?\=\\\\()))&&(?\=/()\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "\\r\\n(defn condition-string [in-str]\\n  (clojure.string/replace  \\r\\n    (clojure.string/replace in-str \#\\"^((\\\\((?\=\!r-)) || (\\\\((?\=\\\\()))&&(?\=\\\\()\\" \\"(R->\\")\\n    \#\\"\\\\(\!r-\\" \\n  \\"(\\"))" "(condition-string \\"(mean 1 2 3)\\")" "(condition-string \\"(\!r-mean 1 2 3)\\")" "(read-string \\"(lskjd d)\\")" "(read-string \\"(lskjd \\\\\\"d\\\\\\")\\")" "(clojure.string/trim (read-string \\"(lskjd \\\\\\"d\\\\\\")\\")J)" "(clojure.string/trim (read-string \\"(lskjd \\\\\\"d\\\\\\")\\"))" "(read-string \\"(lskjd \\\\\\"d\\\\\\")\\")"]
eclipse.preferences.version=1
