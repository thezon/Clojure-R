cmdhistory=["(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond \\n                        (> (count data) 1) (apply R->vector data)\\n                        (vector? data) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\n                        \:defulat (println \\"fail\\"))]))" "(R->mean 1 2 3)" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond \\n                        (> (count data) 1) (apply R->vector data)\\n                        (vector? data) (R->vector (first data))\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\n                        \:defulat (println \\"fail\\"))]))" "(R->mean 1 2 3)" "(R-generate (R->mean 1 2 3))" "(R-generate (R->mean (R->vector 1 2 3)))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond \\n                        (> (count data) 1) (apply R->vector data)\\n                        (vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        \:defulat (println \\"fail\\"))]))" "(R-generate (R->mean (R->vector 1 2 3)))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond \\n                        (> (count data) 1) (apply R->vector data)\\n                        (vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean {\:x 2}))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond \\n                        (> (count data) 1) (apply R->vector data)\\n                        (vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (into [] (apply partition 2 data)))))\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean {\:x 2}))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond \\n                        (> (count data) 1) (apply R->vector data)\\n                        (vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (into [] (apply partition 2 data)))))\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean {\:x 2}))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond \\n                        (> (count data) 1) (apply R->vector data)\\n                        (vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean {\:x 2}))" "(R-generate (R->mean {\:x 2 \:y 4}))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\n                        (vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean {\:x 2 \:y 4}))" "(R-generate (R->mean {\:x 2 }))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\n                        (vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean [1 3 4 5]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\n                        (apply vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean [1 3 4 5]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\n                        (apply vector? data) (R->vector (ffirst data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean [1 3 4 5]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\n                        (apply vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean [1 3 4 5]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\n                        (apply vector? data) (R->vector  data)\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean [1 3 4 5]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\n                        (apply vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean [1 3 4 5]))" "(R-generate  (R->vector 3 4 5))" "(R-generate  (R->vector [3 4 5]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\n                        (apply vector? data) (apply R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean [1 3 4 5]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        \:default (throw \\"Mean failed\\"))]))" "(R->mean \\"4f\\")" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        \:default (throw (Exception. \\"Mean failed\\")))]))" "(R->mean \\"4f\\")" "\\r\\n(defn R-generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep))))) \\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (if (map? entry)\\r\\n          (R-generate entry)\\r\\n          entry))))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->def [var-name value]\\r\\n  (internal-R-struct \:R->def [var-name value]))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  (internal-R-struct \:R->vector [(into [] values)]))\\r\\n\\r\\n(defn R->range [low-val high-val]\\r\\n  (internal-R-struct \:R->range  [low-val high-val]))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))\\r\\n\\r\\n(defn R-slurp [path]\\r\\n  (internal-R-struct \:R-slurp \:params [path]))\\r\\n\\r\\n(defn internal-R->def [var-name value]\\r\\n  (str (name var-name) \\"<-\\" value))\\r\\n\\r\\n(defn internal-R->vector [values]\\r\\n  (str (reduce str \\"c[\\"  (interpose \\",\\" values)) \\"]\\"))\\r\\n\\r\\n(defn internal-R->range [low-val high-val]\\r\\n  (str \\"(\\" low-val \\"\:\\" high-val \\")\\"))\\r\\n\\r\\n(defn internal-R-slurp [path]\\r\\n  (str \\"read.table(\\\\\\"\\" path \\"\\\\\\")\\"))\\r\\n\\r\\n(defn internal-R->mean [val]\\r\\n  (str \\"mean(\\" val \\")\\"))" "(R->def \:car 4)" "(R-generate (R->def \:car 4))" "(R-generate (R->def \:car (R->vector 1 2 3 4 5)))" "(R-generate (R->def \:car (R->mean (R->vector 1 2 3 4 5))))" "(defn internal-R->mean [val]\\r\\n  (str \\"mean(\\" (cond                     \\r\\n                 (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                 (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                 (> (count data) 1) (apply R->vector data)\\r\\n                 \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))\\r\\n       \\")\\"))" "(defn internal-R->mean [data]\\r\\n  (str \\"mean(\\" (cond                     \\r\\n                 (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                 (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                 (> (count data) 1) (apply R->vector data)\\r\\n                 \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))\\r\\n       \\")\\"))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                        (> (count data) 1) (apply R->vector data)\\n                        (first data))]))" "(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                        (> (count data) 1) (apply R->vector data)\\n                        (first data))]))" "(defn R->vector [& values]\\r\\n  (internal-R-struct \:R->vector [(into [] values)]))" "(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                        (> (count data) 1) (apply R->vector data)\\n                        (first data))]))" "(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (first data))]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (first data))]))" "(defn internal-R->mean [data]\\r\\n  (str \\"mean(\\" (cond                     \\r\\n    (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n    (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n    \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))\\")\\"))" "(R->mean 1 2 4 )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (first data))]))" "(R->mean 1 2 4 )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                        \:default (first data))]))" "(R->mean 1 2 4 )" "(R->mean [1 2 4] )" "(defn R-generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep))))) \\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (if (map? entry)\\r\\n          (R-generate entry)\\r\\n          entry)))" "(defn R-generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep))))) \\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (if (map? entry)\\r\\n          (R-generate entry)\\r\\n          entry))))" "(R-generate (R->mean [1 2 4] ))" "(defn internal-R->mean [data]\\r\\n  (str \\"mean(\\" (cond                     \\r\\n    (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n    (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n    \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))\\")\\"))" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond  \\n                       (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                       \:default (first data))))" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                        \:default (first data))]))" "(defn internal-R->mean [data]\\r\\n  (str \\"mean(\\" (cond                     \\r\\n    (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n    (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n    \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))\\")\\"))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (vector? data) (apply R->vector  data)\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (vector? data) (R->vector  data)\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector  data)\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector  (first data))\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector  (ffirst data))\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (vector? data) (apply R->vector  data)\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector  (ffirst data))\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (vector? data) (apply R->vector  data)\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector  (first data))\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "(R->mean 1 2 4 )" "(R-generate (R->mean [1 2 4] ))" " (R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (vector? data) (apply R->vector  data)\\n                        \:default (first data))]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" " (R->mean [1 2 4] )" "(defn internal-R->mean [data]\\r\\n  (str \\"mean(\\" (cond \\n                 (string? data) data \\r\\n                 (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                 (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                 \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))\\")\\"))" "(R-generate (R->mean [1 2 4] ))" "\\r\\n(defn R-generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep))))) \\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (if (map? entry)\\r\\n          (R-generate entry)\\r\\n          entry))))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->def [var-name value]\\r\\n  (internal-R-struct \:R->def [var-name value]))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  (internal-R-struct \:R->vector [(into [] values)]))\\r\\n\\r\\n(defn R->range [low-val high-val]\\r\\n  (internal-R-struct \:R->range  [low-val high-val]))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))\\r\\n\\r\\n(defn R-slurp [path]\\r\\n  (internal-R-struct \:R-slurp \:params [path]))\\r\\n\\r\\n(defn internal-R->def [var-name value]\\r\\n  (str (name var-name) \\"<-\\" value))\\r\\n\\r\\n(defn internal-R->vector [values]\\r\\n  (str (reduce str \\"c[\\"  (interpose \\",\\" values)) \\"]\\"))\\r\\n\\r\\n(defn internal-R->range [low-val high-val]\\r\\n  (str \\"(\\" low-val \\"\:\\" high-val \\")\\"))\\r\\n\\r\\n(defn internal-R-slurp [path]\\r\\n  (str \\"read.table(\\\\\\"\\" path \\"\\\\\\")\\"))\\r\\n\\r\\n(defn internal-R->mean [val]\\r\\n  (str \\"mean(\\" val \\")\\"))" "(R-generate (R->mean 1 1 1 ))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R-generate (R->mean 1 1 1 ))" "(R-generate (R->mean [1 2 4]j))" "(R-generate (R->mean [1 2 4]))" "(R-generate (R->mean {\:x (R->vector 1 2 4 )}))" "(R-generate (R->mean {\:x (R->vector [1 2 4] )}))" "(R-generate (R->mean (R->vector [1 2 4] )))" "(R-generate (R->mean (R->vector 1 2 4 )))" "(R-generate (R->mean {\:x 1 \:y 2}))" " (R->mean {\:x 1 \:y 2})" "(defn internal-R-map-destruc [R-rep]" "(partition 2 {\:x 1 \:y 2})" "(map str (partition 2 {\:x 1 \:y 2})" "(map str (partition 2 {\:x 1 \:y 2}))" "(apply map str (partition 2 {\:x 1 \:y 2}))" "(apply map \#(%1 %2) (partition 2 {\:x 1 \:y 2}))" "(apply map (fn [one two] (str one two)) (partition 2 {\:x 1 \:y 2}))" "(partition 2 (flatten {\:x 1 \:y 2}))" "(partition 2  {\:x 1 \:y 2})" "(apply map str (partition 2 {\:x 1 \:y 2}))" "(apply map (fn [val] (str (first val) (second val) )) (partition 2 {\:x 1 \:y 2}))" "(apply map (fn [val] [(first val) (second val)] ) (partition 2 {\:x 1 \:y 2}))" "(into [] (apply map (fn [val] [(first val) (second val)] ) (partition 2 {\:x 1 \:y 2})))" "(apply str (->> [{\:x 1 \:y 3}] (apply into [] (apply partition 2)) (map (fn [val] (str (name (first val)) \\"\=\\" (second val)))) (interpose \\",\\")))" "(apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 [{\:x 1 \:y 3}])))))" "(apply str (->> [{\:x 1 \:y 3}] (apply partition 2) (apply into []) (map (fn [val] (str (name (first val)) \\"\=\\" (second val)))) (interpose \\",\\")))" "(apply str (->> [{\:x 1 \:y 3}] (apply partition 2)))" "(->> [{\:x 1 \:y 3}] (apply partition 2))" "(->> [{\:x 1 \:y 3}] (first) ( partition 2))" "(->> [{\:x 1 \:y 3 \:x 1 \:y 3}] (first) (partition 2))" "(->> [{\:x 1 \:y 3 \:x 1 \:y 3}]  (partition 2))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (partition 2))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 2))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 1))" "(->> {\:x 1 \:y 3 \:xz 1 \:ys 3}  (partition 1))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}] (first) (partition 1))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 1) (apply into []) (map (fn [val] (str (name (first val)) \\"\=\\" (second val)))) (interpose \\",\\"))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 1) (apply into []))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 1) (into []))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 1) (map (fn [val] (str (name (first val)) \\"\=\\" (second val)))) (interpose \\",\\"))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 1) (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" "(str (->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 1) (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\")))" "(apply str (->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 1) (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\")))" "(split-with keyword? {\:x 1 \:t 4 \:6})" "(split-with keyword? {\:x 1 \:t 4 \:h 6})" " (apply str (->> data  (first) seq (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\")))" " (->> data  (first) seq (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> {\:a 1 \:b 3}  (first) seq (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  (first) seq (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  first seq (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  first )" " (->> [{\:a 1 \:b 3}]  first seq )" " (->> [{\:a 1 \:b 3}] seq )" " (->> [{\:a 1 \:b 3}]  first seq )" " (->> [{\:a 1 \:b 3}]  first seq (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  first seq (map (fn [val] (str (name (apply val)) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  first seq (map (fn [val] (str (name (first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  first seq (map (fn [val] (str (name  val) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  (apply seq) (map (fn [val] (str (name  val) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  (apply seq) )" " (->> [{\:a 1 \:b 3}]  (apply seq) (map (fn [val] (str (name  val) \\"\=\\" (second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  (apply seq) (map (fn [val] (str (name (first val)) \\"\=\\" (second val)))) (interpose \\",\\"))" "(str (->> [{\:a 1 \:b 3}]  (apply seq) (map (fn [val] (str (name (first val)) \\"\=\\" (second val)))) (interpose \\",\\")))" "(apply str (->> [{\:a 1 \:b 3}]  (apply seq) (map (fn [val] (str (name (first val)) \\"\=\\" (second val)))) (interpose \\",\\")))" " (defn R->\= [var-name value]\\r\\n  (internal-R-struct \:R->\= [var-name value]))\\n (defn internal-R->\= [var-name value]\\r\\n  (str (name var-name) \\"\=\\" value))\\n (->> [{\:a 1 \:b 3}]  (apply seq)  (interpose \\",\\"))" "\\n (->> [{\:a 1 \:b 3}]  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))" "\\n (->> {\:a 1 \:b 3}  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))" "\\n (->> [{\:a 1 \:b 3}]  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)  (->> [{\:a 1 \:b 3}]  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)  (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)  (first (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\n                        _ (println (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        (apply map? data)   (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)  (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)  (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))))" "(R->mean 1 2 4 45)" "(R->mean [1 3 4])" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1) [(apply R->vector data)]\\r\\n                        (apply vector? data) [(apply R->vector (first data))]\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)   (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean 1 2 4 45)" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) [(apply R->vector (first data))]\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)   (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean 1 2 4 45)" "(R->mean [1 3 4])" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)   (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean [1 3 4])" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(R-generate (R->mean {\:x [1 2 3 4] \:y [3 4 5]}))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1)      (apply R->vector data)\\r\\n                        (apply vector? data)    (apply R->vector (first data))\\r\\n                        (and (apply map? data)  (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)       (first (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn internal-R-assem-parms [R-rep]\\r\\n  \\"takes a clojure R representation and extracts parameters\\"\\r\\n  (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R-generate entry)\\r\\n          (seq? entry) (apply R-generate entry)\\r\\n          \:default entry)))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1)      (apply R->vector data)\\r\\n                        (apply vector? data)    (apply R->vector (first data))\\r\\n                        (and (apply map? data)  (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)       (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))\\r\\n                        \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn internal-R-assem-parms [R-rep]\\r\\n  \\"takes a clojure R representation and extracts parameters\\"\\r\\n  (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (do (println \\"map\\") (R-generate entry))\\r\\n          (seq? entry) (do (println \\"seq\\") (apply R-generate entry))\\r\\n          \:default entry)))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "\\r\\n(defn internal-R-assem-func [R-rep]\\r\\n  \\"takes a clojure R representation and creates associated function\\"\\r\\n  (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep))))))\\r\\n\\r\\n(defn internal-R-assem-parms [R-rep]\\r\\n  \\"takes a clojure R representation and extracts parameters\\"\\r\\n  (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R-generate entry)\\r\\n          (seq? entry) (apply R-generate entry)\\r\\n          \:default entry)))\\r\\n\\r\\n(defn R->generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (internal-R-assem-func R-rep)\\r\\n      (internal-R-assem-parms R-rep)))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn internal-R-assem-parms [R-rep]\\r\\n  \\"takes a clojure R representation and extracts parameters\\"\\r\\n  (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (do (println \\"map\\") (R-generate entry))\\r\\n          (seq? entry) (do (println \\"seq\\") (apply R-generate entry))\\r\\n          \:default entry)))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn internal-R-assem-parms [R-rep]\\r\\n  \\"takes a clojure R representation and extracts parameters\\"\\r\\n  (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (do (println \\"map\\") (R-generate entry))\\r\\n          (seq? entry) (do (println \\"seq\\") (apply R-generate entry))\\r\\n          \:default (do (print \\"nota\\") entry))))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn internal-R-assem-parms [R-rep]\\r\\n  \\"takes a clojure R representation and extracts parameters\\"\\r\\n  (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (do (println \\"map\\") (R-generate entry))\\r\\n          (seq? entry) (do (println \\"seq\\") (apply R-generate entry))\\r\\n          \:default (do (println \\"nota\\") entry))))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(R->mean (defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1)      (apply R->vector data)\\r\\n                        (apply vector? data)    (apply R->vector (first data))\\r\\n                        (and (apply map? data)  (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)       (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))\\r\\n{\:x [1 2 3 4] \:y [3 4 5]})" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1)      (apply R->vector data)\\r\\n                        (apply vector? data)    (apply R->vector (first data))\\r\\n                        (and (apply map? data)  (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)       (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                        (> (count data) 1)      (apply R->vector data)\\r\\n                        (apply vector? data)    (apply R->vector (first data))\\r\\n                        (and (apply map? data)  (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)       (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(R->mean [1 3 4])" "(R->mean 1 3 4)" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1)      [(apply R->vector data)]\\r\\n                        (apply vector? data)    [(apply R->vector (first data))]\\r\\n                        (apply map? data)       (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean 1 3 4)" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1)      (apply R->vector data)\\r\\n                        (apply vector? data)    [(apply R->vector (first data))]\\r\\n                        (apply map? data)       (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                        (> (count data) 1)      [(apply R->vector data)]\\r\\n                        (apply vector? data)    [(apply R->vector (first data))]\\r\\n                        (apply map? data)       (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))))" "(R->mean 1 3 4)" "(R->mean [1 3 4])" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(R-generate (R->mean {\:x [1 2 3 4] \:y [3 4 5]}))" "(defn internal-R->mean [& val]\\r\\n  (str \\"mean(\\" (apply str val) \\")\\"))" "(R-generate (R->mean {\:x [1 2 3 4] \:y [3 4 5]}))" "(defn internal-R->mean [& val]\\r\\n  (str \\"mean(\\" (interpose \\",\\" (apply str val)) \\")\\"))" "(R-generate (R->mean {\:x [1 2 3 4] \:y [3 4 5]}))" "(defn internal-R->mean [& data]\\n  (do (println (interpose \\",\\" data))\\r\\n  (str \\"mean(\\" data \\")\\")))" "(R-generate (R->mean {\:x [1 2 3 4] \:y [3 4 5]}))" "(defn internal-R->mean [& data]\\r\\n  (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))" "(R-generate (R->mean {\:x [1 2 3 4] \:y [3 4 5]}))" "(R-generate (R->mean 1 2 4 5 6))" "(R-generate (R->mean [1 2 4 5 6]))" "(R->def \:car 5)" "(ns RC.core)" "(R->def \:car 5)" "(R->generate (R->def \:car 5))" "(R->generate (R->def \:car (R->vector 1 2 3)))" "(R->generate (R->def \:car (R->mean (R->vector 1 2 3))))" "(R->generate (R->def \:car (R->mean 1 2 3)))" "(R->generate (R->def \:car (R->mean {\:x 1 \:y 4})))" "(R->generate (R->def \:car (R->mean {\:x (R->vector 1 2 3) \:y 4})))" "(R->generate (R->def \:car (R->mean 1 2 3)))" "(R->generate (R->def \:car (R->mean (R->vector 1 2 3))))" "(R->mean (R->vector 1 2 3))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                       (> (count data) 1)      [(apply R->vector data)]\\r\\n                       (apply vector? data)    [(apply R->vector (first data))]\\r\\n                       (and (apply map? data)  (apply \:R-struct data)) (first data)\\r\\n                       (apply map? data)       (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                       \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))))" "(R->mean (R->vector 1 2 3))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                       (> (count data) 1)            [(apply R->vector data)]\\r\\n                       (apply vector? data)          [(apply R->vector (first data))]\\r\\n                       (and (apply map? data)\\r\\n                            (apply \:R-struct data))  [(first data)]\\r\\n                       (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                       \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))" "(R->mean (R->vector 1 2 3))" "(R->generate (R->def \:car (R->mean (R->vector 1 2 3))))" "(R-slurp \\"c/stuf\\")" "(R->range 4 354)" "(R->generate (R->range 4 354))" "(R->generate (R->def \:result (R->mean (R->vector (R->range 1 50)))))" " (R->def \:result (R->mean (R->vector (R->range 1 50))))" "(defn R->vector [& data]\\r\\n  (if (and (apply map? data)\\r\\n           (apply \:R-struct data))\\n    (first data)\\r\\n  (internal-R-struct \:R->vector [(into [] data)]))" "(defn R->vector [& data]\\r\\n  (if (and (apply map? data)\\r\\n           (apply \:R-struct data))\\n    (first data)\\r\\n  (internal-R-struct \:R->vector [(into [] data)])))" " (R->def \:result (R->mean (R->vector (R->range 1 50))))" "(R->generate (R->def \:result (R->mean (R->vector (R->range 1 50)))))" "(defn R->vector [& data]\\r\\n  (if (and (apply map? data)\\r\\n           (apply \:R-struct data))\\n    (internal-R-struct \:R->vector (first data))\\r\\n    (internal-R-struct \:R->vector [(into [] data)])))" "(R->generate (R->def \:result (R->mean (R->vector (R->range 1 50)))))" "(defn R->vector [& data]\\r\\n  (if (and (apply map? data)\\r\\n           (apply \:R-struct data))\\n    (internal-R-struct \:R->vector [(first data)])\\r\\n    (internal-R-struct \:R->vector [(into [] data)])))" "(R->generate (R->def \:result (R->mean (R->vector (R->range 1 50)))))" "(defn R->vector [& data]\\r\\n  (if (and (apply map? data)\\r\\n           (apply \:R-struct data))\\n    (internal-R-struct \:R->vector [(first data)])\\r\\n    (internal-R-struct \:R->vector [(into [] data)])))" "(ns RC.core)" "(R->def (R->range 12 1000))" "(R->def \:somenumbers (R->range 12 1000))" "(R->generate (R->def \:somenumbers (R->range 12 1000)))" "(R->generate (R->mean (R->vector 1 2 3)))" "(R->generate (R->mean ({\:x R->vector 1 2 3})))" "(R->generate (R->mean ({\:x (R->vector 1 2 3)})))" "(R->generate (R->mean {\:x (R->vector 1 2 3)}))" "(R->generate (R->mean {\:x (R->range 10 20)}))" "(R->generate (R->range 1 4))" "(R->generate (R->mean {\:x (R->range 10 20)}))" "(R->generate  \\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)}))" "(R->generate  \\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(R->generate  \\n  (do (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)}))))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (map (apply \\r\\n         (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n         (for [entry (\:parms R-rep)]\\r\\n           (cond \\r\\n             (map? entry) (R->generate entry)\\r\\n             (seq? entry) (apply R->generate entry) \\r\\n             \:default  entry))) R-rep ))" "(R->generate  \\n  (do (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)}))))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (map str\\n       R-rep ))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply map (apply \\r\\n         (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n         (for [entry (\:parms R-rep)]\\r\\n           (cond \\r\\n             (map? entry) (R->generate entry)\\r\\n             (seq? entry) (apply R->generate entry) \\r\\n             \:default  entry))) R-rep ))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n (map\\n   \#(do (resolve (symbol (str \\"internal-\\" (name (\:oper %)))))\\r\\n         (for [entry (\:parms %)]\\r\\n           (cond \\r\\n             (map? entry) (R->generate entry)\\r\\n             (seq? entry) (apply R->generate entry) \\r\\n             \:default  entry))) R-rep )" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n (map\\n   \#(do (resolve (symbol (str \\"internal-\\" (name (\:oper %)))))\\r\\n         (for [entry (\:parms %)]\\r\\n           (cond \\r\\n             (map? entry) (R->generate entry)\\r\\n             (seq? entry) (apply R->generate entry) \\r\\n             \:default  entry))) R-rep ))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n (map\\n   \#(apply (resolve (symbol (str \\"internal-\\" (name (\:oper %)))))\\r\\n         (for [entry (\:parms %)]\\r\\n           (cond \\r\\n             (map? entry) (R->generate entry)\\r\\n             (seq? entry) (apply R->generate entry) \\r\\n             \:default  entry))) R-rep ))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(seq\\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)}))" "(seq\\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "\\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)}))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(R->generate  \\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(R->generate  \\n  (R->def \:mymean (R->mean {\:x 1})))" " \\n  (R->def \:mymean (R->mean {\:x 1}))" "(R->generate  \\n  (R->def \:mymean (R->mean 1 2 3)))" "  \\n  (R->def \:mymean (R->mean 1 2 3))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "\\n  (R->def \:one (R->vector 1 2 3))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n (map\\n   \#(apply (resolve (symbol (str \\"internal-\\" (name (\:oper %)))))\\r\\n         (for [entry (\:parms %)]\\r\\n           (do (println entry)\\n             (cond \\r\\n             (map? entry) (R->generate entry)\\r\\n             (seq? entry) (apply R->generate entry) \\r\\n             \:default  entry))) R-rep )))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n (map\\n   \#(apply (resolve (symbol (str \\"internal-\\" (name (\:oper %)))))\\r\\n         (for [entry (\:parms %)]\\r\\n           (do (println entry)\\n             (cond \\r\\n             (map? entry) (R->generate entry)\\r\\n             (seq? entry) (apply R->generate entry) \\r\\n             \:default  entry)))) R-rep ))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate entry)\\r\\n          (seq? entry) (apply R->generate entry) \\r\\n          \:default  entry))))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate entry)\\r\\n          (seq? entry) (apply R->generate entry) \\r\\n          \:default  entry))))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n   (map \#(apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper %)))))\\r\\n      (for [entry (\:parms %)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate entry)\\r\\n          (seq? entry) (apply R->generate entry) \\r\\n          \:default  entry))) R-rep))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate entry)\\r\\n          (seq? entry) (apply R->generate entry) \\r\\n          \:default  entry))))" "(defn R->generate [& R-rep]\\n  (map R->generate-command R-rep))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(interpose \\"\\\\n\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])" "(str (interpose \\"\\\\n\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"]))" "(apply str (interpose \\"\\\\n\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"]))" "(defn R->generate [& R-rep]\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))" "(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\"\\\\n\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])))" "(defn R->generate [& R-rep]\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "\\r\\n;generations functions\\r\\n(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))\\r\\n\\r\\n(defn R->generate [& R-rep]\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))\\r\\n\\r\\n\\r\\n; R DSL\\r\\n(defn R->def [var-name value]\\r\\n  (internal-R-struct \:R->def [var-name value]))\\r\\n\\r\\n(defn R->\= [var-name value]\\r\\n  (internal-R-struct \:R->\= [var-name value]))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  \\r\\n  (internal-R-struct \:R->vector [(into [] values)]))\\r\\n\\r\\n(defn R->range [low-val high-val]\\r\\n  (internal-R-struct \:R->range  [low-val high-val]))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                       (> (count data) 1)            [(apply R->vector data)]\\r\\n                       (apply vector? data)          [(apply R->vector (first data))]\\r\\n                       (and (apply map? data)\\r\\n                            (apply \:R-struct data))  [(first data)]\\r\\n                       (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                       \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))\\r\\n\\r\\n(defn R->slurp [path]\\r\\n  (internal-R-struct \:R->slurp \:params [path]))\\r\\n\\r\\n(defn internal-R->def [var-name value]\\r\\n  (str (name var-name) \\"<-\\" value))\\r\\n\\r\\n(defn internal-R->\= [var-name value]\\r\\n  (str (name var-name) \\"\=\\" value))\\r\\n\\r\\n(defn internal-R->vector [values]\\r\\n  (str (reduce str \\"c[\\"  (interpose \\",\\" values)) \\"]\\"))\\r\\n\\r\\n(defn internal-R->range [low-val high-val]\\r\\n  (str \\"(\\" low-val \\"\:\\" high-val \\")\\"))\\r\\n\\r\\n(defn internal-R->slurp [path]\\r\\n  (str \\"read.table(\\\\\\"\\" path \\"\\\\\\")\\"))\\r\\n\\r\\n(defn internal-R->mean [& data]\\r\\n     (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))\\r\\n\\r\\n(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->mean {\:x (R->range 10 20)}))" "(R->generate  \\r\\n  (R->def \:stuff 1)\\r\\n  (R->mean {\:x (R->range 10 20)}))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 2(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])))0)}))" "(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [& data]\\r\\n  (println (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [data]\\r\\n  (println (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(interpose \\"\:\\" [1 2 4])" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data) \\";\\"))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "\\r\\n;generations functions\\r\\n(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))" "(R->generate (R->def \:car 3) (R->mean (R->vector 12 4334 43)))" "(defn internal-R->vector [values]\\r\\n  (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))" "(R->generate (R->def \:car 3) (R->mean (R->vector 12 4334 43)))" "(R->generate (R->def \:car 3) (R->mean {\:x (R->vector 12 4334 43)}))" "(defprotocol prot-R-command\\n  (create-data-struct [_ & data])\\n  (emit-exicute-code [_ & data]))" "(defprotocol prot-R-command\\n  (create-data-struct [_ & data])\\n  (emit-exicute-code [_ & data])\\n  (get-information [_]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_ & data]" "(defprotocol prot-R-command\\n  (create-data-struct [_ & data]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command))\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var-name value]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command)\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var-name value])))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var-name value]))))" "(defprotocol prot-R-command\\n  (create-data-struct [_]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var-name value]))))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))))" "(R->def \:one 1)" "(create-data-struct (R->def \:one 1))" "(defprotocol prot-R-command\\n  (create-data-struct [_])\\n  (emit-exicute-code [_]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_]\\n      (str (name var-name) \\"<-\\" value))))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_ var-nam value]\\n      (str (name var-name) \\"<-\\" value))))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_ & data]\\n      (str (name var-name) \\"<-\\" value))))" "(defprotocol prot-R-command\\n  (create-data-struct [_])\\n  (emit-exicute-code [_ & data]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_ & data]\\n      (str (name var-name) \\"<-\\" value))))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_]\\n      (str (name var) \\"<-\\" value))))" "(defprotocol prot-R-command\\n  (create-data-struct [_])\\n  (emit-exicute-code [_]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_]\\n      (str (name var) \\"<-\\" value))))" "(create-data-struct (R->def \:one 4))" "(emit-exicute-code (create-data-struct (R->def \:one 4)))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [operation (resolve(symbol (name (\:oper R-rep))))]\\r\\n    (apply \\r\\n\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry)))))" "(R->def \:one 4)" "(def rt (R->def \:one 4))" "(create-data-struct rt)" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n      r-struct (create-data-struct R-rep)\\n   \\r\\n    (apply \\n      (emit-exicute-code oper \\r\\n                         (for [entry (\:parms R-rep)]\\r\\n                           (cond \\r\\n                             (map? entry) (R->generate-command entry)\\r\\n                             (seq? entry) (apply R->generate-command entry) \\r\\n                             \:default  entry))))))" "(def rt (R->def \:one (R->def \:two 2)))" "rt" "(class rt)" "(class 1)" "(split (class rt))" "(split \\".\\" (class rt))" "(split  (class rt) \\".\\")" "(class rt)" "(with-in-str \\"RC\\" (class rt))" "(ns-name rt)" "(ns-map RT)" "(ns-map RC.core)" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply emit-exicute-code R-rep)\\r\\n      (for [entry (\:parms (create-data-struct  R-rep))]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry)))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms (create-data-struct  struct))]\\r\\n               (cond \\r\\n                 (map? entry) (R->generate-command entry)\\r\\n                 (seq? entry) (apply R->generate-command entry) \\r\\n                 \:default  entry))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms (create-data-struct  struct))]\\r\\n               (cond \\r\\n                 (map? entry) (R->generate-command entry)\\r\\n                 (seq? entry) (apply R->generate-command entry) \\r\\n                 \:default  entry))))))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_]\\n      (str (name var) \\"<-\\" value))))" "(R->generate-command (R->def \:one 4))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 (map? entry) (R->generate-command entry)\\r\\n                 (seq? entry) (apply R->generate-command entry) \\r\\n                 \:default  entry))))))" "(R->generate-command (R->def \:one 4))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\n  (reify \\n    prot-R-command\\r\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->mean\\r\\n                         (cond          \\r\\n                           (> (count data) 1)            [(apply R->vector data)]\\r\\n                           (apply vector? data)          [(apply R->vector (first data))]\\r\\n                           (and (apply map? data)\\r\\n                                (apply \:R-struct data))  [(first data)]\\r\\n                           (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                           \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))\\n    (emit-exicute-code [_]\\n      (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 (map? entry) (R->generate-command entry)\\r\\n                 (seq? entry) (apply R->generate-command entry) \\r\\n                 \:default  entry))))))" "(R->generate (R->mean 1 2 3))" "(defn R->vector [& values]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\n  (reify \\n    prot-R-command\\r\\n    (create-data-struct [_]\\n     (internal-R-struct \:R->vector [(into [] values)]))\\n    (emit-exicute-code [_]\\n      (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "(create-data-struct (R->mean 1 2 3))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 ;(map? entry) (R->generate-command entry)\\n                 \\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry))))))" "(class (R->mean 1 2 3))" " (R->mean 1 2 3))" " (R->mean 1 2 3)" "(fn? (R->mean 1 2 3))" "(fn (R->mean 1 2 3))" "(fn? (R->mean 1 2 3))" "(ifn? (R->mean 1 2 3))" "(apply ifn? (R->mean 1 2 3))" "(instance? reify (R->mean 1 2 3))" "(instance? (class reify) (R->mean 1 2 3))" "(class reify)" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 (apply map? entry) (R->generate-command entry)\\n                 \\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry))))))" "(create-data-struct (R->mean 1 2 3))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                (R->generate-command entry)\\n                 \\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry))))))" "(instance? RC (R->mean 1 2 3))" "(parents R->mean)" "(find-ns R->mean)" "(find-ns (R->mean 1 2))" "(R->mean 1 2)" "(apply print (R->mean 1 2))" "(print (R->mean 1 2))" "(apply map? (R->mean 1 2))" "(parents (R->mean 1 2))" "(class? (R->mean 1 2))" "(class? 1)" "(appy class (R->mean 1 2))" "(class (R->mean 1 2))" "(.contains (str (class (R->mean 1 2) \\"reify\\")" "(.contains (str (class (R->mean 1 2) \\"reify\\")))" "(.contains (str (class (R->mean 1 2))) \\"reify\\")" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 (.contains (str (class (R->mean 1 2))) \\"reify\\") (R->generate-command entry) ; bad way to check condition\\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry))))))" "(R->generate (R->mean 1 2 3))" "(defn R->vector [& values]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\n  (reify \\n    prot-R-command\\r\\n    (create-data-struct [_]\\n     (internal-R-struct \:R->vector [(into [] values)]))\\n    (emit-exicute-code [_]\\n      (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\n  (reify \\n    prot-R-command\\r\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->mean\\r\\n                         (cond          \\r\\n                           (> (count data) 1)            [(apply R->vector data)]\\r\\n                           (apply vector? data)          [(apply R->vector (first data))]\\r\\n                           (and (apply map? data)\\r\\n                                (apply \:R-struct data))  [(first data)]\\r\\n                           (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                           \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))\\n    (emit-exicute-code [_]\\n      (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\n               (do (println entry)\\r\\n               (cond \\r\\n                 (.contains (str (class (R->mean 1 2))) \\"reify\\") (R->generate-command entry) ; bad way to check condition\\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry)))))))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\n               (do (println entry)\\r\\n               (cond \\r\\n                 (.contains (str (class entry)) \\"reify\\") (R->generate-command entry) ; bad way to check condition\\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry)))))))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defprotocol prot-R-command\\r\\n     (create-data-struct [_])\\r\\n     (emit-exicute-code [_]))\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\r\\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (do (println entry)\\r\\n               (cond \\r\\n                 (.contains (str (class entry)) \\"reify\\") (R->generate-command entry) ; bad way to check condition\\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry)))))))\\r\\n\\r\\n(defn R->def [var value]\\r\\n     (reify\\r\\n       prot-R-command\\r\\n       (create-data-struct [_]\\r\\n         (internal-R-struct \:R->def [var value]))\\r\\n       (emit-exicute-code [_]\\r\\n         (str (name var) \\"<-\\" value))))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (reify \\r\\n    prot-R-command\\r\\n    (create-data-struct [_]\\r\\n     (internal-R-struct \:R->vector [(into [] values)]))\\r\\n    (emit-exicute-code [_]\\r\\n      (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (reify \\r\\n    prot-R-command\\r\\n    (create-data-struct [_]\\r\\n      (internal-R-struct \:R->mean\\r\\n                         (cond          \\r\\n                           (> (count data) 1)            [(apply R->vector data)]\\r\\n                           (apply vector? data)          [(apply R->vector (first data))]\\r\\n                           (and (apply map? data)\\r\\n                                (apply \:R-struct data))  [(first data)]\\r\\n                           (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                           \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))\\r\\n    (emit-exicute-code [_]\\r\\n      (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defprotocol prot-R-command\\r\\n     (create-data-struct [_])\\r\\n     (emit-exicute-code [_]))\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\r\\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 (.contains (str (class entry)) \\"reify\\") (R->generate-command entry) ; bad way to check condition\\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry))))))\\r\\n\\r\\n(defn R->def [var value]\\r\\n     (reify\\r\\n       prot-R-command\\r\\n       (create-data-struct [_]\\r\\n         (internal-R-struct \:R->def [var value]))\\r\\n       (emit-exicute-code [_]\\r\\n         (str (name var) \\"<-\\" value))))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (reify \\r\\n    prot-R-command\\r\\n    (create-data-struct [_]\\r\\n     (internal-R-struct \:R->vector [(into [] values)]))\\r\\n    (emit-exicute-code [_]\\r\\n      (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (reify \\r\\n    prot-R-command\\r\\n    (create-data-struct [_]\\r\\n      (internal-R-struct \:R->mean\\r\\n                         (cond          \\r\\n                           (> (count data) 1)            [(apply R->vector data)]\\r\\n                           (apply vector? data)          [(apply R->vector (first data))]\\r\\n                           (and (apply map? data)\\r\\n                                (apply \:R-struct data))  [(first data)]\\r\\n                           (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                           \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))\\r\\n    (emit-exicute-code [_]\\r\\n      (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "(defn R->summary [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                       (> (count data) 1)            [(apply R->vector data)]\\r\\n                       (apply vector? data)          [(apply R->vector (first data))]\\r\\n                       (and (apply map? data)\\r\\n                            (apply \:R-struct data))  [(first data)]\\r\\n                       (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                       \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))" "(defn internal-R->summary [& data]\\r\\n     (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))" "(R->generate (R->summary 1 2 3))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))\\r\\n\\r\\n(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))" "(R->generate (R->summary 1 2 3))" "(R->generate (R->mean 1 2 3))" "(ns RC.core)" "(R->generate (R->mean 1 2 3))" "(R->generate-command (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply str (internal-R-post-proc (map R->generate-command R-rep))))" "(R->generate-command (R->mean 1 2 3))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply str (internal-R-post-proc (map R->generate-command R-rep))))" "(R->generate (R->mean 1 2 3))" "(R->generate-command (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (println (internal-R-post-proc (map R->generate-command R-rep))))" "(R->generate-command (R->mean 1 2 3))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply println (internal-R-post-proc (map R->generate-command R-rep))))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (println (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (str (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply str (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (println (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (str (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply str (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply str (interpose \\";\\" (map R->generate-command R-rep))))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))\\r\\n\\r\\n(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "(defn R->summary [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->summary\\r\\n                     (cond          \\r\\n                       (> (count data) 1)            [(apply R->vector data)]\\r\\n                       (apply vector? data)          [(apply R->vector (first data))]\\r\\n                       (and (apply map? data)\\r\\n                            (apply \:R-struct data))  [(first data)]\\r\\n                       (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                       \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(defn internal-R->summary [& data]\\r\\n     (str \\"summary(\\" (apply str (interpose \\",\\" data)) \\")\\"))" "(R->generate (R->summary 1 2 3 4 ))" "(defn internal-R->summary [& data]\\r\\n     (str \\"summary(\\" (apply str (interpose \\",\\" data)) \\")\\"))" "(defn R->summary [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->summary\\r\\n                     (stnd-input-support data )))" "(defn stnd-input-support [data]\\r\\n  (cond          \\r\\n    (> (count data) 1)            [(apply R->vector data)]\\r\\n    (apply vector? data)          [(apply R->vector (first data))]\\r\\n    (and (apply map? data)\\r\\n         (apply \:R-struct data))  [(first data)]\\r\\n    (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n    \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\"))))" "(defn R->summary [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->summary\\r\\n                     (stnd-input-support data )))" "(R->generate (R->summary 1 2 3 4 ))" "\\r\\n;generations functions\\r\\n(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))\\r\\n\\r\\n(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))\\r\\n\\r\\n; R DSL\\r\\n(defn R->def [var-name value]\\r\\n  (internal-R-struct \:R->def [var-name value]))\\r\\n\\r\\n(defn R->\= [var-name value]\\r\\n  (internal-R-struct \:R->\= [var-name value]))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  (internal-R-struct \:R->vector [(into [] values)]))\\r\\n\\r\\n(defn R->range [low-val high-val]\\r\\n  (internal-R-struct \:R->range  [low-val high-val]))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean (stnd-input-support data )))\\r\\n\\r\\n(defn R->summary [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->summary (stnd-input-support data )))\\r\\n\\r\\n(defn R->slurp [path]\\r\\n  (internal-R-struct \:R->slurp \:params [path]))\\r\\n\\r\\n(defn internal-R->def [var-name value]\\r\\n  (str (name var-name) \\"<-\\" value))\\r\\n\\r\\n(defn internal-R->\= [var-name value]\\r\\n  (str (name var-name) \\"\=\\" value))\\r\\n\\r\\n(defn internal-R->vector [values]\\r\\n  (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))\\r\\n\\r\\n(defn internal-R->range [low-val high-val]\\r\\n  (str \\"(\\" low-val \\"\:\\" high-val \\")\\"))\\r\\n\\r\\n(defn internal-R->slurp [path]\\r\\n  (str \\"read.table(\\\\\\"\\" path \\"\\\\\\")\\"))\\r\\n\\r\\n(defn internal-R->mean [& data]\\r\\n     (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))\\r\\n\\r\\n(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn internal-R->summary [& data]\\r\\n     (str \\"summary(\\" (apply str (interpose \\",\\" data)) \\")\\"))\\r\\n\\r\\n(defn stnd-input-support [data]\\r\\n  (cond          \\r\\n    (> (count data) 1)            [(apply R->vector data)]\\r\\n    (apply vector? data)          [(apply R->vector (first data))]\\r\\n    (and (apply map? data)\\r\\n         (apply \:R-struct data))  [(first data)]\\r\\n    (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n    \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\"))))" "(R->generate (R->summary 1 2 3 4 5 56))" "(R->generate-command (R->summary 1 2 3 4 5 56))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (-> R-rep (map R->generate-command) internal-R-post-proc ))" "(R->generate-command (R->summary 1 2 3 4 5 56))" "(R->generate (R->summary 1 2 3 4 5 56))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (->> R-rep (map R->generate-command) internal-R-post-proc ))" "(R->generate (R->summary 1 2 3 4 5 56))" "(defn internal-R-post-proc [data]\\r\\n  (println (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3 4 5 56))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3 4 5 56))" "(R->generate (R->summary 1 2 3))" "(R->generate-command (R->summary 1 2 3))" "(R->generate-command (R->summary 1 2 3) (R->def \:car 23))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (print (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (apply print (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  [(interpose \\";\\" data)])" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (first (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (second (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (concat (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (apply concat (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  ( concat (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (str (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3 4))" "(R->generate (R->def \:stuf (R->summary 1 2 3 4))" "(R->generate (R->def \:stuf (R->summary 1 2 3 4)))" "(R->generate (R->def \:stuf (R->summary {\:x (R->vector 1 3 3 4 5)})))" "(macroexpand '(ns RC.RC-DSL\\r\\n  (\:require [[RC.RC-code-generation \:as gen]\\r\\n             [RC.RC-support \:as sup]])))" "(macroexpand '(ns RC.RC-code-generation))" "(macroexpand '(ns RC.core\\r\\n  (\:require [[DSL.primary-operations]\\r\\n             [DSL.composit-operations]])))" "(do (clojure.core/in-ns (quote RC.core)) (clojure.core/with-loading-context (clojure.core/refer (quote clojure.core)) (clojure.core/require (quote [[DSL.primary-operations] [DSL.composit-operations]]))) (if (.equals (quote RC.core) (quote clojure.core)) nil (do (clojure.core/dosync (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote RC.core))) nil)))" "(ns RC.core\\r\\n  (\:require [DSL.primary-operations composit-operations]))" "(ns RC.core\\r\\n  (\:require [DSL.primary-operations]))" "(ns RC.core\\r\\n  (\:require [DSL.composit-operations]))" "(ns RC.core\\r\\n  (\:require [DSL [primary-operations composit-operations]]))" "(macroexpand '(ns RC.core\\r\\n  (\:require 'DSL.primary-operations\\r\\n             'DSL.composit-operations)))" "(ns RC.core\\r\\n  (\:require 'DSL.primary-operations\\r\\n             'DSL.composit-operations))" "(ns RC.core\\r\\n  (\:require ['DSL.primary-operations\\r\\n             'DSL.composit-operations]\\n            ))" "(ns RC.core\\r\\n  (\:require [DSL.primary-operations\\r\\n             DSL.composit-operations]\\n            ))" "(ns RC.core\\r\\n  (\:require [[DSL.primary-operations \:as one]\\r\\n             [DSL.composit-operations \:as two]]))" "(ns primary)" "(ns RC.core)" "(ns-name)" "(ns DSL.composit-operations)" "(gen/R->generate(R->def \:cor 4))" "(R->def \:cor 4)" "(gen/R->generate-command\\n  (R->def \:cor 4))" "(defn gen-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn gen-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"gen-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))" "(R->generate-command\\n  (R->def \:cor 4))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"codeGeneration.gen-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))" "(R->generate-command\\n  (R->def \:cor 4))" "(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve 'codeGeneration (symbol (str \\"gen-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))" "(R->generate-command\\n  (R->def \:cor 4))" "(ns-rs codeGeneration (symbol (str \\"gen-\\" (name (\:oper R-rep)))))" "(ns-resolve codeGeneration (symbol (str \\"gen-\\" (name (\:oper R-rep)))))" "(ns-resolve 'codeGeneration (symbol (str \\"gen-\\" (name (\:oper R-rep)))))" "(gen/R->generate-command (R->def \:oen 3))" " (R->def \:oen 3)" "(gen/R->generate-command primary_operations.clj)" "(gen/R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(ns user)" "ns" "*ns*" "(R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(codeGeneration/R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(codeGeneration.R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(codeGeneration.RC-code-generation/R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(ns DSL.primary-operations)" "(R->def \:one 3)" "(gen/R->generate-command (R->def \:one 3))" "(resolve (symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" )))" "(resolve (symbol (str \\"codeGeneration.RC-code-generationdsdfs/R->generate-command/gen-R->summary \\" )))" "((resolve (symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" ))) [1 2 3])" "((symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" ))[1 2 3])" "((symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" )) 55 5 [1 2 3])" "((symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" ))[1 2 3])" "(symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" ))" "(codeGeneration.RC-code-generation/R->generate-command/gen-R->summary [1 2 3])" "(codeGeneration.RC-code-generation/gen-R->summary [1 2 3])" "((resolve (symbol (str \\"codeGeneration.RC-code-generation/gen-R->summary \\" ))) [1 2 3])" "((resolve (symbol (str \\"codeGeneration.RC-code-generation/gen-R->summary\\" ))) [1 2 3])" "(R->def \:one 2)" "(gen/R->generate-command (R->def \:one 2))" "(ns DSL.primary-operations\\r\\n  (\:require [codeGeneration.RC-code-generation \:as gen]))" "(R-def \:one 21)" "(R->def \:one 21)" "(R->def \:one 1)" "(gen/R->generate-command (R->def \:one 1))" "(seq 1 1)" "(defn tests [& data]\\n  (class data))" "(tests 1 2 3)" "(seq? (tests 1 2 3))" "(seq? (tests {\:q 1}))" "(tests {\:q 1})" "(defmacro stnd-input-support [^clojure.lang.ArraySeq data]\\r\\n  (cond          \\r\\n    (> (count data) 1)            [(apply dsl/R->vector data)]\\r\\n    (apply vector? data)          [(apply dsl/R->vector (first data))]\\r\\n    (and (apply map? data)\\r\\n         (apply \:R-struct data))  [(first data)]\\r\\n    (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n    \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\"))))" "(R->mean 1 1 1)" "(gen/R->generate-command (R->mean 1 1 1))" "(R->generate-command (R->def \:one 1))" "(R->generate-command (R->def \:themean(R->mean {\:x (R->vector 1 2 43 45) \:y (R->vector 543 65 87)})))" "(R->\= \\"one\\" \\"tw\\")" "(R->generate-command (R->def \:themean(R->mean {\:x (R->vector 1 2 43 45) \:y (R->vector 543 65 87)})))" "  (require '[codeGeneration.RC-code-generation \:refer [R->generate R->generate-command]]\\r\\n            '[dsl.primary-operations \:refer \:all]\\r\\n            '[dsl.composit-operations \:refer \:all]\\r\\n            )" "(R->generate-command (R->mean {\:x (R->vector 1 2 3 4 5)}))" "(require '[clojure.test \:refer \:all]\\r\\n            [rc.core \:refer \:all])" "(R->generate-command (R->vector 1 2 3))" "(R->mean 1 2 3)" "(R->generate-command (R->mean 1 1 3 3))" "(R->generate (R->mean 1 1 3 3))" "(R->generate (R->mean 1 1 3 3) (R->def \:one 1))" "(R->generate (R->mean 1 1 3 3) )" "(R->mean 1 1 3 3)" "(deftest mean-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->mean 1 1 3 3) \\r\\n            {\:R-struct true, \:oper \:R->mean, \:parms [{\:R-struct true, \:oper \:R->vector, \:parms [[1 1 3 3]]}]}))))" "mean-basic-test" "(mean-basic-test)" "(deftest mean-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->mean 1 1 3 3) \\r\\n            {\:R-struct true, \:one 1 \:oper \:R->mean, \:parms [{\:R-struct true, \:oper \:R->vector, \:parms [[1 1 3 3]]}]}))))" "(mean-basic-test)" "(R->mean 1 1 3 3)" "(R->generate (R->mean 1 1 3 3) )" "(deftest mean-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->mean 1 1 3 3) \\r\\n            {\:R-struct true, \:oper \:R->mean, \:parms [{\:R-struct true, \:oper \:R->vector, \:parms [[1 1 3 3]]}]})))\\r\\n    (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->mean 1 1 3 3) \\"mean(c(1,1,3,3))\\"))))" "(mean-basic-test)" "(deftest mean-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->mean 1 1 3 3) \\r\\n            {\:R-struct true, \:oper \:R->mean, \:parms [{\:R-struct true, \:oper \:R->vector, \:parms [[1 1 3 3]]}]})))\\r\\n    (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->generate (R->mean 1 1 3 3)) \\"mean(c(1,1,3,3))\\"))))" "(mean-basic-test)" "(R->vector 1 2 3 4 5)" "(R->generate (R->vector 1 2 3 4 5))" "(deftest vector-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->vector 1 2 3 4 5) \\r\\n            {\:R-struct true, \:oper \:R->vector, \:parms [[1 2 3 4 5]]})))\\r\\n    (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->generate (R->vector 1 2 3 4 5)) \\"c(1,2,3,4,5)\\"))))" "(vector-basic-test)" "(R->generate (R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)})))" "(R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)}))" "(deftest mean-complex-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)})) \\r\\n            {\:R-struct true, \:oper \:R->def, \:parms [\:mymean {\:R-struct true, \:oper \:R->mean, \:parms [{\:R-struct true, \:oper \:R->\=, \:parms [\:x {\:R-struct true, \:oper \:R->vector, \:parms [[1 2 3 4 5]]}]}]}]})))\\r\\n    (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is\\r\\n      (\=  \\r\\n        (R->generate (R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)})))\\r\\n        \\"mymean<-mean(x\=c(1,2,3,4,5))\\"))))" "(mean-complex-test)" "(R->generate (R->summary 1 2 3 4))" "(R->summary 1 2 3 4)" "(deftest summary-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\= (R->summary 1 2 3 4) \\r\\n           {\:R-struct true, \:oper \:R->summary, \:parms [{\:R-struct true, \:oper \:R->vector, \:parms [[1 2 3 4]]}]})))\\r\\n    (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\= (R->generate (R->summary 1 2 3 4)) \\"summary(c(1,2,3,4))\\"))))" "(summary-basic-test)" "(deftest summary-complex-test\\r\\n  (testing \\"mean structure taking map and vector failed\\"\\r\\n    (is (\=  (R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)})) \\r\\n            {\:R-struct true, \:oper \:R->def, \:parms [\:mymean {\:R-struct true, \:oper \:R->summary, \:parms [{\:R-struct true, \:oper \:R->\=, \:parms [\:x {\:R-struct true, \:oper \:R->vector, \:parms [[1 2 3 4 5]]}]}]}]})))\\r\\n    (testing \\"Mean output taking map and vector numbers failed\\"\\r\\n    (is\\r\\n      (\=  \\r\\n        (R->generate (R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)})))\\r\\n        \\"mymean<-summary(x\=c(1,2,3,4,5))\\"))))" "(summary-complex-test)" "(R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)}))" "(R->def \:mymean (R->summary {\:x (R->vector 1 2 3 4 5)}))" "(R->generate (R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)})))" " (R->generate (R->def \:mymean (R->summaryean {\:x (R->vector 1 2 3 4 5)})))" "(R->generate (R->def \:mymean (R->summaryean {\:x (R->vector 1 2 3 4 5)})))" " (R->generate (R->def \:mymean (R->summaryean {\:x (R->vector 1 2 3 4 5)})))" " (R->generate\\n   (R->def \:mymean\\n           (R->summary {\:x (R->vector 1 2 3 4 5)})))" "(deftest summary-complex-test\\r\\n  (testing \\"mean structure taking map and vector failed\\"\\r\\n    (is (\=  (R->def \:mymean (R->summary {\:x (R->vector 1 2 3 4 5)})) \\r\\n            {\:R-struct true, \:oper \:R->def, \:parms [\:mymean {\:R-struct true, \:oper \:R->summary, \:parms [{\:R-struct true, \:oper \:R->\=, \:parms [\:x {\:R-struct true, \:oper \:R->vector, \:parms [[1 2 3 4 5]]}]}]}]})))\\r\\n    (testing \\"Mean output taking map and vector numbers failed\\"\\r\\n    (is\\r\\n      (\=  \\r\\n        (R->generate\\r\\n      (R->def \:mymean\\r\\n              (R->summary {\:x (R->vector 1 2 3 4 5)})))\\r\\n        \\"mymean<-summary(x\=c(1,2,3,4,5))\\"))))" "(summary-basic-test)" "(mean-complex-test)" "(contains? [\:num] \:num)" "(some \#(\= \:num %) [\:sdf \:num])" "(some \#(\= \:num %) [\:sdf \:numd])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n  \\"\:num allow numbers\\r\\n   \:vec allows vectors\\r\\n   \:map allows maps\\r\\n   \:r-str allow R structure\\"\\r\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1)\\r\\n      (some \#(\:num) options-vec))  [(apply dsl/R->vector data)]\\r\\n    (and \\r\\n      (apply vector? data) \\r\\n      (some \#(\:vec) options-vec))  [(apply dsl/R->vector (first data))]\\r\\n    (and \\r\\n      (apply map? data)\\r\\n      (apply \:R-struct data)\\r\\n      (some \#(\:r-str) options-vec))     [(first data)]\\r\\n    (and \\r\\n      (apply map? data) \\r\\n      (apply \:R-struct data)\\r\\n      (some \#(\:map) options-vec))         (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n    \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(require '[dsl.primary-operations \:as dsl])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n  \\"\:num allow numbers\\r\\n   \:vec allows vectors\\r\\n   \:map allows maps\\r\\n   \:r-str allow R structure\\"\\r\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1)\\r\\n      (some \#(\:num) options-vec))  [(apply dsl/R->vector data)]\\r\\n    (and \\r\\n      (apply vector? data) \\r\\n      (some \#(\:vec) options-vec))  [(apply dsl/R->vector (first data))]\\r\\n    (and \\r\\n      (apply map? data)\\r\\n      (apply \:R-struct data)\\r\\n      (some \#(\:r-str) options-vec))     [(first data)]\\r\\n    (and \\r\\n      (apply map? data) \\r\\n      (apply \:R-struct data)\\r\\n      (some \#(\:map) options-vec))         (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n    \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(run-all)" "(R->mean 1 1 3 3)" "(stnd-input-support '(1 2 3))" "(stnd-input-support [1 2 3])" "(stnd-input-support 1)" "(stnd-input-support [1 1 1])" "(stnd-input-support [1 2 3])" "(stnd-input-support [1 2 3] [\:mpa])" "\\r\\n(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))  [(apply dsl/R->vector data)]\\r\\n      (and \\r\\n        (apply vector? data) \\r\\n        (some \#(\:vec) options-vec))  [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))     [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:map) options-vec))         (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(stnd-input-support [1 1] [\:num])" "\\r\\n(defn stnd-input-support \\r\\n  ([ data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))  [(apply dsl/R->vector data)]\\r\\n      (and \\r\\n        (apply vector? data) \\r\\n        (some \#(\:vec) options-vec))  [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))     [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:map) options-vec))         (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(stnd-input-support [1 1] [\:num])" "(defn testm \\n  ([one] (println \\"testone\: \\" one))\\n  ([one two] (println \\"testtwo\: \\" one \\" \\" two)))" "(testm \\"first\\")" "(testm \\"first\\" \\"second\\")" "(defn testm \\n  ([one] (testm \\"another\\" one))\\n  ([one two] (println \\"testtwo\: \\" one \\" \\" two)))" "(testm \\"fire\\")" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]\\r\\n      (and \\r\\n        (apply vector? data) \\r\\n        (some \#(\:vec) options-vec))    [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:map) options-vec))    (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                         (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (println data))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]\\r\\n      (and \\r\\n        (apply vector? data) \\r\\n        (some \#(\:vec) options-vec))    [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:map) options-vec))    (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                         (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(stnd-input-support [1 2 3])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n   (print data options-vec)))" "(stnd-input-support [1 2 3])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]\\r\\n      (and \\r\\n        (apply vector? data) \\r\\n        (some \#(\:vec) options-vec))    [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:map) options-vec))    (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                         (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(stnd-input-support [1 2 3])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n   (print data options-vec)))" "(stnd-input-support [1 2 3])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]\\r\\n      (and \\r\\n        (apply vector? data) \\r\\n        (some \#(\:vec) options-vec))    [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:map) options-vec))    (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                         (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(stnd-input-support [1 2 3])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n   (print data options-vec)))" "(stnd-input-support [1 2 3])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n        (> (count data) 1)    [(apply dsl/R->vector data)]\\r\\n        (apply vector? data)     [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)) [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data))    (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                         (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(stnd-input-support [1 2 3])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]\\r\\n        (apply vector? data)   [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data))   (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                         (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(stnd-input-support [1 2 3])" "(let [data [1 2 3]\\n      options-vec [ 1 2 3]]\\n  (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]\\r\\n        (apply vector? data)   [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data))   (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default ) )" "(let [data [1 2 3]\\n      options-vec [ 1 2 3]]\\n  (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]\\r\\n        (apply vector? data)   [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data))   (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default [1]) )" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]\\r\\n        (apply vector? data)   [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data))   (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default [1]) )" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1)\\r\\n      (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]))" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n      (> (count data) 1)   [(apply dsl/R->vector data)]))" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1)\\r\\n      (not (nil? (some \#(\:num) options-vec))))   [(apply dsl/R->vector data)]))" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1)\\r\\n      nil)   [(apply dsl/R->vector data)]))" "(stnd-input-support [1 2 3])" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1))   [(apply dsl/R->vector data)]))" "(stnd-input-support [1 2 3])" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1))   [(apply dsl/R->vector data)]))" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1)\\n      nil)   [(apply dsl/R->vector data)]))" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1)\\n      (some \#(\:num) options-vec))   [(apply dsl/R->vector data)]))" "(some \#(\:num) [\:num \:d])" "(some \#{\:num} [\:num \:d])" "(R->mean 1 2 3)" "(run-all)" "(R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)}))" "(R->summary 1 2 3 4)" "(R->generate (R->summary 1 2 3 4))" "(R->generate (R->def \:mymean (R->summary {\:x (R->vector 1 2 3 4 5)})))" "(R->generate \\n  (R->def \:mymean \\n          (R->summary \\n            1 2 3 4 5)))" "(R->generate \\n                     (R->summary\\n                       {\:x (R->vector 1 2 3 4 5)}))" "(R->generate  (R->summary\\n                {\:x (R->vector 1 2 3 4 5)}))" "(R->generate  (R->mean\\n                {\:x (R->vector 1 2 3 4 5)}))" "(R->vector 1 1 1 )" "(R->vector [1 2] )" "(R->def \:one 1)" "(R->def \:one (R->vector 1 2 3))" "(R->generate(R->def \:one (R->vector 1 2 3)))" "(R->generate(R->mean {\:one 1}))" "  \\r\\n(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#{\:num} options-vec))    [(apply dsl/R->vector data)]\\r\\n      (and \\r\\n        (apply vector? data) \\r\\n        (some \#{\:vec} options-vec))    [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#{\:r-str} options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (some \#{\:map} options-vec))    (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                         (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#{\:num} options-vec))    [(apply dsl/R->vector data)]\\r\\n      (and \\r\\n        (apply vector? data) \\r\\n        (some \#{\:vec} options-vec))    [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#{\:r-str} options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (some \#{\:map} options-vec))    (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                         (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(run-all)" "(defn R->dataframe [& data]\\r\\n  \\"attribute map\\"\\r\\n  (gen/gen-R-struct R->dataframe (sup/stnd-input-support data [\:map \:r-srt])))" "(R->dataframe {\:x (R->vector 1 2 3)})" "(R->generate \\n  (R->dataframe {\:x (R->vector 1 2 3)}))" "(R->generate \\n  (R->dataframe {\:x 1}))" "(R->dataframe {\:x (R->vector 1 2 3)})" "(defn R->dataframe [& data]\\r\\n  \\"attribute map\\"\\r\\n  (gen/gen-R-struct \:R->dataframe (sup/stnd-input-support data [\:map \:r-srt])))" "(R->dataframe {\:x (R->vector 1 2 3)})" "(R->generate \\n  (R->dataframe {\:x (R->vector 1 2 3)}))" "(R->generate \\n  (R->mean {\:x (R->vector 1 2 3)}))" "(R->generate \\n  (R->dataframe {\:x (R->vector 1 2 3)}))" "(R->generate (R->dataframe {\:x (R->vector 2 3 4)}))" "(R->generate (R->dataframe 1 2 3))" "(R->dataframe 1 2 3)" "(R->dataframe 1)" "(R->dataframe {})" "(sup/stnd-input-support\\n  {\:x 1} [\:map \:r-srt])" "(R->generate (R->dataframe 1 2 3))" "(R->dataframe 1 2 3)" "(R->dataframe [1 2 3]\\n              \\n              )" "(R->dataframe 1 2 3)" "(R->dataframe (R->vector 1 2 3))" "(R->dataframe {\:x (R->vector 1 2 3)})" "(R->dataframe {\:x 1})" "(R->mean 1 2 3)" "(R->dataframe {\:x 1})" "(R->dataframe {\:x (R->vector 1 2 3)})" "(R->generate (R->dataframe {\:x (R->vector 1 2 3)}))" "\\n(R->generate\\n  (R->dataframe {\:x (R->vector 1 2 3) \\n          \:y (R->vector 4 5 6)}))" "\\n(R->generate\\n  (R->mean \\n    (R->dataframe {\:x (R->vector 1 2 3) \\n                   \:y (R->vector 4 5 6)})))" "\\n(R->generate\\n  (R->summary\\n    (R->dataframe {\:x (R->vector 1 2 3) \\n                   \:y (R->vector 4 5 6)})))" "\\n(R->generate\\n  (R->def \\n    \:values\\n    (R->summary\\n      (R->dataframe {\:x (R->vector 1 2 3) \\n                     \:y (R->vector 4 5 6)}))))" "(R->generate \\"values\\")" "\\n(R->generate\\n  (R->def \\n    \:values\\n    (R->summary\\n      (R->dataframe {\:x (R->vector 1 2 3) \\n                     \:y (R->vector 4 5 6)})))\\n  (R->dataframe? \:values)" "\\n(R->generate\\n  (R->def \\n    \:values\\n    (R->summary\\n      (R->dataframe {\:x (R->vector 1 2 3) \\n                     \:y (R->vector 4 5 6)})))\\n  (R->dataframe? \:values))" "\\n(R->generate\\n  (R->def \\n    \:values\\n    (R->summary\\n      (R->dataframe {\:x (R->vector 1 2 3) \\n                     \:y (R->vector 4 5 6)})))\\n  (R->dataframe? \\"v\\"))" "\\n(R->generate\\n  (R->def \\n    \:values\\n    (R->summary\\n      (R->dataframe {\:x (R->vector 1 2 3) \\n                     \:y (R->vector 4 5 6)}))))" "\\n(R->generate\\n  (R->dataframe? \\"v\\") )" "\\n  (R->dataframe? \\"v\\")" "(R->dataframe? \\"car\\")" "(R->dataframe? \:car)" "(name \:test)" "(R->generate (R->dataframe? \:test))" "\\n(R->generate\\n  (R->def \\n    \:values\\n    (R->summary\\n      (R->dataframe {\:x (R->vector 1 2 3) \\n                     \:y (R->vector 4 5 6)})))\\n  (R->dataframe? \\"v\\"))" "\\n(R->generate\\n  (R->def \\n    \:values\\n    (R->summary\\n      (R->dataframe {\:x (R->vector 1 2 3) \\n                     \:y (R->vector 4 5 6)})))\\n  (R->dataframe? \\"values\\"))" "(ns rc.core)" "(R->vector? \:one)" "(R->generate (R->vector? \:one))" "(R->matrix {\:x (R->vector 12 2 3 )})" "(R->generate (R->matrix {\:x (R->vector 12 2 3 )}))" "(R->generate (R->matrix {\:x (R->vector 12 2 3 ) \:y (R->vector 12 2 3 )}))" "(R->generate (R->mean {\:x (R->vector 12 2 3 ) \:y (R->vector 12 2 3 )}))" "(R->generate (R->matrix {\:x (R->vector 1 2 4) \:y (R->vector 4 5 6)}))" "(R->generate\\n  (R->summary\\n    (R->matrix {\:x (R->vector 1 2 4) \\n                \:y (R->vector 4 5 6)})))" "(R->generate\\n  (R->mean\\n    (R->matrix {\:x (R->vector 1 2 4) \\n                \:y (R->vector 4 5 6)})))" "(R->generate\\n  (R->mean\\n    (R->matrix {\:data (R->vector 1 2 4 1 2 4 1 2 4) \:ncol 3})))" "(R->vector 1 2 3 4 5)" "(R->generate (R->vector 1 2 3 4))" "(name \:stuff)" "(R->stripchart 1 2 3)" "(R->generate (R->stripchart 1 2 3))" "(R->generate (R->stripchart (R->range 1 4)))" "(R->generate (R->stripchart (R->vector (R->range 1 4))))" "(R->stripchart \\n  (R->vector\\n    (R->range 1 4)))" "(R->generate\\n  (R->vector\\n    (R->range 1 4)))" "(R->generate\\n\\n    (R->range 1 4))" "(R->generate (R->stripchart (R->vector 1 1 2 5 4 2 1 2.3 4.3)))" "(defn R->stripchart [& data]\\r\\n  \\"attribute map\\"\\r\\n  (gen/gen-R-struct \:R->stripchart (sup/stnd-input-support data [\:map \:r-srt])))" "(ns rc.core)" "(R->stripchart 1 1 1)" "(R->stripchart (R->vector 1 1 1))" "(defn R->stripchart [& data]\\r\\n  \\"attribute map\\"\\r\\n  (gen/gen-R-struct \:R->stripchart \\n                    (sup/stnd-input-support data [\:r-srt \:vec])))" "(R->stripchart 1 12)" "(defn R->stripchart [& data]\\r\\n  \\"attribute map\\"\\r\\n  (gen/gen-R-struct \:R->stripchart \\n                    (sup/stnd-input-support data [\:r-srt \:num])))" "(R->stripchart 1 12)" "(R->stripchart 1 1 12 23 33 2  3 4)" "(R->generate (R->stripchart 1 1 12 23 33 2  3 4))" "(defn gen-R->stripchart [values]\\r\\n  (str (reduce str \\"stripchart(\\"  values\\")\\")))" "(R->generate (R->stripchart 1 1 12 23 33 2  3 4))" "(defn gen-R->stripchart [values]\\r\\n  (str str \\"stripchart(\\"  values\\")\\"))" "(R->generate (R->stripchart 1 1 12 23 33 2  3 4))" "(R->generate (R->stripchart [1 1 12 23 33 2  3 4]))" "(R->generate (R->stripchart (R->vector 1 1 12 23 33 2  3 4)))" "(R->vector 1 1 12 23 33 2  3 4)" "(let [tm  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count tm)]\\n        (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))  [(first data)])" "(let [tm  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count tm)\\n      options-vec [\:r-str]]\\n        (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))  [(first data)])" "(let [data  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count tm)\\n      options-vec [\:r-str]]\\n        (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))  [(first data)])" "(let [data  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count data)\\n      options-vec [\:r-str]]\\n        (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))  [(first data)])" "(let [data  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count data)\\n      options-vec [\:r-str]]\\n       (if (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))  [(first data)])\\n       \\"yes\\"\\n       \\"no\\")" "(let [data  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count data)\\n      options-vec [\:r-str]]\\n       (if (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n       ; (apply map? data)\\r\\n        (apply \:R-struct data))  [(first data)])\\n       \\"yes\\"\\n       \\"no\\")" "(let [data  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count data)\\n      options-vec [\:r-str]]\\n       (if (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))\\n       \\"yes\\"\\n       \\"no\\"))" "(let [data  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count data)\\n      options-vec [\:r-str]]\\n       (if (and \\r\\n       ; (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))\\n       \\"yes\\"\\n       \\"no\\"))" "(let [data  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count data)\\n      options-vec [\:r-str]]\\n       (if (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n       ; (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))\\n       \\"yes\\"\\n       \\"no\\"))" "(let [data  '({\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count data)\\n      options-vec [\:r-str]]\\n       (if (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n       ; (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))\\n       \\"yes\\"\\n       \\"no\\"))" "(let [data  '({\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count data)\\n      options-vec [\:r-str]]\\n       (if (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))\\n       \\"yes\\"\\n       \\"no\\"))" "(R->vector 1 1 12 23 33 2  3 4)" "(R->generate (R->stripchart (R->vector 1 1 12 23 33 2  3 4)))" "(R->generate (R->stripchart 12 3 54 65))" "(R->mean 1 2 3)" "(R->generate (R->mean (R->vector 1 1 12 23 33 2  3 4)))" "(defn R->stripchart [& data]\\r\\n  \\"attribute map\\"\\r\\n  (gen/gen-R-struct \:R->stripchart (sup/stnd-input-support data)))" "(R->generate (R->stripchart (R->vector 1 1 12 23 33 2  3 4)))" "(ns rc.core)" "(R->generate (R->stripchart (R->vector 1 1 12 23 33 2  3 4)))" "(R->generate (R->stripchart [1 2 3 4]))" "(R->generate (R->stripchart 3 4 4 5))" "(R->generate (R->stripchart {}))" "(R->generate (R->stripchart (R->vector 1 1 12 23 33 2  3 4)))" "(R->generate (R->stripchart (R->vector (R->range 1 40))))" "(ns rc.core)" "(R->generate (R->boxplot 1 2 3 4))" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n             (R->\= \:mean2 (R->mean 3 5 6 7)) \\n             (R->\= \:mean3 (R->mean 3 5 67)) \\n             (R->\= \:mean4 (R->mean 3 75 6 7))\\n             (R->boxplot \:mean1 \:mean2 \:mean3 \:mean4))" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str \:key]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)]\\r\\n      (cond \\r\\n        (and \\r\\n          (some \#{\:key} options-vec)\\r\\n          (apply keyword? data))\\r\\n         [(apply name data)]        \\r\\n        (and \\r\\n          (some \#{\:num} options-vec)\\r\\n          (> cardinality 1)) \\r\\n         [(apply dsl/R->vector data)]\\r\\n        (and \\r\\n          (some \#{\:vec} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply vector? data))    \\r\\n        [(apply dsl/R->vector (first data))]\\r\\n        (and \\r\\n          (some \#{\:r-str} options-vec)\\r\\n          (\=  1)\\r\\n          (apply map? data)\\r\\n          (apply \:R-struct data))\\r\\n        [(first data)]\\r\\n        (and \\r\\n          (some \#{\:map} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data))    \\r\\n        (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n        \:default                         \\r\\n        (throw (Exception. (str \\"Invalid element in function\\"\\r\\n                            \\"\\\\nData\: \\" data \\r\\n                            \\"\\\\noptions\: \\" options-vec\\r\\n                            \\"\\\\nCardinality\: \\" cardinality)))))))" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n             (R->\= \:mean2 (R->mean 3 5 6 7)) \\n             (R->\= \:mean3 (R->mean 3 5 67)) \\n             (R->\= \:mean4 (R->mean 3 75 6 7))\\n             (R->boxplot \:mean1 \:mean2 \:mean3 \:mean4))" "(ns rc.core)" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n             (R->\= \:mean2 (R->mean 3 5 6 7)) \\n             (R->\= \:mean3 (R->mean 3 5 67)) \\n             (R->\= \:mean4 (R->mean 3 75 6 7))\\n             (R->boxplot \:mean1 \:mean2 \:mean3 \:mean4))" "(ns rc.core)" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n             (R->\= \:mean2 (R->mean 3 5 6 7)) \\n             (R->\= \:mean3 (R->mean 3 5 67)) \\n             (R->\= \:mean4 (R->mean 3 75 6 7))\\n             (R->boxplot \:mean1 \:mean2 \:mean3 \:mean4))" "\\n             (R->boxplot \:mean1 \:mean2 \:mean3 \:mean4)" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n             (R->\= \:mean2 (R->mean 3 5 6 7)) \\n             (R->\= \:mean3 (R->mean 3 5 67)) \\n             (R->\= \:mean4 (R->mean 3 75 6 7)))" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n)" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n             (R->\= \:mean2 (R->mean 3 5 6 7)) \\n             (R->\= \:mean3 (R->mean 3 5 67)) \\n             (R->\= \:mean4 (R->mean 3 75 6 7)))" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n             (R->\= \:mean2 (R->mean 3 5 6 7)) \\n             (R->\= \:mean3 (R->mean 3 5 67)) \\n             (R->\= \:mean4 (R->mean 3 75 6 7))\\n             (R->boxplot \:mean1 \:mean2 \:mean3 \:mean4))" "(ns rc.core)" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n             (R->\= \:mean2 (R->mean 3 5 6 7)) \\n             (R->\= \:mean3 (R->mean 3 5 67)) \\n             (R->\= \:mean4 (R->mean 3 75 6 7))\\n             (R->boxplot \:mean1 \:mean2 \:mean3 \:mean4))" "(ns rc.core)" "(R->sample 1 1 1 1)" "(R->generate (R->sample 1 1 1 1))" "(into [] '(1 2 3))" "(R->generate (R->sample 1 1 1 1))" "(ns rc.core)" "(R->generate (R->sample 1 1 1 1))" "(R->generate (R->sample (R->range 1 20) 1 1 1))" "(R->generate (R->sample 1 1 1 1))" "(R->generate (R->sample (R->range 1 20) 1 1 1))" "(R->\= \:one 2)" "(R->generate (R->\= \:one 2))" "(R->generate (R->def \:one 2))" "(R->generate (R->mean 1 1 1 2 3 4))" "(R->mean 1 1 1 2 3 4)" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (gen/gen-R-struct \:R->mean data [\:vec \:num \:map \:r-str] [\:vec->rvec \:raw->vec \:map->\=]))" "(defn R->mean-new [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (gen/gen-R-struct \:R->mean data [\:vec \:num \:map \:r-str] [\:vec->rvec \:raw->vec \:map->\=]))" "(defn R->mean-new [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (gen-R-struct \:R->mean data [\:vec \:num \:map \:r-str] [\:vec->rvec \:raw->vec \:map->\=]))" "(defn gen-R-struct [operation parms-vec validate-vec behavior-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec \:valid validate-vec \:behavior behavior-vec})" "(defn R->mean-new [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (gen-R-struct \:R->mean data [\:vec \:num \:map \:r-str] [\:vec->rvec \:raw->vec \:map->\=]))" "(R->mean-new 1 2 3)" "(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply \\r\\n    (resolve \\r\\n      (symbol (str \\"codeGeneration.RC-code-generation/gen-\\" (name (\:oper R-rep))))) ; get code emittion function\\r\\n    (for [entry (\:parms R-rep)] ; process each parameter\\r\\n      (cond \\r\\n        (map? entry) (R->generate-command entry) ;if map requires proccessing\\r\\n        (seq? entry) (apply R->generate-command entry) ; if sequence unwrap and process each\\r\\n        \:default  entry))))" "(defn gen-R-struct [operation parms-vec validate-vec behavior-vec]\\r\\n  {\:R-struct true \:oper operation \:parms (into [] parms-vec) \:valid validate-vec \:behavior behavior-vec})" "(R->mean-new 1 2 3)" "(R->mean-new {\:x 1})" "(R->mean-new 1 2 3)" "(R->generate (R->mean 1 1 1 2 3 4))" "(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  ;preprocess\\n  (let [R-rep (behavior-process R-rep)]\\r\\n  (apply \\r\\n    (resolve \\r\\n      (symbol (str \\"codeGeneration.RC-code-generation/gen-\\" (name (\:oper R-rep))))) ; get code emittion function\\r\\n    (for [entry (\:parms R-rep)] ; process each parameter\\r\\n      (cond \\r\\n        (map? entry) (R->generate-command entry) ;if map requires proccessing\\r\\n        (seq? entry) (apply R->generate-command entry) ; if sequence unwrap and process each\\r\\n        \:default  entry)))))" "(defn behavior-process\\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (behavior-process data [\:num \:vec \:map \:r-str \:key]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)]\\r\\n      (try \\r\\n        (cond        \\r\\n          (and \\r\\n            (some \#{\:num} options-vec)\\r\\n            (> cardinality 1)) \\r\\n          [(apply dsl/R->vector \\r\\n                  (map (fn [x] (if (keyword? x) (name x) x)) data))]\\r\\n          (and \\r\\n            (some \#{\:vec} options-vec)\\r\\n            (\= cardinality 1)\\r\\n            (apply vector? data))    \\r\\n          [(apply dsl/R->vector (first data))]\\r\\n          (and \\r\\n            (some \#{\:r-str} options-vec)\\r\\n            (\=  1)\\r\\n            (apply map? data)\\r\\n            (apply \:R-struct data))\\r\\n          [(first data)]\\r\\n          (and \\r\\n            (some \#{\:map} options-vec)\\r\\n            (\= cardinality 1)\\r\\n            (apply map? data))    \\r\\n          (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n          \:default                         \\r\\n          (throw (Exception. (str \\"Invalid parameter type in function.\\"))))\\r\\n      (catch Exception e (str \\"exception in std-input-support occured\: \\" (.getMessage e)\\r\\n                              \\"\\\\nData\: \\" data \\r\\n                              \\"\\\\noptions\: \\" options-vec\\r\\n                              \\"\\\\nCardinality\: \\" cardinality))))))" "(defn behavior-process\\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (behavior-process data [\:num \:vec \:map \:r-str \:key]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)]\\r\\n      (try \\r\\n        (cond        \\r\\n          (and \\r\\n            (some \#{\:num} options-vec)\\r\\n            (> cardinality 1)) \\r\\n          [(apply R->vector \\r\\n                  (map (fn [x] (if (keyword? x) (name x) x)) data))]\\r\\n          (and \\r\\n            (some \#{\:vec} options-vec)\\r\\n            (\= cardinality 1)\\r\\n            (apply vector? data))    \\r\\n          [(apply dsl/R->vector (first data))]\\r\\n          (and \\r\\n            (some \#{\:r-str} options-vec)\\r\\n            (\=  1)\\r\\n            (apply map? data)\\r\\n            (apply \:R-struct data))\\r\\n          [(first data)]\\r\\n          (and \\r\\n            (some \#{\:map} options-vec)\\r\\n            (\= cardinality 1)\\r\\n            (apply map? data))    \\r\\n          (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n          \:default                         \\r\\n          (throw (Exception. (str \\"Invalid parameter type in function.\\"))))\\r\\n      (catch Exception e (str \\"exception in std-input-support occured\: \\" (.getMessage e)\\r\\n                              \\"\\\\nData\: \\" data \\r\\n                              \\"\\\\noptions\: \\" options-vec\\r\\n                              \\"\\\\nCardinality\: \\" cardinality))))))" "(defn behavior-process\\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (behavior-process data [\:num \:vec \:map \:r-str \:key]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)]\\r\\n      (try \\r\\n        (cond        \\r\\n          (and \\r\\n            (some \#{\:num} options-vec)\\r\\n            (> cardinality 1)) \\r\\n          [(apply R->vector \\r\\n                  (map (fn [x] (if (keyword? x) (name x) x)) data))]\\r\\n          (and \\r\\n            (some \#{\:vec} options-vec)\\r\\n            (\= cardinality 1)\\r\\n            (apply vector? data))    \\r\\n          [(apply R->vector (first data))]\\r\\n          (and \\r\\n            (some \#{\:r-str} options-vec)\\r\\n            (\=  1)\\r\\n            (apply map? data)\\r\\n            (apply \:R-struct data))\\r\\n          [(first data)]\\r\\n          (and \\r\\n            (some \#{\:map} options-vec)\\r\\n            (\= cardinality 1)\\r\\n            (apply map? data))    \\r\\n          (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n          \:default                         \\r\\n          (throw (Exception. (str \\"Invalid parameter type in function.\\"))))\\r\\n      (catch Exception e (str \\"exception in std-input-support occured\: \\" (.getMessage e)\\r\\n                              \\"\\\\nData\: \\" data \\r\\n                              \\"\\\\noptions\: \\" options-vec\\r\\n                              \\"\\\\nCardinality\: \\" cardinality))))))" "(defn behavior-process\\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (behavior-process data [\:num \:vec \:map \:r-str \:key]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)]\\r\\n      (try \\r\\n        (cond        \\r\\n          (and \\r\\n            (some \#{\:num} options-vec)\\r\\n            (> cardinality 1)) \\r\\n          [(apply R->vector \\r\\n                  (map (fn [x] (if (keyword? x) (name x) x)) data))]\\r\\n          (and \\r\\n            (some \#{\:vec} options-vec)\\r\\n            (\= cardinality 1)\\r\\n            (apply vector? data))    \\r\\n          [(apply R->vector (first data))]\\r\\n          (and \\r\\n            (some \#{\:r-str} options-vec)\\r\\n            (\=  1)\\r\\n            (apply map? data)\\r\\n            (apply \:R-struct data))\\r\\n          [(first data)]\\r\\n          (and \\r\\n            (some \#{\:map} options-vec)\\r\\n            (\= cardinality 1)\\r\\n            (apply map? data))    \\r\\n          (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n          \:default                         \\r\\n          (throw (Exception. (str \\"Invalid parameter type in function.\\"))))\\r\\n      (catch Exception e (str \\"exception in std-input-support occured\: \\" (.getMessage e)\\r\\n                              \\"\\\\nData\: \\" data \\r\\n                              \\"\\\\noptions\: \\" options-vec\\r\\n                              \\"\\\\nCardinality\: \\" cardinality))))))" "(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  ;preprocess\\n  (let [R-rep (behavior-process R-rep)]\\r\\n  (apply \\r\\n    (resolve \\r\\n      (symbol (str \\"codeGeneration.RC-code-generation/gen-\\" (name (\:oper R-rep))))) ; get code emittion function\\r\\n    (for [entry (\:parms R-rep)] ; process each parameter\\r\\n      (cond \\r\\n        (map? entry) (R->generate-command entry) ;if map requires proccessing\\r\\n        (seq? entry) (apply R->generate-command entry) ; if sequence unwrap and process each\\r\\n        \:default  entry)))))" "(R->generate (R->mean 1 1 1 2 3 4))" "(R->generate-command (R->mean 1 1 1 2 3 4))" "(R->mean (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(R->generate (R->mean (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) )))" "(R->generate-command (R->mean 1 1 1 2 3 4))" "(R->generate (R->mean (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) )))" "(ns rc.core)" "(R->generate (R->mean (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) )))" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(defn gen-R->vector [& data]\\r\\n    (str \\"c(\\" (apply str (interpose \\",\\" data)) \\")\\")" "(defn gen-R->vector [& data]\\r\\n    (str \\"c(\\" (apply str (interpose \\",\\" data)) \\")\\"))" "(gen-R->vector 1 2 3 4)" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(defn gen-R->vector [& data]\\r\\n    (str \\"c(\\"  data \\")\\"))" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(defn gen-R->vector [& data]\\r\\n    (str \\"c(\\"  data \\")\\"))" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) )" "(R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1))" "(ns rc.core)" "(R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1))" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(interose \\",\\" '(\\"1\\" \\"1\\"))" "(interpose \\",\\" '(\\"1\\" \\"1\\"))" "ns" "(ns)" "(ns codeGeneration.RC-code-generation)" "(defn gen-R->vector [& data]\\n  (do (print data)\\r\\n    (str (interpose \\",\\" data)) \\")\\"))" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(ns rc.core)" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(ns codeGeneration.RC-code-generation)" "(defn gen-R->vector [& data]\\n  (do (print data) (print (interpose \\",\\" data))\\r\\n    (str (interpose \\",\\" data)) \\")\\"))" "(ns rc.core)" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(ns codeGeneration.RC-code-generation)" "(defn gen-R->vector [& data]\\r\\n    (str (interpose \\",\\" data) \\")\\"))" "(ns rc.core)" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(ns codeGeneration.RC-code-generation)" "(defn gen-R->vector [& data]\\r\\n    (apply str (interpose \\",\\" data) \\")\\"))" "(ns rc.core)" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(ns codeGeneration.RC-code-generation)" "(defn gen-R->vector [& data]\\r\\n    (str (interpose \\",\\" data)))" "(ns rc.core)" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(ns codeGeneration.RC-code-generation)" "(defn gen-R->vector [& data]\\r\\n    (str (interpose \\",\\" \\n                    )))" "(str (interpose \\",\\" '(1 1 1)))" "(apply str (interpose \\",\\" '(1 1 1)))" "(str \\"c(\\" (apply str (interpose \\",\\" '(1 1 1))) \\")\\")" "(defn gen-R->vector [& data]\\r\\n    (str \\"c(\\" (apply str (interpose \\",\\" data)) \\")\\"))" "(ns rc.core)" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))" "(R->keyword \:dog)" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))" "(R->generate (R->mean (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) )))" "(R->generate (R->mean (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))" "(R->generate (R->mean \\n               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\n               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))" "(R->generate (R->def \:main1 (R->mean \\n                             (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\n                             (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) )))))" "(R->generate (R->def \:m1 (R->mean \\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->def \:m2 (R->mean \\r\\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->def \:m3 (R->mean \\r\\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->stripchart (R->keyword m1) (R->keyword m2) (R->keyword m3)))" "(R->generate (R->def \:m1 (R->mean \\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->def \:m2 (R->mean \\r\\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->def \:m3 (R->mean \\r\\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->stripchart (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3)))" "(R->generate (R->def \:m1 (R->mean \\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->def \:m2 (R->mean \\r\\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->def \:m3 (R->mean \\r\\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->stripchart (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3))))" "(R->generate \\n  (R->def \:dog 4)\\n  (R->def \:m1 (R->mean \\n                (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\n                (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n  (R->def \:m2 (R->mean \\r\\n                (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n  (R->def \:m3 (R->mean \\r\\n                (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n  (R->stripchart (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3))))" "          (R->generate \\r\\n                 (R->def \:dog 4)\\r\\n                 (R->def \:m1 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\r\\n                 (R->def \:m2 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\r\\n                 (R->def \:m3 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\r\\n                 (R->stripchart (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3))))" "(R->generate (R->boxplot (R->\= \:x (R->vector 1 2 3)) (R->\= \:y (R->vector 1 2 3))))" "(ns dsl.composit-operations)" "(mean 1 2 3 4)" "(ns rc.core)" "  (require '[codeGeneration.RC-code-generation \:refer [R->generate]]\\r\\n            '[dsl.primary-operations \:refer \:all]\\r\\n            '[dsl.composit-operations \:refer \:all])" "(R->generate (mean 1 2 3))" "(R->generate (mean {\:x [1 2 3]}))" "(R->generate (mean {\:x (R->vector 1 2 3)}))" "(R->generate (mean 1 2 3))" "  (require '[codeGeneration.RC-code-generation \:refer [R->generate]]\\r\\n            '[dsl.primary-operations \:refer \:all]\\r\\n            '[dsl.composit-operations \:refer \:all]\\r\\n            )" "(R->generate (mean 1 2 3))" "(map (fn [x] (cond\\n               (number? x) (R->number x)\\n               (keyword? x) (R->keyword x)\\n               \:default (throw (Exception. (str \\"Invalid parameter type in function.\\"))))) [1 3 \:d 4])" "(R->generate (mean 1 2 3))" " (mean 1 2 3)" "(R->generate (mean 1 2 3))" "(R->generate (mean (R->vector 1 2 3)))" " (R->generate \\r\\n                 (R->def \:dog 4)\\r\\n                 (R->def \:m1 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\r\\n                 (R->def \:m2 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\r\\n                 (R->def \:m3 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\r\\n                 (R->stripchart (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3))))" "(R->generate (mean (R->vector 1 2 3)))" " (mean (R->vector 1 2 3))" "  (require '[codeGeneration.RC-code-generation \:refer [R->generate]]\\r\\n            '[dsl.primary-operations \:refer \:all]\\r\\n            '[dsl.composit-operations \:refer \:all])" " (mean (R->vector 1 2 3))" "(R->vector 1 2 3)" " (mean (R->vector 1 2 3))" "(R->vector 1 2 3)" " (mean (R->vector 1 2 3))" "(R->vector 1 2 3)" " (mean 1 2 3)" "(R->generate (mean 1 2 3))" "(R->vector 1 2 3)" "(apply assoc '({\:R-struct true, \:oper \:R->vector, \:parms []}) \:parms (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}))))" "(defn convert-raw-value [data-coll]\\r\\n  (into []\\r\\n        (map (fn [x] (cond\\r\\n                 (number? x) (dsl/R->number x)\\r\\n                 (keyword? x) (dsl/R->keyword x)\\r\\n                 \:default (throw (Exception. (str \\"Invalid parameter type in function.\\"))))) data-coll)))" "(require '[dsl.primary-operations \:as dsl])" "(defn convert-raw-value [data-coll]\\r\\n  (into []\\r\\n        (map (fn [x] (cond\\r\\n                 (number? x) (dsl/R->number x)\\r\\n                 (keyword? x) (dsl/R->keyword x)\\r\\n                 \:default (throw (Exception. (str \\"Invalid parameter type in function.\\"))))) data-coll)))" "(apply assoc '({\:R-struct true, \:oper \:R->vector, \:parms []}) \:parms (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}))))" " (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]})))" "(assoc '({\:R-struct true, \:oper \:R->vector, \:parms []}) \\n       \:parms (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}))))" "(apply assoc '({\:R-struct true, \:oper \:R->vector, \:parms []}) \\n       \:parms (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}))))" "(assoc (first '({\:R-struct true, \:oper \:R->vector, \:parms []})) \\n       \:parms (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}))))" " (-> '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}) first (assoc  \:parms \\n                                                                        \\n                                                                         (->> '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}) (apply \:parms) (convert-raw-value))))" " (-> '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}) first (assoc  \:parms \\n                                                                        \\n                                                                         (->> '({\:R-struct true, \:oper \:R->vector, \:parms [1 444 3]}) (apply \:parms) (convert-raw-value))))" " (mean (R->vector 1 2 3))" "(R->generate (mean (R->vector 1 2 3)))" "(R->stripchart 1 2 3)" "(R->stripchart (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3)))" "(R->generate (R->stripchart (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3))))" "(R->generate (R->mean (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3))))" "(require '[testDrivenDev.integration-test])"]
eclipse.preferences.version=1
