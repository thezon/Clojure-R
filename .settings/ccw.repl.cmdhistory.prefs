cmdhistory=["   (defn R.def [name value]\\n     (str name \\"<-\\" value))" "(RC.core \\"car\\" 5)" "(R.def \\"car\\" 5)" "   (defn def [name value]\\n     (str name \\"<-\\" value))" "(def \\"car\\" 4)" "   (defn R->def [name value]\\n     (str name \\"<-\\" value))" "(R->def \\"car\\" 4)" "(defn R->vector [& values]\\n  (concat values))" "(R->vector 1 2 3 4)" "(R->vector [1 2 3 4])" "(defn R->vector [& values]\\n  [values])" "(R->vector [1 2 3 4])" "(R->vector 1 2 3 4)" "(defn R->vector [& values]\\n  (into [] values))" "(R->vector 1 2 3 4)" "(R->vector [1 2 3 4])" "(R->def test (R->vector 1 2 3 4))" "   (defn R->def [name value]\\n     (str (str name) \\"<-\\" value))" "(R->def test (R->vector 1 2 3 4))" "   (defn R->def [name value]\\n     (str (.toString name) \\"<-\\" value))" "(R->def test (R->vector 1 2 3 4))" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->def [name value]\\r\\n        (str (name name) \\"<-\\" value))" "(R->def \:test (R->vector 1 2 3 4))" "(name \:test)" "(defn R->def [var-name value]\\r\\n        (str (name var-name) \\"<-\\" value))" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->vector [& values]\\r\\n  (interpose \\",\\" (into [] values))" "(defn R->vector [& values]\\r\\n  (interpose \\",\\" (into [] values)))" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->vector [& values]\\r\\n  (str (interpose \\",\\" (into [] values))))" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->vector [& values]\\r\\n  (str (interpose \\",\\" values)))" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->vector [& values]\\r\\n   (interpose \\",\\" values))" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->vector [& values]\\r\\n   (apply str (interpose \\",\\" values)))" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->def [var-name value]\\r\\n        (str \\"c\\" (name var-name) \\"<-\\" value))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n   (apply str (into [] (interpose \\",\\" values))))" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->vector [& values]\\r\\n   [(interpose \\",\\" values)])" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->def [var-name value]\\r\\n        (str (name var-name) \\"<-\\" value))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n   (into [] (interpose \\",\\" values)))" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->vector [& values]\\r\\n   (str \\"c\\" (into [] (interpose \\",\\" values))))" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->vector [& values]\\r\\n   (str \\"c\\" (concat (into [] (interpose \\",\\" values)))))" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->vector [& values]\\r\\n   (concat (str (into [] (interpose \\",\\" values)))))" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->vector [& values]\\r\\n   (apply str (concat (str (into [] (interpose \\",\\" values))))))" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->vector [& values]\\r\\n   (apply str (concat (str (into [] (interpose , values))))))" "(R->def \:test (R->vector 1 2 3 4))" "(str [1 2 3])" "(apply str [1 2 3])" "(map \#(str %) [1 2 3])" "(defn R->vector [& values]\\r\\n   (apply str  (into [] (interpose \\",\\" (map str values))))" "(defn R->vector [& values]\\r\\n   (apply str  (into [] (interpose \\",\\" (map str values)))))" "(map \#(str %) [1 2 3])" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->vector [& values]\\r\\n     (into [] (interpose \\",\\" (map str values))))" "(defn R->vector [& values]\\r\\n     (str \\"c\\" (into [] (interpose \\",\\" (map str values)))))" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->vector [& values]\\r\\n     (str \\"c\\" (apply str (into [] (interpose \\",\\" (map str values))))))" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->vector [& values]\\r\\n     (str \\"c\\" (into []  (apply str (interpose \\",\\" (map str values))))))" "(R->def \:test (R->vector 1 2 3 4))" "(interpose \\",\\" '(1 2 3 4))" "(map str (interpose \\",\\" '(1 2 3 4)))" "(concat (map str (interpose \\",\\" '(1 2 3 4))))" "(apply str  (map str (interpose \\",\\" '(1 2 3 4))))" "(str \\"[\\"(apply str  (map str (interpose \\",\\" '(1 2 3 4))) \\"]\\"))" "(map str (interpose \\",\\" '(1 2 3 4)))" "(reduce str [1 2 3 4])" "(reduce str (interose \\",\\" [1 2 3 4]))" "(reduce str (interpose \\",\\" [1 2 3 4]))" "(reduce str \\"c[\\" (interpose \\",\\" [1 2 3 4]))" "(reduce str \\"c[\\" (interpose \\",\\" [1 2 3 4 \\"]\\"]))" "(reduce str \\"c[\\" (conj (interpose \\",\\" [1 2 3 4]) \\"]\\"))" "(reduce str \\"c[\\"  (interpose \\",\\" [1 2 3 4]))" "(str (reduce str \\"c[\\"  (interpose \\",\\" [1 2 3 4])) \\"]\\")" "(defn R->vector [& values]\\r\\n      (str (reduce str \\"c[\\"  (interpose \\",\\" values)) \\"]\\"))" "(R->def \:test (R->vector 1 2 3 4))" "(defn R->range [low-val high-val]\\n  (str \\"(\\" low-val \\"\:\\" high-val \\")\\"))" "(R->range 1 3)" "(R->def \:some-range (R->range 3 5))" "(defn R->mean [vec]\\n  (str \\"mean(\\" vec \\")\\"))" "(R->mean (R->vector 1 2 3 4))" "(R->def \:result (R->mean (R->vector 1 2 3 4)))" "(defprotocol R-oper\\n  (R-rep[_])\\n  (C-rep[_]))" "(defmulti R-process map?)" "(defmulti R-process true (println \\"map\\"))" "(defmethod R-process true (println \\"map\\"))" "(defmethod R-process true [] (println \\"map\\"))" "(R-process {})" "(defmethod R-process true [map] (println \\"map\\"))" "(R-process {})" "(defmethod R-process true [] (println \\"map\\"))" "(defmulti R-process true (println \\"map\\"))" "(defmulti R-process map?)" "(defmulti R-process false [& values] (println \\"no map\\"))" "(defmulti R-process false [values] (println \\"no map\\"))" "(defmethod R-process false [values] (println \\"no map\\"))" "(R-process {})" "(defmethod R-process true [map] (println \\"map\\"))" "(defmethod R-process false [values] (println \\"no map\\"))" "(defmulti R-process map?)" "(R-process {})" "(R-process [])" "(R->mean (R->vector 1 2 3 4))" "(defn R->def [var-name value]\\r\\n        {\:R->def {\:var-name var-name \:value value}})" "(R->def \:car 4)" "(defn R->vector [& values]\\r\\n    {\:R->vector {\:values (into [] values)}})" "(R->vector 1 2 43 4)" "(R-def \:stuff (R->vector 1 2 4))" "(R->def \:stuff (R->vector 1 2 4))" "(defn R->vector [& values]\\r\\n    {\:R->vector \:values (into [] values)})" "(defn R->vector [& values]\\r\\n    {\:oper \:R->vector \:params {\:values (into [] values)}})" "(defn R->def [var-name value]\\r\\n        {\:oper \:R->def \:params {\:var-name var-name \:value value}})" "(R->def \:stuff (R->vector 1 2 4))" "(def td {\:oper \:R->def, \:params {\:var-name \:stuff, \:value {\:oper \:R->vector, \:params {\:values [1 2 4]}}}})" "((\:oper td) (\:params td))" "(\:oper td)" "(name (\:oper td))" "(concat \\"internal-\\" (name (\:oper td)))" "(str \\"internal-\\" (name (\:oper td)))" "(str \\"internal-\\" (name (\:oper td))(\:oper td))" "(str \\"internal-\\" (name (\:oper td)) \\" \\" (\:prams td))" "(str \\"internal-\\" (name (\:oper td)) \\" \\" (\:params td))" "(defn R->def [var-name value]\\r\\n        {\:oper \:R->def \:params [\:var-name var-name \:value value]})" "(defn R->vector [& values]\\r\\n    {\:oper \:R->vector \:params [\:values (into [] values)]})" "(str \\"internal-\\" (name (\:oper td)) \\" \\" (\:params td))" "(def td (R->def \:stuff (R->vector 1 2 4)))" "(str \\"internal-\\" (name (\:oper td)) \\" \\" (\:params td))" "(defn R->vector [& values]\\r\\n    {\:oper \:R->vector \:params [(into [] values)]})" "(defn R->def [var-name value]\\r\\n        {\:oper \:R->def \:params [var-name value]})" "(def td (R->def \:stuff (R->vector 1 2 4)))" "(str \\"internal-\\" (name (\:oper td)) \\" \\" (\:params td))" "(defn R->def [var-name value]\\r\\n        {\:oper \:R->def \:params [(name var-name) value]})" "(def td (R->def \:stuff (R->vector 1 2 4)))" "(str \\"internal-\\" (name (\:oper td)) \\" \\" (\:params td))" "(defn R-generate [R-rep]\\n  (str \\"internal-\\" (name (\:oper R-rep)) \\" \\" (\:params R-rep)))" "(R->vector 1 2 4)" "(R-generate (R->vector 1 2 4))" "(keyword \\"test\\")" "(symbol \\"car\\")" "(defn R-generate [R-rep]\\n  ((symbol \\"internal-\\" (name (\:oper R-rep))) \\" \\" (\:params R-rep)))" "(R-generate (R->vector 1 2 4))" "(R-generate (R->def \:car 45\\n                    ))" "(R->def \:car 45)" "(defn R-generate [R-rep]\\n  (apply (symbol \\"internal-\\" (name (\:oper R-rep))) \\" \\" (\:params R-rep)))" "(R->def \:car 45)" "(R-generate (R->def \:car 45\\n                    ))" "(defn R-generate [R-rep]\\n  (let [oper (symbol \\"internal-\\" (name (\:oper R-rep)))\\n        parms (\:params R-rep)]\\n    (apply oper parms)))" "(R-generate (R->def \:car 45\\n                    ))" "(R-generate (R->def \:car 45))" "(R->def \:car 45)" "(defn R-generate [R-rep]\\n  (let [oper (symbol \\"internal-\\" (name (\:oper R-rep)))\\n        parms (\:params R-rep)]\\n    (println oper parms)))" "(R->def \:car 45)" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (symbol \\"internal-\\" (name (\:oper R-rep)))\\n        parms (\:params R-rep)]\\n    (println apply oper parms)))" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (str (symbol \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)]\\n    (println apply oper parms)))" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (str (symbol \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)]\\n    (println  oper parms)))" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (str (symbol \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)]\\n    (apply oper parms)))" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (str (symbol \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)]\\n    (oper parms)))" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)]\\n    (oper parms)))" "(R-generate (R->def \:car 45))" "(R->def \:car 45)" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)]\\n    (println oper parms)))" "(R->def \:car 45)" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)]\\n    (apply oper parms)))" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)]\\n    (print oper parms)))" "(R-generate (R->def \:car 45))" "(apply internal-R->def [car 45])" "(apply internal-R->def [\:car 45])" "( internal-R->def \:car 45)" "(defn internal-R->def [var-name value]\\r\\n        (str (name var-name) \\"<-\\" value))" "( internal-R->def \:car 45)" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)]\\n    (apply oper parms)))" "(R-generate (R->def \:car 45))" "( internal-R->def \:car 45)" "(apply internal-R->def [\:car 45])" "(defn R->def [var-name value]\\r\\n        {\:oper \:R->def \:params [(str (name var-name)) value]})" "(R-generate (R->def \:car 45))" "(apply internal-R->def [\:car 45])" "(defn R->def [var-name value]\\r\\n        {\:oper \:R->def \:params [var-name value]})" "(R-generate (R->def \:car 45))" "(apply internal-R->def [\:car 45])" "(defn R->def [var-name value]\\r\\n        {\:oper \:R->def \:params [var-name value]})" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)]\\n    (print oper parms)))" "(R-generate (R->def \:car 45))" "(apply internal-R->def [\:car 45])" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)\\n        _ (println parms)]\\n    (print oper parms)))" "(apply internal-R->def [\:car 45])" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)\\n        _ (println parms)]\\n    (apply oper parms)))" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)\\n        _ (println parms)]\\n    (do (println oper parms) (apply oper parms))))" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)\\n        _ (println parms)]\\n    (apply oper parms)))" "(apply internal-R->def [\:car 45])" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms [\:car 55];(\:params R-rep)\\n        _ (println parms)]\\n    (apply oper parms)))" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms [\:car 55];(\:params R-rep)\\n        _ (println parms)]\\n    (apply oper  [\:car 55])))" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms [\:car 55];(\:params R-rep)\\n        _ (println parms)]\\n    (apply internal-R->def  [\:car 55])))" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms [\:car 55];(\:params R-rep)\\n        _ (println parms)]\\n    (apply internal-R->def parms)))" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper internal-R->def\\n        parms [\:car 55];(\:params R-rep)\\n        _ (println parms)]\\n    (apply internal-R->def parms)))" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)\\n        _ (println parms)]\\n    (oper \:two 3)))" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"interjnal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)\\n        _ (println parms)]\\n    (oper \:two 3)))" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)\\n        _ (println parms)]\\n    (oper \:two 3)))" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)]\\n    (print oper \:two 3)))" "(R-generate (R->def \:car 45))" "(internal-R->def \:two 3)" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)]\\n    (apply oper parms)))" "(internal-R->def \:two 3)" "(R-generate (R->def \:car 45))" "(internal-R->def \:two 3)" "(R-generate (R->def \:car 45))" "(defn R-generate [R-rep]\\n  (let [oper (symbol (str \\"internal-\\" (name (\:oper R-rep))))\\n        parms (\:params R-rep)]\\n    (map \#(oper %1 %2) parms)))" "(R-generate (R->def \:car 45))" "(R-def \:car 45)" "(R->def \:car 3)" "(R-generate (R->def \:car 3))" "(defn R-generate [R-rep]\\r\\n  (let [oper (resove (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n        parms (\:params R-rep)]\\r\\n    (apply oper parms)))" "(defn R-generate [R-rep]\\r\\n  (let [oper (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n        parms (\:params R-rep)]\\r\\n    (apply oper parms)))" "(R-generate (R->def \:car 3))" "(deftest mean-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\= (R->mean 1 2 3 4) \\"mean(c[1,2,3,4])\\"))))" "  (require '[clojure.test \:refer \:all])" "(deftest mean-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\= (R->mean 1 2 3 4) \\"mean(c[1,2,3,4])\\"))))" "(R->vector 1 2 3 4)" "(defn R->vector [& values]\\r\\n    {\:oper \:R->vector \:params [values]})" "(R->vector 1 2 3 4)" "\\r\\n(defn R->vector [& values]\\r\\n    {\:oper \:R->vector \:params [(into [] values)]})" "(defn internal-R->vector [values]\\r\\n      (str (reduce str \\"c[\\"  (interpose \\",\\" values)) \\"]\\"))" "(R->vector 1 2 3 4)" "(R-generate (R->vector 1 2 3 4))" "(R-generate (R->def \:car (R->vector 1 2 3 4)))" "(defn R-generate [R-rep]\\r\\n    (apply \\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep))))) \\n      (for [entry (\:params R-rep)]\\n        (if (map? entry)\\n          (R-generate entry)\\n          entry))))" "(R-generate (R->def \:car (R->vector 1 2 3 4)))" "(R-generate (R->mean \:car (R->vector 1 2 3 4)))" "(defn R->mean [vec]\\r\\n{\:oper \:R->mean \:params vec})" "(R-generate (R->mean \:car (R->vector 1 2 3 4)))" "(R->mean \:car (R->vector 1 2 3 4))" "(R->vector 1 2 3 4)" "(defn R->mean [vec]\\r\\n{\:oper \:R->mean \:params vec})" "(R->mean 12 4)" "(R->mean [12 4])" "(R->vector 1 2 3 4)" "(R->mean {\:oper \:R->vector, \:params [[1 2 3 4]]})" "(R->mean \:car (R->vector 1 2 3 4))" "(defn R->range [low-val high-val]\\r\\n{\:oper \:R->range \:params [low-val high-val]})" "(R->range 30 45)" "(R->mean 1 2 3)" "(R->mean (R->vector 1 2 3))" "(R-generate (R->mean (R->vector 1 2 3)))" "(defn R-generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep))))) \\r\\n      (for [entry (\:params R-rep)]\\r\\n        (if (map? entry)\\r\\n          (do (print entry) (R-generate entry))\\r\\n          entry))))" "(R-generate (R->mean (R->vector 1 2 3)))" " (R->mean (R->vector 1 2 3))" "(defn R->mean [vec]\\r\\n  {\:oper \:R->mean \:params [vec]})" " (R->mean (R->vector 1 2 3))" "(R-generate (R->mean (R->vector 1 2 3)))" "(R-generate (R->def \:how-much (R->mean (R->vector 1 2 3))))" "(deftest mean-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\= (R->mean 1 2 3 4) \\"mean(c[1,2,3,4])\\"))))\\r\\n\\r\\n(deftest vector-assign-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\= (R-generate (R->def \:car (R->vector 1 2 3 4)))\\r\\n           \\"car<-c[1,2,3,4]\\"))))\\r\\n\\r\\n(deftest vector-mean-assign-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\= (R-generate (R->def \:how-much (R->mean (R->vector 1 2 3)))) \\"how-much<-mean(c[1,2,3])\\"))))" " (require '[clojure.test \:refer \:all]" " (require '[clojure.test \:refer \:all])" "(deftest mean-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\= (R->mean 1 2 3 4) \\"mean(c[1,2,3,4])\\"))))\\r\\n\\r\\n(deftest vector-assign-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\= (R-generate (R->def \:car (R->vector 1 2 3 4)))\\r\\n           \\"car<-c[1,2,3,4]\\"))))\\r\\n\\r\\n(deftest vector-mean-assign-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\= (R-generate (R->def \:how-much (R->mean (R->vector 1 2 3)))) \\"how-much<-mean(c[1,2,3])\\"))))" "mean-basic-test" "(mean-basic-test)" "(defn run-test-sweet []\\r\\n  (do mean-basic-test\\r\\n    vector-assign-test\\r\\n    vector-mean-assign-test))" "mean-basic-test" "(mean-basic-test)" "(R-generate (R->def \:how-much (R->mean (R->vector 1 2 3))))" "(R->mean 1 2 3 4)" "(defn R->mean [& data]\\r\\n  {\:oper \:R->mean \:params \\r\\n   (if (>(apply count data) 1)\\r\\n     (into [] data)\\r\\n     (first data))})" "(R->mean 1 2 4)" "(defn R->mean [& data]\\r\\n  {\:oper \:R->mean \:params \\r\\n   (if (>(count data) 1)\\r\\n     (into [] data)\\r\\n     (first data))})" "(R->mean 1 2 4)" " (require '[clojure.test \:refer \:all])" "(deftest mean-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\= (R->mean 1 2 3 4) \\"mean(c[1,2,3,4])\\"))))" "(mean-basic-test)" "(deftest mean-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\= (R-generate (R->mean 1 2 3 4) \\"mean(c[1,2,3,4])\\")))))" "(mean-basic-test)" "(R-generate (R->mean 1 2 3))" "(defn R->mean [& data]\\r\\n  {\:oper \:R->mean \:params \\r\\n   (if (>(count data) 1)\\r\\n     (into [] data)\\r\\n     (first data))})" "(R-generate (R->mean (R->vector 1 2 3)))" "(defn R->mean [& data]\\r\\n  {\:oper \:R->mean \:params \\r\\n   (if (>(count data) 1)\\r\\n     [(into [] data)]\\r\\n     [(first data)])})" "(R-generate (R->mean (R->vector 1 2 3)))" "(defn R->mean [& data]\\r\\n  {\:oper \:R->mean \:params \\r\\n   [(if (>(count data) 1)\\r\\n     (into [] data)\\r\\n     (first data))]})" "(R-generate (R->mean (R->vector 1 2 3)))" "(R-generate (R->mean  1 2 3))" "(defn R->mean [& data]\\r\\n  {\:oper \:R->mean \:params \\r\\n   [(if (>(count data) 1)\\r\\n     (apply R->vector data)\\r\\n     (first data))]})" "(R-generate (R->mean  1 2 3))" "(R-generate (R->mean (R->vector 1 2 3)))" "(defn R-slurp [path]\\n  {\:R-slurp [path]})" "(defn R-slurp [path]\\n  {\:oper \:R-slurp \:params [path]})" "(defn R-slurp [path]\\r\\n     {\:oper \:R-slurp \:params [path]})" "(defn internal-R-slurp [path]\\r\\n     (str \\"read.table(\\" path \\")\\"))" "(R-generate (R-slurp \\"/something to slurp\\"))" "(defn internal-R-slurp [path]\\r\\n     (str \\"read.table(\\\\\\"\\" path \\"\\\\\\")\\"))" "(R-generate (R-slurp \\"/something to slurp\\"))" "(R-generate (R->mean (R-slurp \\"c\\\\\:thesnuts\\")))" "(R-generate (R->mean (R-slurp \\"c/\:thesnuts\\")))" "(R-generate (R->def \:result (R->mean (R-slurp \\"c/\:thesnuts\\"))))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  {\:oper \:R->mean \:params \\r\\n   (if (>(count data) 1)\\r\\n     (apply R->vector data)\\n    (if (vector? data)\\r\\n       (first data)\\n       (if })" "(apply class [1 2 2])" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  {\:oper \:R->mean \:params \\r\\n   (if (>(count data) 1)\\r\\n     (apply R->vector data)\\n    (if (vector? data)\\r\\n       (first data)\\n       (if (and (apply map? data) (\:R-map (first data)))\\n         (println \\"good stuff\\")\\n         (println \\"fail\\"))))})" "(R->mean {\:x [1 2 3] \:y [4 5 6]})" "(R->mean {\:x [1 2 3] \:y [4 5 6] \:R-map true})" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  {\:oper \:R->mean \:params \\r\\n   (if (>(count data) 1)\\r\\n     (apply R->vector data)\\n    (if (vector? data)\\r\\n       (first data)\\n       (if (and (apply map? data) (\:R-map (first data)))\\n         (println \\"good stuff\\")\\n         (println \\"fail\\"))))})" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  {\:oper \:R->mean \:params \\r\\n   (if (>(count data) 1)\\r\\n     (apply R->vector data)\\n    (if (vector? data)\\r\\n       (first data)\\n       (if (and (apply map? data) (\:R-map (first data)))\\n         \\n         (println \\"fail\\"))))})" "(partition 2 {\:x [1 2 3] \:y [4 5 6] })" "(partition 2 2 {\:x [1 2 3] \:y [4 5 6] })" "(partition 2 2 (flatten {\:x [1 2 3] \:y [4 5 6] }))" "(partition 2 (flatten {\:x [1 2 3] \:y [4 5 6] }))" "2 (flatten {\:x [1 2 3] \:y [4 5 6] })" "(partition 2 {\:x [1 2 3] \:y [4 5 6] })" "(flatten (partition 2 {\:x [1 2 3] \:y [4 5 6] }))" "(partition 2 {\:x [1 2 3] \:y [4 5 6] })" "(apply into [] (partition 2 {\:x [1 2 3] \:y [4 5 6] }))" "(map \#(str (name %1) \\"\=\\" %2)(apply into [] (partition 2 {\:x [1 2 3] \:y [4 5 6] })))" "(map \#(str (name (first %) \\"\=\\" (second %))) (apply into [] (partition 2 {\:x [1 2 3] \:y [4 5 6] })))" "(apply into [] (partition 2 {\:x [1 2 3] \:y [4 5 6] }))" "(map (fn [val] (str (first val) \\"\=\\" (second val))) (apply into [] (partition 2 {\:x [1 2 3] \:y [4 5 6] })))" "(map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (partition 2 {\:x [1 2 3] \:y [4 5 6] })))" "(interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (partition 2 {\:x [1 2 3] \:y [4 5 6] }))))" "(str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (partition 2 {\:x [1 2 3] \:y [4 5 6] })))))" "(apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (partition 2 {\:x [1 2 3] \:y [4 5 6] })))))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  {\:oper \:R->mean \:params \\r\\n   (if (>(count data) 1)\\r\\n     (apply R->vector data)\\n    (if (vector? data)\\r\\n       (first data)\\n       (if (apply map? data)\\n         (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (partition 2 data)))))\\n         (println \\"fail\\"))))})" "(R->mean {\:x [1 2 3] \:y [4 5 6]})" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  {\:oper \:R->mean \:params \\r\\n   (if (>(count data) 1)\\r\\n     (apply R->vector data)\\n    (if (vector? data)\\r\\n       (first data)\\n       (if (apply map? data)\\n         (println data);(apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (partition 2 data)))))\\n         (println \\"fail\\"))))})" "(R->mean {\:x [1 2 3] \:y [4 5 6]})" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  {\:oper \:R->mean \:params \\r\\n   (if (>(count data) 1)\\r\\n     (apply R->vector data)\\n    (if (vector? data)\\r\\n       (first data)\\n       (if (apply map? data)\\n         (println (partition 2 data));(apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (partition 2 data)))))\\n         (println \\"fail\\"))))})" "(R->mean {\:x [1 2 3] \:y [4 5 6]})" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  {\:oper \:R->mean \:params \\r\\n   (if (>(count data) 1)\\r\\n     (apply R->vector data)\\n    (if (vector? data)\\r\\n       (first data)\\n       (if (apply map? data)\\n         (println (apply partition 2 data));(apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (partition 2 data)))))\\n         (println \\"fail\\"))))})" "(R->mean {\:x [1 2 3] \:y [4 5 6]})" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  {\:oper \:R->mean \:params \\r\\n   (if (>(count data) 1)\\r\\n     (apply R->vector data)\\n    (if (vector? data)\\r\\n       (first data)\\n       (if (apply map? data)\\n         (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n         (println \\"fail\\"))))})" "(R->mean {\:x [1 2 3] \:y [4 5 6]})" "(R-generate (R->mean {\:x [1 2 3] \:y [4 5 6]}))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  {\:oper \:R->mean \:params \\r\\n   [(if (>(count data) 1)\\r\\n     (apply R->vector data)\\n     (if (vector? data)\\r\\n       (first data)\\n        (if (apply map? data)\\n          (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n          (println \\"fail\\"))))]})" "(R-generate (R->mean {\:x [1 2 3] \:y [4 5 6]}))" "(R-generate (R->mean 1 2 3))" "(R-generate (R->mean (R->vector 1 2 3 4)))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  {\:oper \:R->mean \:params \\r\\n   [(if (and (map? data) (\:R-struct data))\\n      data\\n    (if (>(count data) 1)\\r\\n     (apply R->vector data)\\n     (if (vector? data)\\r\\n       (first data)\\n        (if (apply map? data)\\n          (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n          (println \\"fail\\")))))]})" "(R-generate (R->mean (R->vector 1 2 3 4)))" "(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-map true \:oper operation \:parms parms-vec})" "(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-map true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->def [var-name value]\\r\\n  (internal-R-struct \:R->def [var-name value]))" "(R->def car 43)" "(R->def \:car 43)" "(R-generate (R->def \:car 43))" "(R->def \:car 43)" "(defn R-generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep))))) \\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (if (map? entry)\\r\\n          (R-generate entry)\\r\\n          entry))))" "(R->def \:car 43)" "(R-generate (R->def \:car 43))" "(defn R-generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep))))) \\r\\n      (for [entry (\:params R-rep)]\\r\\n        (if (map? entry)\\r\\n          (R-generate entry)\\r\\n          entry))))\\r\\n\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-map true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->def [var-name value]\\r\\n  (internal-R-struct \:R->def [var-name value]))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  (internal-R-struct \:R->vector [(into [] values)]))\\r\\n\\r\\n(defn R->range [low-val high-val]\\r\\n  (internal-R-struct \:R->range  [low-val high-val]))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean \:params \\r\\n   [(if (>(count data) 1)\\r\\n     (apply R->vector data)\\r\\n     (first data))]))\\r\\n\\r\\n(defn R-slurp [path]\\r\\n     (internal-R-struct \:R-slurp \:params [path]))" "(R->vector 1 2 34)" "(R-generate (R->vector 1 2 34))" "\\r\\n(defn R-generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep))))) \\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (if (map? entry)\\r\\n          (R-generate entry)\\r\\n          entry))))\\r\\n\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-map true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->def [var-name value]\\r\\n  (internal-R-struct \:R->def [var-name value]))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  (internal-R-struct \:R->vector [(into [] values)]))\\r\\n\\r\\n(defn R->range [low-val high-val]\\r\\n  (internal-R-struct \:R->range  [low-val high-val]))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean \:params \\r\\n   [(if (>(count data) 1)\\r\\n     (apply R->vector data)\\r\\n     (first data))]))\\r\\n\\r\\n(defn R-slurp [path]\\r\\n     (internal-R-struct \:R-slurp \:params [path]))" "(R-generate (R->vector 1 2 34))" "(R-generate (R->mean (R->vector 1 2 34)))" "(R->vector 1 2 34)" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  {\:oper \:R->mean \:params \\r\\n   [(if (and (map? data) (\:R-struct data))\\n      data\\n    (if (>(count data) 1)\\r\\n     (apply R->vector data)\\n     (if (vector? data)\\r\\n       (first data)\\n        (if (apply map? data)\\n          (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n          (println \\"fail\\")))))]})" "(R-generate (R->mean (R->vector 1 2 34)))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n   [(if (and (map? data) (\:R-struct data))\\n      data\\n    (if (>(count data) 1)\\r\\n     (apply R->vector data)\\n     (if (vector? data)\\r\\n       (first data)\\n        (if (apply map? data)\\n          (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n          (println \\"fail\\")))))]))" "(R-generate (R->mean (R->vector 1 2 34)))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n   [(if (and (map? data) (\:R-struct data))\\n      data\\n    (if (>(count data) 1)\\r\\n     (apply R->vector data)\\n     (if (vector? data)\\r\\n       (first data)\\n        (if (apply map? data)\\n          (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n          (println \\"fail\\")))))]))" "(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})" "(R-generate (R->mean (R->vector 1 2 34)))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n   [(if (\:R-struct data)\\n      data\\n    (if (>(count data) 1)\\r\\n     (apply R->vector data)\\n     (if (vector? data)\\r\\n       (first data)\\n        (if (apply map? data)\\n          (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n          (println \\"fail\\")))))]))" "(\:test [{\:test 1}])" "(apply \:test [{\:test 1}])" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n   [\\n    (if (>(count data) 1)\\r\\n     (apply R->vector data)\\n     (if (vector? data)\\r\\n       (first data)\\n        (if (apply map? data)\\n          (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n          (println \\"fail\\")))))]))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [ (case \\n                         (> (count data) 1) (apply R->vector data)\\n                         (vector? data) (first data)\\r\\n                         (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                         (and (apply map? data) (apply \:R-struct data)) (first data)\\n                         \:defulat (println \\"fail\\"))]))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond \\n                        (> (count data) 1) (apply R->vector data)\\n                        (vector? data) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\n                        \:defulat (println \\"fail\\"))]))" "(R->mean 1 2 3)" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond \\n                        (> (count data) 1) (apply R->vector data)\\n                        (vector? data) (R->vector (first data))\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\n                        \:defulat (println \\"fail\\"))]))" "(R->mean 1 2 3)" "(R-generate (R->mean 1 2 3))" "(R-generate (R->mean (R->vector 1 2 3)))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond \\n                        (> (count data) 1) (apply R->vector data)\\n                        (vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        \:defulat (println \\"fail\\"))]))" "(R-generate (R->mean (R->vector 1 2 3)))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond \\n                        (> (count data) 1) (apply R->vector data)\\n                        (vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean {\:x 2}))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond \\n                        (> (count data) 1) (apply R->vector data)\\n                        (vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (into [] (apply partition 2 data)))))\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean {\:x 2}))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond \\n                        (> (count data) 1) (apply R->vector data)\\n                        (vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (into [] (apply partition 2 data)))))\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean {\:x 2}))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond \\n                        (> (count data) 1) (apply R->vector data)\\n                        (vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean {\:x 2}))" "(R-generate (R->mean {\:x 2 \:y 4}))" "(defn R->mean [& data]\\r\\n  \\"Takes R-vector or numbers\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\n                        (vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean {\:x 2 \:y 4}))" "(R-generate (R->mean {\:x 2 }))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\n                        (vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean [1 3 4 5]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\n                        (apply vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean [1 3 4 5]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\n                        (apply vector? data) (R->vector (ffirst data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean [1 3 4 5]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\n                        (apply vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean [1 3 4 5]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\n                        (apply vector? data) (R->vector  data)\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean [1 3 4 5]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\n                        (apply vector? data) (R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean [1 3 4 5]))" "(R-generate  (R->vector 3 4 5))" "(R-generate  (R->vector [3 4 5]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\n                        (apply vector? data) (apply R->vector (first data))\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (println \\"fail\\"))]))" "(R-generate (R->mean [1 3 4 5]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        \:default (throw \\"Mean failed\\"))]))" "(R->mean \\"4f\\")" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        \:default (throw (Exception. \\"Mean failed\\")))]))" "(R->mean \\"4f\\")" "\\r\\n(defn R-generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep))))) \\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (if (map? entry)\\r\\n          (R-generate entry)\\r\\n          entry))))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->def [var-name value]\\r\\n  (internal-R-struct \:R->def [var-name value]))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  (internal-R-struct \:R->vector [(into [] values)]))\\r\\n\\r\\n(defn R->range [low-val high-val]\\r\\n  (internal-R-struct \:R->range  [low-val high-val]))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))\\r\\n\\r\\n(defn R-slurp [path]\\r\\n  (internal-R-struct \:R-slurp \:params [path]))\\r\\n\\r\\n(defn internal-R->def [var-name value]\\r\\n  (str (name var-name) \\"<-\\" value))\\r\\n\\r\\n(defn internal-R->vector [values]\\r\\n  (str (reduce str \\"c[\\"  (interpose \\",\\" values)) \\"]\\"))\\r\\n\\r\\n(defn internal-R->range [low-val high-val]\\r\\n  (str \\"(\\" low-val \\"\:\\" high-val \\")\\"))\\r\\n\\r\\n(defn internal-R-slurp [path]\\r\\n  (str \\"read.table(\\\\\\"\\" path \\"\\\\\\")\\"))\\r\\n\\r\\n(defn internal-R->mean [val]\\r\\n  (str \\"mean(\\" val \\")\\"))" "(R->def \:car 4)" "(R-generate (R->def \:car 4))" "(R-generate (R->def \:car (R->vector 1 2 3 4 5)))" "(R-generate (R->def \:car (R->mean (R->vector 1 2 3 4 5))))" "(defn internal-R->mean [val]\\r\\n  (str \\"mean(\\" (cond                     \\r\\n                 (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                 (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                 (> (count data) 1) (apply R->vector data)\\r\\n                 \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))\\r\\n       \\")\\"))" "(defn internal-R->mean [data]\\r\\n  (str \\"mean(\\" (cond                     \\r\\n                 (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                 (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                 (> (count data) 1) (apply R->vector data)\\r\\n                 \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))\\r\\n       \\")\\"))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                        (> (count data) 1) (apply R->vector data)\\n                        (first data))]))" "(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                        (> (count data) 1) (apply R->vector data)\\n                        (first data))]))" "(defn R->vector [& values]\\r\\n  (internal-R-struct \:R->vector [(into [] values)]))" "(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                        (> (count data) 1) (apply R->vector data)\\n                        (first data))]))" "(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (first data))]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (first data))]))" "(defn internal-R->mean [data]\\r\\n  (str \\"mean(\\" (cond                     \\r\\n    (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n    (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n    \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))\\")\\"))" "(R->mean 1 2 4 )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                        (> (count data) 1) (apply R->vector data)\\n                        \:default (first data))]))" "(R->mean 1 2 4 )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                        \:default (first data))]))" "(R->mean 1 2 4 )" "(R->mean [1 2 4] )" "(defn R-generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep))))) \\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (if (map? entry)\\r\\n          (R-generate entry)\\r\\n          entry)))" "(defn R-generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep))))) \\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (if (map? entry)\\r\\n          (R-generate entry)\\r\\n          entry))))" "(R-generate (R->mean [1 2 4] ))" "(defn internal-R->mean [data]\\r\\n  (str \\"mean(\\" (cond                     \\r\\n    (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n    (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n    \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))\\")\\"))" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond  \\n                       (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                       \:default (first data))))" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\n                        \:default (first data))]))" "(defn internal-R->mean [data]\\r\\n  (str \\"mean(\\" (cond                     \\r\\n    (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n    (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n    \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))\\")\\"))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (vector? data) (apply R->vector  data)\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (vector? data) (R->vector  data)\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector  data)\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector  (first data))\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector  (ffirst data))\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (vector? data) (apply R->vector  data)\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector  (ffirst data))\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (vector? data) (apply R->vector  data)\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector  (first data))\\n                        \:default (first data))]))" "(R->mean [1 2 4] )" "(R->mean 1 2 4 )" "(R-generate (R->mean [1 2 4] ))" " (R->mean [1 2 4] )" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond  \\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (vector? data) (apply R->vector  data)\\n                        \:default (first data))]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" " (R->mean [1 2 4] )" "(defn internal-R->mean [data]\\r\\n  (str \\"mean(\\" (cond \\n                 (string? data) data \\r\\n                 (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                 (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                 \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))\\")\\"))" "(R-generate (R->mean [1 2 4] ))" "\\r\\n(defn R-generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep))))) \\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (if (map? entry)\\r\\n          (R-generate entry)\\r\\n          entry))))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->def [var-name value]\\r\\n  (internal-R-struct \:R->def [var-name value]))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  (internal-R-struct \:R->vector [(into [] values)]))\\r\\n\\r\\n(defn R->range [low-val high-val]\\r\\n  (internal-R-struct \:R->range  [low-val high-val]))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond                     \\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))\\r\\n\\r\\n(defn R-slurp [path]\\r\\n  (internal-R-struct \:R-slurp \:params [path]))\\r\\n\\r\\n(defn internal-R->def [var-name value]\\r\\n  (str (name var-name) \\"<-\\" value))\\r\\n\\r\\n(defn internal-R->vector [values]\\r\\n  (str (reduce str \\"c[\\"  (interpose \\",\\" values)) \\"]\\"))\\r\\n\\r\\n(defn internal-R->range [low-val high-val]\\r\\n  (str \\"(\\" low-val \\"\:\\" high-val \\")\\"))\\r\\n\\r\\n(defn internal-R-slurp [path]\\r\\n  (str \\"read.table(\\\\\\"\\" path \\"\\\\\\")\\"))\\r\\n\\r\\n(defn internal-R->mean [val]\\r\\n  (str \\"mean(\\" val \\")\\"))" "(R-generate (R->mean 1 1 1 ))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \\r\\n                        (apply map? data) (apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 data)))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R-generate (R->mean 1 1 1 ))" "(R-generate (R->mean [1 2 4]j))" "(R-generate (R->mean [1 2 4]))" "(R-generate (R->mean {\:x (R->vector 1 2 4 )}))" "(R-generate (R->mean {\:x (R->vector [1 2 4] )}))" "(R-generate (R->mean (R->vector [1 2 4] )))" "(R-generate (R->mean (R->vector 1 2 4 )))" "(R-generate (R->mean {\:x 1 \:y 2}))" " (R->mean {\:x 1 \:y 2})" "(defn internal-R-map-destruc [R-rep]" "(partition 2 {\:x 1 \:y 2})" "(map str (partition 2 {\:x 1 \:y 2})" "(map str (partition 2 {\:x 1 \:y 2}))" "(apply map str (partition 2 {\:x 1 \:y 2}))" "(apply map \#(%1 %2) (partition 2 {\:x 1 \:y 2}))" "(apply map (fn [one two] (str one two)) (partition 2 {\:x 1 \:y 2}))" "(partition 2 (flatten {\:x 1 \:y 2}))" "(partition 2  {\:x 1 \:y 2})" "(apply map str (partition 2 {\:x 1 \:y 2}))" "(apply map (fn [val] (str (first val) (second val) )) (partition 2 {\:x 1 \:y 2}))" "(apply map (fn [val] [(first val) (second val)] ) (partition 2 {\:x 1 \:y 2}))" "(into [] (apply map (fn [val] [(first val) (second val)] ) (partition 2 {\:x 1 \:y 2})))" "(apply str (->> [{\:x 1 \:y 3}] (apply into [] (apply partition 2)) (map (fn [val] (str (name (first val)) \\"\=\\" (second val)))) (interpose \\",\\")))" "(apply str (interpose \\",\\" (map (fn [val] (str (name (first val)) \\"\=\\" (second val))) (apply into [] (apply partition 2 [{\:x 1 \:y 3}])))))" "(apply str (->> [{\:x 1 \:y 3}] (apply partition 2) (apply into []) (map (fn [val] (str (name (first val)) \\"\=\\" (second val)))) (interpose \\",\\")))" "(apply str (->> [{\:x 1 \:y 3}] (apply partition 2)))" "(->> [{\:x 1 \:y 3}] (apply partition 2))" "(->> [{\:x 1 \:y 3}] (first) ( partition 2))" "(->> [{\:x 1 \:y 3 \:x 1 \:y 3}] (first) (partition 2))" "(->> [{\:x 1 \:y 3 \:x 1 \:y 3}]  (partition 2))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (partition 2))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 2))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 1))" "(->> {\:x 1 \:y 3 \:xz 1 \:ys 3}  (partition 1))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}] (first) (partition 1))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 1) (apply into []) (map (fn [val] (str (name (first val)) \\"\=\\" (second val)))) (interpose \\",\\"))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 1) (apply into []))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 1) (into []))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 1) (map (fn [val] (str (name (first val)) \\"\=\\" (second val)))) (interpose \\",\\"))" "(->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 1) (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" "(str (->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 1) (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\")))" "(apply str (->> [{\:x 1 \:y 3 \:xz 1 \:ys 3}]  (first) (partition 1) (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\")))" "(split-with keyword? {\:x 1 \:t 4 \:6})" "(split-with keyword? {\:x 1 \:t 4 \:h 6})" " (apply str (->> data  (first) seq (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\")))" " (->> data  (first) seq (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> {\:a 1 \:b 3}  (first) seq (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  (first) seq (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  first seq (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  first )" " (->> [{\:a 1 \:b 3}]  first seq )" " (->> [{\:a 1 \:b 3}] seq )" " (->> [{\:a 1 \:b 3}]  first seq )" " (->> [{\:a 1 \:b 3}]  first seq (map (fn [val] (str (name (apply first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  first seq (map (fn [val] (str (name (apply val)) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  first seq (map (fn [val] (str (name (first val)) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  first seq (map (fn [val] (str (name  val) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  (apply seq) (map (fn [val] (str (name  val) \\"\=\\" (apply second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  (apply seq) )" " (->> [{\:a 1 \:b 3}]  (apply seq) (map (fn [val] (str (name  val) \\"\=\\" (second val)) )) (interpose \\",\\"))" " (->> [{\:a 1 \:b 3}]  (apply seq) (map (fn [val] (str (name (first val)) \\"\=\\" (second val)))) (interpose \\",\\"))" "(str (->> [{\:a 1 \:b 3}]  (apply seq) (map (fn [val] (str (name (first val)) \\"\=\\" (second val)))) (interpose \\",\\")))" "(apply str (->> [{\:a 1 \:b 3}]  (apply seq) (map (fn [val] (str (name (first val)) \\"\=\\" (second val)))) (interpose \\",\\")))" " (defn R->\= [var-name value]\\r\\n  (internal-R-struct \:R->\= [var-name value]))\\n (defn internal-R->\= [var-name value]\\r\\n  (str (name var-name) \\"\=\\" value))\\n (->> [{\:a 1 \:b 3}]  (apply seq)  (interpose \\",\\"))" "\\n (->> [{\:a 1 \:b 3}]  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))" "\\n (->> {\:a 1 \:b 3}  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))" "\\n (->> [{\:a 1 \:b 3}]  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))" "\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)  (->> [{\:a 1 \:b 3}]  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)  (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)  (first (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\n                        _ (println (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        (apply map? data)   (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)  (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)  (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))))" "(R->mean 1 2 4 45)" "(R->mean [1 3 4])" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1) [(apply R->vector data)]\\r\\n                        (apply vector? data) [(apply R->vector (first data))]\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)   (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean 1 2 4 45)" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) [(apply R->vector (first data))]\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)   (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean 1 2 4 45)" "(R->mean [1 3 4])" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1) (apply R->vector data)\\r\\n                        (apply vector? data) (apply R->vector (first data))\\r\\n                        (and (apply map? data) (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)   (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))\\r\\n                        \:default (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean [1 3 4])" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(R-generate (R->mean {\:x [1 2 3 4] \:y [3 4 5]}))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1)      (apply R->vector data)\\r\\n                        (apply vector? data)    (apply R->vector (first data))\\r\\n                        (and (apply map? data)  (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)       (first (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn internal-R-assem-parms [R-rep]\\r\\n  \\"takes a clojure R representation and extracts parameters\\"\\r\\n  (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R-generate entry)\\r\\n          (seq? entry) (apply R-generate entry)\\r\\n          \:default entry)))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1)      (apply R->vector data)\\r\\n                        (apply vector? data)    (apply R->vector (first data))\\r\\n                        (and (apply map? data)  (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)       (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))\\r\\n                        \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn internal-R-assem-parms [R-rep]\\r\\n  \\"takes a clojure R representation and extracts parameters\\"\\r\\n  (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (do (println \\"map\\") (R-generate entry))\\r\\n          (seq? entry) (do (println \\"seq\\") (apply R-generate entry))\\r\\n          \:default entry)))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "\\r\\n(defn internal-R-assem-func [R-rep]\\r\\n  \\"takes a clojure R representation and creates associated function\\"\\r\\n  (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep))))))\\r\\n\\r\\n(defn internal-R-assem-parms [R-rep]\\r\\n  \\"takes a clojure R representation and extracts parameters\\"\\r\\n  (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R-generate entry)\\r\\n          (seq? entry) (apply R-generate entry)\\r\\n          \:default entry)))\\r\\n\\r\\n(defn R->generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (internal-R-assem-func R-rep)\\r\\n      (internal-R-assem-parms R-rep)))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn internal-R-assem-parms [R-rep]\\r\\n  \\"takes a clojure R representation and extracts parameters\\"\\r\\n  (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (do (println \\"map\\") (R-generate entry))\\r\\n          (seq? entry) (do (println \\"seq\\") (apply R-generate entry))\\r\\n          \:default entry)))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn internal-R-assem-parms [R-rep]\\r\\n  \\"takes a clojure R representation and extracts parameters\\"\\r\\n  (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (do (println \\"map\\") (R-generate entry))\\r\\n          (seq? entry) (do (println \\"seq\\") (apply R-generate entry))\\r\\n          \:default (do (print \\"nota\\") entry))))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn internal-R-assem-parms [R-rep]\\r\\n  \\"takes a clojure R representation and extracts parameters\\"\\r\\n  (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (do (println \\"map\\") (R-generate entry))\\r\\n          (seq? entry) (do (println \\"seq\\") (apply R-generate entry))\\r\\n          \:default (do (println \\"nota\\") entry))))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(R->mean (defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1)      (apply R->vector data)\\r\\n                        (apply vector? data)    (apply R->vector (first data))\\r\\n                        (and (apply map? data)  (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)       (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))\\r\\n{\:x [1 2 3 4] \:y [3 4 5]})" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1)      (apply R->vector data)\\r\\n                        (apply vector? data)    (apply R->vector (first data))\\r\\n                        (and (apply map? data)  (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)       (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                        (> (count data) 1)      (apply R->vector data)\\r\\n                        (apply vector? data)    (apply R->vector (first data))\\r\\n                        (and (apply map? data)  (apply \:R-struct data)) (first data)\\r\\n                        (apply map? data)       (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))))" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(R->mean [1 3 4])" "(R->mean 1 3 4)" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1)      [(apply R->vector data)]\\r\\n                        (apply vector? data)    [(apply R->vector (first data))]\\r\\n                        (apply map? data)       (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(R->mean 1 3 4)" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     [(cond          \\r\\n                        (> (count data) 1)      (apply R->vector data)\\r\\n                        (apply vector? data)    [(apply R->vector (first data))]\\r\\n                        (apply map? data)       (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))]))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                        (> (count data) 1)      [(apply R->vector data)]\\r\\n                        (apply vector? data)    [(apply R->vector (first data))]\\r\\n                        (apply map? data)       (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                        \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))))" "(R->mean 1 3 4)" "(R->mean [1 3 4])" "(R->mean {\:x [1 2 3 4] \:y [3 4 5]})" "(R-generate (R->mean {\:x [1 2 3 4] \:y [3 4 5]}))" "(defn internal-R->mean [& val]\\r\\n  (str \\"mean(\\" (apply str val) \\")\\"))" "(R-generate (R->mean {\:x [1 2 3 4] \:y [3 4 5]}))" "(defn internal-R->mean [& val]\\r\\n  (str \\"mean(\\" (interpose \\",\\" (apply str val)) \\")\\"))" "(R-generate (R->mean {\:x [1 2 3 4] \:y [3 4 5]}))" "(defn internal-R->mean [& data]\\n  (do (println (interpose \\",\\" data))\\r\\n  (str \\"mean(\\" data \\")\\")))" "(R-generate (R->mean {\:x [1 2 3 4] \:y [3 4 5]}))" "(defn internal-R->mean [& data]\\r\\n  (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))" "(R-generate (R->mean {\:x [1 2 3 4] \:y [3 4 5]}))" "(R-generate (R->mean 1 2 4 5 6))" "(R-generate (R->mean [1 2 4 5 6]))" "(R->def \:car 5)" "(ns RC.core)" "(R->def \:car 5)" "(R->generate (R->def \:car 5))" "(R->generate (R->def \:car (R->vector 1 2 3)))" "(R->generate (R->def \:car (R->mean (R->vector 1 2 3))))" "(R->generate (R->def \:car (R->mean 1 2 3)))" "(R->generate (R->def \:car (R->mean {\:x 1 \:y 4})))" "(R->generate (R->def \:car (R->mean {\:x (R->vector 1 2 3) \:y 4})))" "(R->generate (R->def \:car (R->mean 1 2 3)))" "(R->generate (R->def \:car (R->mean (R->vector 1 2 3))))" "(R->mean (R->vector 1 2 3))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                       (> (count data) 1)      [(apply R->vector data)]\\r\\n                       (apply vector? data)    [(apply R->vector (first data))]\\r\\n                       (and (apply map? data)  (apply \:R-struct data)) (first data)\\r\\n                       (apply map? data)       (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                       \:default                (throw (Exception. \\"Invalid element in function R->Mean.\\")))))" "(R->mean (R->vector 1 2 3))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                       (> (count data) 1)            [(apply R->vector data)]\\r\\n                       (apply vector? data)          [(apply R->vector (first data))]\\r\\n                       (and (apply map? data)\\r\\n                            (apply \:R-struct data))  [(first data)]\\r\\n                       (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                       \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))" "(R->mean (R->vector 1 2 3))" "(R->generate (R->def \:car (R->mean (R->vector 1 2 3))))" "(R-slurp \\"c/stuf\\")" "(R->range 4 354)" "(R->generate (R->range 4 354))" "(R->generate (R->def \:result (R->mean (R->vector (R->range 1 50)))))" " (R->def \:result (R->mean (R->vector (R->range 1 50))))" "(defn R->vector [& data]\\r\\n  (if (and (apply map? data)\\r\\n           (apply \:R-struct data))\\n    (first data)\\r\\n  (internal-R-struct \:R->vector [(into [] data)]))" "(defn R->vector [& data]\\r\\n  (if (and (apply map? data)\\r\\n           (apply \:R-struct data))\\n    (first data)\\r\\n  (internal-R-struct \:R->vector [(into [] data)])))" " (R->def \:result (R->mean (R->vector (R->range 1 50))))" "(R->generate (R->def \:result (R->mean (R->vector (R->range 1 50)))))" "(defn R->vector [& data]\\r\\n  (if (and (apply map? data)\\r\\n           (apply \:R-struct data))\\n    (internal-R-struct \:R->vector (first data))\\r\\n    (internal-R-struct \:R->vector [(into [] data)])))" "(R->generate (R->def \:result (R->mean (R->vector (R->range 1 50)))))" "(defn R->vector [& data]\\r\\n  (if (and (apply map? data)\\r\\n           (apply \:R-struct data))\\n    (internal-R-struct \:R->vector [(first data)])\\r\\n    (internal-R-struct \:R->vector [(into [] data)])))" "(R->generate (R->def \:result (R->mean (R->vector (R->range 1 50)))))" "(defn R->vector [& data]\\r\\n  (if (and (apply map? data)\\r\\n           (apply \:R-struct data))\\n    (internal-R-struct \:R->vector [(first data)])\\r\\n    (internal-R-struct \:R->vector [(into [] data)])))" "(ns RC.core)" "(R->def (R->range 12 1000))" "(R->def \:somenumbers (R->range 12 1000))" "(R->generate (R->def \:somenumbers (R->range 12 1000)))" "(R->generate (R->mean (R->vector 1 2 3)))" "(R->generate (R->mean ({\:x R->vector 1 2 3})))" "(R->generate (R->mean ({\:x (R->vector 1 2 3)})))" "(R->generate (R->mean {\:x (R->vector 1 2 3)}))" "(R->generate (R->mean {\:x (R->range 10 20)}))" "(R->generate (R->range 1 4))" "(R->generate (R->mean {\:x (R->range 10 20)}))" "(R->generate  \\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)}))" "(R->generate  \\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(R->generate  \\n  (do (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)}))))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (map (apply \\r\\n         (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n         (for [entry (\:parms R-rep)]\\r\\n           (cond \\r\\n             (map? entry) (R->generate entry)\\r\\n             (seq? entry) (apply R->generate entry) \\r\\n             \:default  entry))) R-rep ))" "(R->generate  \\n  (do (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)}))))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (map str\\n       R-rep ))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply map (apply \\r\\n         (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n         (for [entry (\:parms R-rep)]\\r\\n           (cond \\r\\n             (map? entry) (R->generate entry)\\r\\n             (seq? entry) (apply R->generate entry) \\r\\n             \:default  entry))) R-rep ))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n (map\\n   \#(do (resolve (symbol (str \\"internal-\\" (name (\:oper %)))))\\r\\n         (for [entry (\:parms %)]\\r\\n           (cond \\r\\n             (map? entry) (R->generate entry)\\r\\n             (seq? entry) (apply R->generate entry) \\r\\n             \:default  entry))) R-rep )" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n (map\\n   \#(do (resolve (symbol (str \\"internal-\\" (name (\:oper %)))))\\r\\n         (for [entry (\:parms %)]\\r\\n           (cond \\r\\n             (map? entry) (R->generate entry)\\r\\n             (seq? entry) (apply R->generate entry) \\r\\n             \:default  entry))) R-rep ))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n (map\\n   \#(apply (resolve (symbol (str \\"internal-\\" (name (\:oper %)))))\\r\\n         (for [entry (\:parms %)]\\r\\n           (cond \\r\\n             (map? entry) (R->generate entry)\\r\\n             (seq? entry) (apply R->generate entry) \\r\\n             \:default  entry))) R-rep ))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(seq\\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)}))" "(seq\\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "\\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)}))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(R->generate  \\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(R->generate  \\n  (R->def \:mymean (R->mean {\:x 1})))" " \\n  (R->def \:mymean (R->mean {\:x 1}))" "(R->generate  \\n  (R->def \:mymean (R->mean 1 2 3)))" "  \\n  (R->def \:mymean (R->mean 1 2 3))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "\\n  (R->def \:one (R->vector 1 2 3))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n (map\\n   \#(apply (resolve (symbol (str \\"internal-\\" (name (\:oper %)))))\\r\\n         (for [entry (\:parms %)]\\r\\n           (do (println entry)\\n             (cond \\r\\n             (map? entry) (R->generate entry)\\r\\n             (seq? entry) (apply R->generate entry) \\r\\n             \:default  entry))) R-rep )))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n (map\\n   \#(apply (resolve (symbol (str \\"internal-\\" (name (\:oper %)))))\\r\\n         (for [entry (\:parms %)]\\r\\n           (do (println entry)\\n             (cond \\r\\n             (map? entry) (R->generate entry)\\r\\n             (seq? entry) (apply R->generate entry) \\r\\n             \:default  entry)))) R-rep ))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate entry)\\r\\n          (seq? entry) (apply R->generate entry) \\r\\n          \:default  entry))))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate entry)\\r\\n          (seq? entry) (apply R->generate entry) \\r\\n          \:default  entry))))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n   (map \#(apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper %)))))\\r\\n      (for [entry (\:parms %)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate entry)\\r\\n          (seq? entry) (apply R->generate entry) \\r\\n          \:default  entry))) R-rep))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate entry)\\r\\n          (seq? entry) (apply R->generate entry) \\r\\n          \:default  entry))))" "(defn R->generate [& R-rep]\\n  (map R->generate-command R-rep))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(interpose \\"\\\\n\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])" "(str (interpose \\"\\\\n\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"]))" "(apply str (interpose \\"\\\\n\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"]))" "(defn R->generate [& R-rep]\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))" "(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\"\\\\n\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])))" "(defn R->generate [& R-rep]\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "\\r\\n;generations functions\\r\\n(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))\\r\\n\\r\\n(defn R->generate [& R-rep]\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))\\r\\n\\r\\n\\r\\n; R DSL\\r\\n(defn R->def [var-name value]\\r\\n  (internal-R-struct \:R->def [var-name value]))\\r\\n\\r\\n(defn R->\= [var-name value]\\r\\n  (internal-R-struct \:R->\= [var-name value]))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  \\r\\n  (internal-R-struct \:R->vector [(into [] values)]))\\r\\n\\r\\n(defn R->range [low-val high-val]\\r\\n  (internal-R-struct \:R->range  [low-val high-val]))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                       (> (count data) 1)            [(apply R->vector data)]\\r\\n                       (apply vector? data)          [(apply R->vector (first data))]\\r\\n                       (and (apply map? data)\\r\\n                            (apply \:R-struct data))  [(first data)]\\r\\n                       (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                       \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))\\r\\n\\r\\n(defn R->slurp [path]\\r\\n  (internal-R-struct \:R->slurp \:params [path]))\\r\\n\\r\\n(defn internal-R->def [var-name value]\\r\\n  (str (name var-name) \\"<-\\" value))\\r\\n\\r\\n(defn internal-R->\= [var-name value]\\r\\n  (str (name var-name) \\"\=\\" value))\\r\\n\\r\\n(defn internal-R->vector [values]\\r\\n  (str (reduce str \\"c[\\"  (interpose \\",\\" values)) \\"]\\"))\\r\\n\\r\\n(defn internal-R->range [low-val high-val]\\r\\n  (str \\"(\\" low-val \\"\:\\" high-val \\")\\"))\\r\\n\\r\\n(defn internal-R->slurp [path]\\r\\n  (str \\"read.table(\\\\\\"\\" path \\"\\\\\\")\\"))\\r\\n\\r\\n(defn internal-R->mean [& data]\\r\\n     (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))\\r\\n\\r\\n(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->mean {\:x (R->range 10 20)}))" "(R->generate  \\r\\n  (R->def \:stuff 1)\\r\\n  (R->mean {\:x (R->range 10 20)}))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 2(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])))0)}))" "(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [& data]\\r\\n  (println (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [data]\\r\\n  (println (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(interpose \\"\:\\" [1 2 4])" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data) \\";\\"))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "\\r\\n;generations functions\\r\\n(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))" "(R->generate (R->def \:car 3) (R->mean (R->vector 12 4334 43)))" "(defn internal-R->vector [values]\\r\\n  (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))" "(R->generate (R->def \:car 3) (R->mean (R->vector 12 4334 43)))" "(R->generate (R->def \:car 3) (R->mean {\:x (R->vector 12 4334 43)}))" "(defprotocol prot-R-command\\n  (create-data-struct [_ & data])\\n  (emit-exicute-code [_ & data]))" "(defprotocol prot-R-command\\n  (create-data-struct [_ & data])\\n  (emit-exicute-code [_ & data])\\n  (get-information [_]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_ & data]" "(defprotocol prot-R-command\\n  (create-data-struct [_ & data]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command))\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var-name value]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command)\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var-name value])))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var-name value]))))" "(defprotocol prot-R-command\\n  (create-data-struct [_]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var-name value]))))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))))" "(R->def \:one 1)" "(create-data-struct (R->def \:one 1))" "(defprotocol prot-R-command\\n  (create-data-struct [_])\\n  (emit-exicute-code [_]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_]\\n      (str (name var-name) \\"<-\\" value))))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_ var-nam value]\\n      (str (name var-name) \\"<-\\" value))))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_ & data]\\n      (str (name var-name) \\"<-\\" value))))" "(defprotocol prot-R-command\\n  (create-data-struct [_])\\n  (emit-exicute-code [_ & data]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_ & data]\\n      (str (name var-name) \\"<-\\" value))))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_]\\n      (str (name var) \\"<-\\" value))))" "(defprotocol prot-R-command\\n  (create-data-struct [_])\\n  (emit-exicute-code [_]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_]\\n      (str (name var) \\"<-\\" value))))" "(create-data-struct (R->def \:one 4))" "(emit-exicute-code (create-data-struct (R->def \:one 4)))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [operation (resolve(symbol (name (\:oper R-rep))))]\\r\\n    (apply \\r\\n\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry)))))" "(R->def \:one 4)" "(def rt (R->def \:one 4))" "(create-data-struct rt)" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n      r-struct (create-data-struct R-rep)\\n   \\r\\n    (apply \\n      (emit-exicute-code oper \\r\\n                         (for [entry (\:parms R-rep)]\\r\\n                           (cond \\r\\n                             (map? entry) (R->generate-command entry)\\r\\n                             (seq? entry) (apply R->generate-command entry) \\r\\n                             \:default  entry))))))" "(def rt (R->def \:one (R->def \:two 2)))" "rt" "(class rt)" "(class 1)" "(split (class rt))" "(split \\".\\" (class rt))" "(split  (class rt) \\".\\")" "(class rt)" "(with-in-str \\"RC\\" (class rt))" "(ns-name rt)" "(ns-map RT)" "(ns-map RC.core)" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply emit-exicute-code R-rep)\\r\\n      (for [entry (\:parms (create-data-struct  R-rep))]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry)))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms (create-data-struct  struct))]\\r\\n               (cond \\r\\n                 (map? entry) (R->generate-command entry)\\r\\n                 (seq? entry) (apply R->generate-command entry) \\r\\n                 \:default  entry))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms (create-data-struct  struct))]\\r\\n               (cond \\r\\n                 (map? entry) (R->generate-command entry)\\r\\n                 (seq? entry) (apply R->generate-command entry) \\r\\n                 \:default  entry))))))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_]\\n      (str (name var) \\"<-\\" value))))" "(R->generate-command (R->def \:one 4))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 (map? entry) (R->generate-command entry)\\r\\n                 (seq? entry) (apply R->generate-command entry) \\r\\n                 \:default  entry))))))" "(R->generate-command (R->def \:one 4))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\n  (reify \\n    prot-R-command\\r\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->mean\\r\\n                         (cond          \\r\\n                           (> (count data) 1)            [(apply R->vector data)]\\r\\n                           (apply vector? data)          [(apply R->vector (first data))]\\r\\n                           (and (apply map? data)\\r\\n                                (apply \:R-struct data))  [(first data)]\\r\\n                           (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                           \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))\\n    (emit-exicute-code [_]\\n      (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 (map? entry) (R->generate-command entry)\\r\\n                 (seq? entry) (apply R->generate-command entry) \\r\\n                 \:default  entry))))))" "(R->generate (R->mean 1 2 3))" "(defn R->vector [& values]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\n  (reify \\n    prot-R-command\\r\\n    (create-data-struct [_]\\n     (internal-R-struct \:R->vector [(into [] values)]))\\n    (emit-exicute-code [_]\\n      (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "(create-data-struct (R->mean 1 2 3))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 ;(map? entry) (R->generate-command entry)\\n                 \\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry))))))" "(class (R->mean 1 2 3))" " (R->mean 1 2 3))" " (R->mean 1 2 3)" "(fn? (R->mean 1 2 3))" "(fn (R->mean 1 2 3))" "(fn? (R->mean 1 2 3))" "(ifn? (R->mean 1 2 3))" "(apply ifn? (R->mean 1 2 3))" "(instance? reify (R->mean 1 2 3))" "(instance? (class reify) (R->mean 1 2 3))" "(class reify)" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 (apply map? entry) (R->generate-command entry)\\n                 \\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry))))))" "(create-data-struct (R->mean 1 2 3))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                (R->generate-command entry)\\n                 \\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry))))))" "(instance? RC (R->mean 1 2 3))" "(parents R->mean)" "(find-ns R->mean)" "(find-ns (R->mean 1 2))" "(R->mean 1 2)" "(apply print (R->mean 1 2))" "(print (R->mean 1 2))" "(apply map? (R->mean 1 2))" "(parents (R->mean 1 2))" "(class? (R->mean 1 2))" "(class? 1)" "(appy class (R->mean 1 2))" "(class (R->mean 1 2))" "(.contains (str (class (R->mean 1 2) \\"reify\\")" "(.contains (str (class (R->mean 1 2) \\"reify\\")))" "(.contains (str (class (R->mean 1 2))) \\"reify\\")" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 (.contains (str (class (R->mean 1 2))) \\"reify\\") (R->generate-command entry) ; bad way to check condition\\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry))))))" "(R->generate (R->mean 1 2 3))" "(defn R->vector [& values]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\n  (reify \\n    prot-R-command\\r\\n    (create-data-struct [_]\\n     (internal-R-struct \:R->vector [(into [] values)]))\\n    (emit-exicute-code [_]\\n      (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\n  (reify \\n    prot-R-command\\r\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->mean\\r\\n                         (cond          \\r\\n                           (> (count data) 1)            [(apply R->vector data)]\\r\\n                           (apply vector? data)          [(apply R->vector (first data))]\\r\\n                           (and (apply map? data)\\r\\n                                (apply \:R-struct data))  [(first data)]\\r\\n                           (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                           \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))\\n    (emit-exicute-code [_]\\n      (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\n               (do (println entry)\\r\\n               (cond \\r\\n                 (.contains (str (class (R->mean 1 2))) \\"reify\\") (R->generate-command entry) ; bad way to check condition\\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry)))))))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\n               (do (println entry)\\r\\n               (cond \\r\\n                 (.contains (str (class entry)) \\"reify\\") (R->generate-command entry) ; bad way to check condition\\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry)))))))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defprotocol prot-R-command\\r\\n     (create-data-struct [_])\\r\\n     (emit-exicute-code [_]))\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\r\\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (do (println entry)\\r\\n               (cond \\r\\n                 (.contains (str (class entry)) \\"reify\\") (R->generate-command entry) ; bad way to check condition\\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry)))))))\\r\\n\\r\\n(defn R->def [var value]\\r\\n     (reify\\r\\n       prot-R-command\\r\\n       (create-data-struct [_]\\r\\n         (internal-R-struct \:R->def [var value]))\\r\\n       (emit-exicute-code [_]\\r\\n         (str (name var) \\"<-\\" value))))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (reify \\r\\n    prot-R-command\\r\\n    (create-data-struct [_]\\r\\n     (internal-R-struct \:R->vector [(into [] values)]))\\r\\n    (emit-exicute-code [_]\\r\\n      (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (reify \\r\\n    prot-R-command\\r\\n    (create-data-struct [_]\\r\\n      (internal-R-struct \:R->mean\\r\\n                         (cond          \\r\\n                           (> (count data) 1)            [(apply R->vector data)]\\r\\n                           (apply vector? data)          [(apply R->vector (first data))]\\r\\n                           (and (apply map? data)\\r\\n                                (apply \:R-struct data))  [(first data)]\\r\\n                           (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                           \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))\\r\\n    (emit-exicute-code [_]\\r\\n      (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defprotocol prot-R-command\\r\\n     (create-data-struct [_])\\r\\n     (emit-exicute-code [_]))\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\r\\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 (.contains (str (class entry)) \\"reify\\") (R->generate-command entry) ; bad way to check condition\\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry))))))\\r\\n\\r\\n(defn R->def [var value]\\r\\n     (reify\\r\\n       prot-R-command\\r\\n       (create-data-struct [_]\\r\\n         (internal-R-struct \:R->def [var value]))\\r\\n       (emit-exicute-code [_]\\r\\n         (str (name var) \\"<-\\" value))))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (reify \\r\\n    prot-R-command\\r\\n    (create-data-struct [_]\\r\\n     (internal-R-struct \:R->vector [(into [] values)]))\\r\\n    (emit-exicute-code [_]\\r\\n      (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (reify \\r\\n    prot-R-command\\r\\n    (create-data-struct [_]\\r\\n      (internal-R-struct \:R->mean\\r\\n                         (cond          \\r\\n                           (> (count data) 1)            [(apply R->vector data)]\\r\\n                           (apply vector? data)          [(apply R->vector (first data))]\\r\\n                           (and (apply map? data)\\r\\n                                (apply \:R-struct data))  [(first data)]\\r\\n                           (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                           \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))\\r\\n    (emit-exicute-code [_]\\r\\n      (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "(defn R->summary [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                       (> (count data) 1)            [(apply R->vector data)]\\r\\n                       (apply vector? data)          [(apply R->vector (first data))]\\r\\n                       (and (apply map? data)\\r\\n                            (apply \:R-struct data))  [(first data)]\\r\\n                       (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                       \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))" "(defn internal-R->summary [& data]\\r\\n     (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))" "(R->generate (R->summary 1 2 3))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))\\r\\n\\r\\n(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))" "(R->generate (R->summary 1 2 3))" "(R->generate (R->mean 1 2 3))" "(ns RC.core)" "(R->generate (R->mean 1 2 3))" "(R->generate-command (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply str (internal-R-post-proc (map R->generate-command R-rep))))" "(R->generate-command (R->mean 1 2 3))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply str (internal-R-post-proc (map R->generate-command R-rep))))" "(R->generate (R->mean 1 2 3))" "(R->generate-command (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (println (internal-R-post-proc (map R->generate-command R-rep))))" "(R->generate-command (R->mean 1 2 3))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply println (internal-R-post-proc (map R->generate-command R-rep))))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (println (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (str (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply str (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (println (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (str (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply str (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply str (interpose \\";\\" (map R->generate-command R-rep))))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))\\r\\n\\r\\n(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "(defn R->summary [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->summary\\r\\n                     (cond          \\r\\n                       (> (count data) 1)            [(apply R->vector data)]\\r\\n                       (apply vector? data)          [(apply R->vector (first data))]\\r\\n                       (and (apply map? data)\\r\\n                            (apply \:R-struct data))  [(first data)]\\r\\n                       (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                       \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(defn internal-R->summary [& data]\\r\\n     (str \\"summary(\\" (apply str (interpose \\",\\" data)) \\")\\"))" "(R->generate (R->summary 1 2 3 4 ))" "(defn internal-R->summary [& data]\\r\\n     (str \\"summary(\\" (apply str (interpose \\",\\" data)) \\")\\"))" "(defn R->summary [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->summary\\r\\n                     (stnd-input-support data )))" "(defn stnd-input-support [data]\\r\\n  (cond          \\r\\n    (> (count data) 1)            [(apply R->vector data)]\\r\\n    (apply vector? data)          [(apply R->vector (first data))]\\r\\n    (and (apply map? data)\\r\\n         (apply \:R-struct data))  [(first data)]\\r\\n    (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n    \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\"))))" "(defn R->summary [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->summary\\r\\n                     (stnd-input-support data )))" "(R->generate (R->summary 1 2 3 4 ))" "\\r\\n;generations functions\\r\\n(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))\\r\\n\\r\\n(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))\\r\\n\\r\\n; R DSL\\r\\n(defn R->def [var-name value]\\r\\n  (internal-R-struct \:R->def [var-name value]))\\r\\n\\r\\n(defn R->\= [var-name value]\\r\\n  (internal-R-struct \:R->\= [var-name value]))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  (internal-R-struct \:R->vector [(into [] values)]))\\r\\n\\r\\n(defn R->range [low-val high-val]\\r\\n  (internal-R-struct \:R->range  [low-val high-val]))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean (stnd-input-support data )))\\r\\n\\r\\n(defn R->summary [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->summary (stnd-input-support data )))\\r\\n\\r\\n(defn R->slurp [path]\\r\\n  (internal-R-struct \:R->slurp \:params [path]))\\r\\n\\r\\n(defn internal-R->def [var-name value]\\r\\n  (str (name var-name) \\"<-\\" value))\\r\\n\\r\\n(defn internal-R->\= [var-name value]\\r\\n  (str (name var-name) \\"\=\\" value))\\r\\n\\r\\n(defn internal-R->vector [values]\\r\\n  (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))\\r\\n\\r\\n(defn internal-R->range [low-val high-val]\\r\\n  (str \\"(\\" low-val \\"\:\\" high-val \\")\\"))\\r\\n\\r\\n(defn internal-R->slurp [path]\\r\\n  (str \\"read.table(\\\\\\"\\" path \\"\\\\\\")\\"))\\r\\n\\r\\n(defn internal-R->mean [& data]\\r\\n     (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))\\r\\n\\r\\n(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn internal-R->summary [& data]\\r\\n     (str \\"summary(\\" (apply str (interpose \\",\\" data)) \\")\\"))\\r\\n\\r\\n(defn stnd-input-support [data]\\r\\n  (cond          \\r\\n    (> (count data) 1)            [(apply R->vector data)]\\r\\n    (apply vector? data)          [(apply R->vector (first data))]\\r\\n    (and (apply map? data)\\r\\n         (apply \:R-struct data))  [(first data)]\\r\\n    (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n    \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\"))))" "(R->generate (R->summary 1 2 3 4 5 56))" "(R->generate-command (R->summary 1 2 3 4 5 56))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (-> R-rep (map R->generate-command) internal-R-post-proc ))" "(R->generate-command (R->summary 1 2 3 4 5 56))" "(R->generate (R->summary 1 2 3 4 5 56))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (->> R-rep (map R->generate-command) internal-R-post-proc ))" "(R->generate (R->summary 1 2 3 4 5 56))" "(defn internal-R-post-proc [data]\\r\\n  (println (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3 4 5 56))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3 4 5 56))" "(R->generate (R->summary 1 2 3))" "(R->generate-command (R->summary 1 2 3))" "(R->generate-command (R->summary 1 2 3) (R->def \:car 23))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (print (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (apply print (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  [(interpose \\";\\" data)])" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (first (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (second (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (concat (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (apply concat (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  ( concat (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (str (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3 4))" "(R->generate (R->def \:stuf (R->summary 1 2 3 4))" "(R->generate (R->def \:stuf (R->summary 1 2 3 4)))" "(R->generate (R->def \:stuf (R->summary {\:x (R->vector 1 3 3 4 5)})))" "(macroexpand '(ns RC.RC-DSL\\r\\n  (\:require [[RC.RC-code-generation \:as gen]\\r\\n             [RC.RC-support \:as sup]])))" "(macroexpand '(ns RC.RC-code-generation))" "(macroexpand '(ns RC.core\\r\\n  (\:require [[DSL.primary-operations]\\r\\n             [DSL.composit-operations]])))" "(do (clojure.core/in-ns (quote RC.core)) (clojure.core/with-loading-context (clojure.core/refer (quote clojure.core)) (clojure.core/require (quote [[DSL.primary-operations] [DSL.composit-operations]]))) (if (.equals (quote RC.core) (quote clojure.core)) nil (do (clojure.core/dosync (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote RC.core))) nil)))" "(ns RC.core\\r\\n  (\:require [DSL.primary-operations composit-operations]))" "(ns RC.core\\r\\n  (\:require [DSL.primary-operations]))" "(ns RC.core\\r\\n  (\:require [DSL.composit-operations]))" "(ns RC.core\\r\\n  (\:require [DSL [primary-operations composit-operations]]))" "(macroexpand '(ns RC.core\\r\\n  (\:require 'DSL.primary-operations\\r\\n             'DSL.composit-operations)))" "(ns RC.core\\r\\n  (\:require 'DSL.primary-operations\\r\\n             'DSL.composit-operations))" "(ns RC.core\\r\\n  (\:require ['DSL.primary-operations\\r\\n             'DSL.composit-operations]\\n            ))" "(ns RC.core\\r\\n  (\:require [DSL.primary-operations\\r\\n             DSL.composit-operations]\\n            ))" "(ns RC.core\\r\\n  (\:require [[DSL.primary-operations \:as one]\\r\\n             [DSL.composit-operations \:as two]]))" "(ns primary)" "(ns RC.core)" "(ns-name)" "(ns DSL.composit-operations)" "(gen/R->generate(R->def \:cor 4))" "(R->def \:cor 4)" "(gen/R->generate-command\\n  (R->def \:cor 4))" "(defn gen-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn gen-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"gen-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))" "(R->generate-command\\n  (R->def \:cor 4))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"codeGeneration.gen-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))" "(R->generate-command\\n  (R->def \:cor 4))" "(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve 'codeGeneration (symbol (str \\"gen-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))" "(R->generate-command\\n  (R->def \:cor 4))" "(ns-rs codeGeneration (symbol (str \\"gen-\\" (name (\:oper R-rep)))))" "(ns-resolve codeGeneration (symbol (str \\"gen-\\" (name (\:oper R-rep)))))" "(ns-resolve 'codeGeneration (symbol (str \\"gen-\\" (name (\:oper R-rep)))))" "(gen/R->generate-command (R->def \:oen 3))" " (R->def \:oen 3)" "(gen/R->generate-command primary_operations.clj)" "(gen/R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(ns user)" "ns" "*ns*" "(R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(codeGeneration/R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(codeGeneration.R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(codeGeneration.RC-code-generation/R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(ns DSL.primary-operations)" "(R->def \:one 3)" "(gen/R->generate-command (R->def \:one 3))" "(resolve (symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" )))" "(resolve (symbol (str \\"codeGeneration.RC-code-generationdsdfs/R->generate-command/gen-R->summary \\" )))" "((resolve (symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" ))) [1 2 3])" "((symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" ))[1 2 3])" "((symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" )) 55 5 [1 2 3])" "((symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" ))[1 2 3])" "(symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" ))" "(codeGeneration.RC-code-generation/R->generate-command/gen-R->summary [1 2 3])" "(codeGeneration.RC-code-generation/gen-R->summary [1 2 3])" "((resolve (symbol (str \\"codeGeneration.RC-code-generation/gen-R->summary \\" ))) [1 2 3])" "((resolve (symbol (str \\"codeGeneration.RC-code-generation/gen-R->summary\\" ))) [1 2 3])" "(R->def \:one 2)" "(gen/R->generate-command (R->def \:one 2))" "(ns DSL.primary-operations\\r\\n  (\:require [codeGeneration.RC-code-generation \:as gen]))" "(R-def \:one 21)" "(R->def \:one 21)" "(R->def \:one 1)" "(gen/R->generate-command (R->def \:one 1))" "(seq 1 1)" "(defn tests [& data]\\n  (class data))" "(tests 1 2 3)" "(seq? (tests 1 2 3))" "(seq? (tests {\:q 1}))" "(tests {\:q 1})" "(defmacro stnd-input-support [^clojure.lang.ArraySeq data]\\r\\n  (cond          \\r\\n    (> (count data) 1)            [(apply dsl/R->vector data)]\\r\\n    (apply vector? data)          [(apply dsl/R->vector (first data))]\\r\\n    (and (apply map? data)\\r\\n         (apply \:R-struct data))  [(first data)]\\r\\n    (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n    \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\"))))" "(R->mean 1 1 1)" "(gen/R->generate-command (R->mean 1 1 1))" "(R->generate-command (R->def \:one 1))" "(R->generate-command (R->def \:themean(R->mean {\:x (R->vector 1 2 43 45) \:y (R->vector 543 65 87)})))" "(R->\= \\"one\\" \\"tw\\")" "(R->generate-command (R->def \:themean(R->mean {\:x (R->vector 1 2 43 45) \:y (R->vector 543 65 87)})))"]
eclipse.preferences.version=1
