cmdhistory=["(R->generate  \\n  (R->def \:mymean (R->mean 1 2 3)))" "  \\n  (R->def \:mymean (R->mean 1 2 3))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "\\n  (R->def \:one (R->vector 1 2 3))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n (map\\n   \#(apply (resolve (symbol (str \\"internal-\\" (name (\:oper %)))))\\r\\n         (for [entry (\:parms %)]\\r\\n           (do (println entry)\\n             (cond \\r\\n             (map? entry) (R->generate entry)\\r\\n             (seq? entry) (apply R->generate entry) \\r\\n             \:default  entry))) R-rep )))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n (map\\n   \#(apply (resolve (symbol (str \\"internal-\\" (name (\:oper %)))))\\r\\n         (for [entry (\:parms %)]\\r\\n           (do (println entry)\\n             (cond \\r\\n             (map? entry) (R->generate entry)\\r\\n             (seq? entry) (apply R->generate entry) \\r\\n             \:default  entry)))) R-rep ))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate entry)\\r\\n          (seq? entry) (apply R->generate entry) \\r\\n          \:default  entry))))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate entry)\\r\\n          (seq? entry) (apply R->generate entry) \\r\\n          \:default  entry))))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate [& R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n   (map \#(apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper %)))))\\r\\n      (for [entry (\:parms %)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate entry)\\r\\n          (seq? entry) (apply R->generate entry) \\r\\n          \:default  entry))) R-rep))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate entry)\\r\\n          (seq? entry) (apply R->generate entry) \\r\\n          \:default  entry))))" "(defn R->generate [& R-rep]\\n  (map R->generate-command R-rep))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))" "(R->generate \\n  (R->def \:one (R->vector 1 2 3)))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(interpose \\"\\\\n\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])" "(str (interpose \\"\\\\n\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"]))" "(apply str (interpose \\"\\\\n\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"]))" "(defn R->generate [& R-rep]\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))" "(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\"\\\\n\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])))" "(defn R->generate [& R-rep]\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "\\r\\n;generations functions\\r\\n(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))\\r\\n\\r\\n(defn R->generate [& R-rep]\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))\\r\\n\\r\\n\\r\\n; R DSL\\r\\n(defn R->def [var-name value]\\r\\n  (internal-R-struct \:R->def [var-name value]))\\r\\n\\r\\n(defn R->\= [var-name value]\\r\\n  (internal-R-struct \:R->\= [var-name value]))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  \\r\\n  (internal-R-struct \:R->vector [(into [] values)]))\\r\\n\\r\\n(defn R->range [low-val high-val]\\r\\n  (internal-R-struct \:R->range  [low-val high-val]))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                       (> (count data) 1)            [(apply R->vector data)]\\r\\n                       (apply vector? data)          [(apply R->vector (first data))]\\r\\n                       (and (apply map? data)\\r\\n                            (apply \:R-struct data))  [(first data)]\\r\\n                       (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                       \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))\\r\\n\\r\\n(defn R->slurp [path]\\r\\n  (internal-R-struct \:R->slurp \:params [path]))\\r\\n\\r\\n(defn internal-R->def [var-name value]\\r\\n  (str (name var-name) \\"<-\\" value))\\r\\n\\r\\n(defn internal-R->\= [var-name value]\\r\\n  (str (name var-name) \\"\=\\" value))\\r\\n\\r\\n(defn internal-R->vector [values]\\r\\n  (str (reduce str \\"c[\\"  (interpose \\",\\" values)) \\"]\\"))\\r\\n\\r\\n(defn internal-R->range [low-val high-val]\\r\\n  (str \\"(\\" low-val \\"\:\\" high-val \\")\\"))\\r\\n\\r\\n(defn internal-R->slurp [path]\\r\\n  (str \\"read.table(\\\\\\"\\" path \\"\\\\\\")\\"))\\r\\n\\r\\n(defn internal-R->mean [& data]\\r\\n     (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))\\r\\n\\r\\n(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->def \:mymean (R->mean {\:x (R->range 10 20)})))" "(R->generate  \\n  (R->def \:stuff 1)\\n  (R->mean {\:x (R->range 10 20)}))" "(R->generate  \\r\\n  (R->def \:stuff 1)\\r\\n  (R->mean {\:x (R->range 10 20)}))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 2(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])))0)}))" "(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" [\\"stuff<-1\\" \\"mymean<-mean(x\=(10\:20))\\"])))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [& data]\\r\\n  (println (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [data]\\r\\n  (println (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(interpose \\"\:\\" [1 2 4])" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data) \\";\\"))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate  \\r\\n  (R->mean {\:x (R->range 10 20)}))" "\\r\\n;generations functions\\r\\n(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))" "(R->generate (R->def \:car 3) (R->mean (R->vector 12 4334 43)))" "(defn internal-R->vector [values]\\r\\n  (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))" "(R->generate (R->def \:car 3) (R->mean (R->vector 12 4334 43)))" "(R->generate (R->def \:car 3) (R->mean {\:x (R->vector 12 4334 43)}))" "(defprotocol prot-R-command\\n  (create-data-struct [_ & data])\\n  (emit-exicute-code [_ & data]))" "(defprotocol prot-R-command\\n  (create-data-struct [_ & data])\\n  (emit-exicute-code [_ & data])\\n  (get-information [_]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_ & data]" "(defprotocol prot-R-command\\n  (create-data-struct [_ & data]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command))\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var-name value]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command)\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var-name value])))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var-name value]))))" "(defprotocol prot-R-command\\n  (create-data-struct [_]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var-name value]))))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))))" "(R->def \:one 1)" "(create-data-struct (R->def \:one 1))" "(defprotocol prot-R-command\\n  (create-data-struct [_])\\n  (emit-exicute-code [_]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_]\\n      (str (name var-name) \\"<-\\" value))))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_ var-nam value]\\n      (str (name var-name) \\"<-\\" value))))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_ & data]\\n      (str (name var-name) \\"<-\\" value))))" "(defprotocol prot-R-command\\n  (create-data-struct [_])\\n  (emit-exicute-code [_ & data]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_ & data]\\n      (str (name var-name) \\"<-\\" value))))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_]\\n      (str (name var) \\"<-\\" value))))" "(defprotocol prot-R-command\\n  (create-data-struct [_])\\n  (emit-exicute-code [_]))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_]\\n      (str (name var) \\"<-\\" value))))" "(create-data-struct (R->def \:one 4))" "(emit-exicute-code (create-data-struct (R->def \:one 4)))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [operation (resolve(symbol (name (\:oper R-rep))))]\\r\\n    (apply \\r\\n\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry)))))" "(R->def \:one 4)" "(def rt (R->def \:one 4))" "(create-data-struct rt)" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n      r-struct (create-data-struct R-rep)\\n   \\r\\n    (apply \\n      (emit-exicute-code oper \\r\\n                         (for [entry (\:parms R-rep)]\\r\\n                           (cond \\r\\n                             (map? entry) (R->generate-command entry)\\r\\n                             (seq? entry) (apply R->generate-command entry) \\r\\n                             \:default  entry))))))" "(def rt (R->def \:one (R->def \:two 2)))" "rt" "(class rt)" "(class 1)" "(split (class rt))" "(split \\".\\" (class rt))" "(split  (class rt) \\".\\")" "(class rt)" "(with-in-str \\"RC\\" (class rt))" "(ns-name rt)" "(ns-map RT)" "(ns-map RC.core)" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply emit-exicute-code R-rep)\\r\\n      (for [entry (\:parms (create-data-struct  R-rep))]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry)))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms (create-data-struct  struct))]\\r\\n               (cond \\r\\n                 (map? entry) (R->generate-command entry)\\r\\n                 (seq? entry) (apply R->generate-command entry) \\r\\n                 \:default  entry))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms (create-data-struct  struct))]\\r\\n               (cond \\r\\n                 (map? entry) (R->generate-command entry)\\r\\n                 (seq? entry) (apply R->generate-command entry) \\r\\n                 \:default  entry))))))" "(defn R->def [var value]\\n  (reify\\n    prot-R-command\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->def [var value]))\\n    (emit-exicute-code [_]\\n      (str (name var) \\"<-\\" value))))" "(R->generate-command (R->def \:one 4))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 (map? entry) (R->generate-command entry)\\r\\n                 (seq? entry) (apply R->generate-command entry) \\r\\n                 \:default  entry))))))" "(R->generate-command (R->def \:one 4))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\n  (reify \\n    prot-R-command\\r\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->mean\\r\\n                         (cond          \\r\\n                           (> (count data) 1)            [(apply R->vector data)]\\r\\n                           (apply vector? data)          [(apply R->vector (first data))]\\r\\n                           (and (apply map? data)\\r\\n                                (apply \:R-struct data))  [(first data)]\\r\\n                           (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                           \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))\\n    (emit-exicute-code [_]\\n      (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 (map? entry) (R->generate-command entry)\\r\\n                 (seq? entry) (apply R->generate-command entry) \\r\\n                 \:default  entry))))))" "(R->generate (R->mean 1 2 3))" "(defn R->vector [& values]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\n  (reify \\n    prot-R-command\\r\\n    (create-data-struct [_]\\n     (internal-R-struct \:R->vector [(into [] values)]))\\n    (emit-exicute-code [_]\\n      (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "(create-data-struct (R->mean 1 2 3))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 ;(map? entry) (R->generate-command entry)\\n                 \\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry))))))" "(class (R->mean 1 2 3))" " (R->mean 1 2 3))" " (R->mean 1 2 3)" "(fn? (R->mean 1 2 3))" "(fn (R->mean 1 2 3))" "(fn? (R->mean 1 2 3))" "(ifn? (R->mean 1 2 3))" "(apply ifn? (R->mean 1 2 3))" "(instance? reify (R->mean 1 2 3))" "(instance? (class reify) (R->mean 1 2 3))" "(class reify)" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 (apply map? entry) (R->generate-command entry)\\n                 \\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry))))))" "(create-data-struct (R->mean 1 2 3))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                (R->generate-command entry)\\n                 \\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry))))))" "(instance? RC (R->mean 1 2 3))" "(parents R->mean)" "(find-ns R->mean)" "(find-ns (R->mean 1 2))" "(R->mean 1 2)" "(apply print (R->mean 1 2))" "(print (R->mean 1 2))" "(apply map? (R->mean 1 2))" "(parents (R->mean 1 2))" "(class? (R->mean 1 2))" "(class? 1)" "(appy class (R->mean 1 2))" "(class (R->mean 1 2))" "(.contains (str (class (R->mean 1 2) \\"reify\\")" "(.contains (str (class (R->mean 1 2) \\"reify\\")))" "(.contains (str (class (R->mean 1 2))) \\"reify\\")" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 (.contains (str (class (R->mean 1 2))) \\"reify\\") (R->generate-command entry) ; bad way to check condition\\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry))))))" "(R->generate (R->mean 1 2 3))" "(defn R->vector [& values]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\n  (reify \\n    prot-R-command\\r\\n    (create-data-struct [_]\\n     (internal-R-struct \:R->vector [(into [] values)]))\\n    (emit-exicute-code [_]\\n      (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\n  (reify \\n    prot-R-command\\r\\n    (create-data-struct [_]\\n      (internal-R-struct \:R->mean\\r\\n                         (cond          \\r\\n                           (> (count data) 1)            [(apply R->vector data)]\\r\\n                           (apply vector? data)          [(apply R->vector (first data))]\\r\\n                           (and (apply map? data)\\r\\n                                (apply \:R-struct data))  [(first data)]\\r\\n                           (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                           \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))\\n    (emit-exicute-code [_]\\n      (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\n               (do (println entry)\\r\\n               (cond \\r\\n                 (.contains (str (class (R->mean 1 2))) \\"reify\\") (R->generate-command entry) ; bad way to check condition\\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry)))))))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\n               (do (println entry)\\r\\n               (cond \\r\\n                 (.contains (str (class entry)) \\"reify\\") (R->generate-command entry) ; bad way to check condition\\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry)))))))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defprotocol prot-R-command\\r\\n     (create-data-struct [_])\\r\\n     (emit-exicute-code [_]))\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\r\\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (do (println entry)\\r\\n               (cond \\r\\n                 (.contains (str (class entry)) \\"reify\\") (R->generate-command entry) ; bad way to check condition\\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry)))))))\\r\\n\\r\\n(defn R->def [var value]\\r\\n     (reify\\r\\n       prot-R-command\\r\\n       (create-data-struct [_]\\r\\n         (internal-R-struct \:R->def [var value]))\\r\\n       (emit-exicute-code [_]\\r\\n         (str (name var) \\"<-\\" value))))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (reify \\r\\n    prot-R-command\\r\\n    (create-data-struct [_]\\r\\n     (internal-R-struct \:R->vector [(into [] values)]))\\r\\n    (emit-exicute-code [_]\\r\\n      (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (reify \\r\\n    prot-R-command\\r\\n    (create-data-struct [_]\\r\\n      (internal-R-struct \:R->mean\\r\\n                         (cond          \\r\\n                           (> (count data) 1)            [(apply R->vector data)]\\r\\n                           (apply vector? data)          [(apply R->vector (first data))]\\r\\n                           (and (apply map? data)\\r\\n                                (apply \:R-struct data))  [(first data)]\\r\\n                           (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                           \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))\\r\\n    (emit-exicute-code [_]\\r\\n      (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "\\r\\n(defprotocol prot-R-command\\r\\n     (create-data-struct [_])\\r\\n     (emit-exicute-code [_]))\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (let [struct (create-data-struct R-rep)]\\r\\n    (emit-exicute-code \\r\\n      (apply (resolve (symbol (name (\:oper struct))))\\r\\n             (for [entry (\:parms struct)]\\r\\n               (cond \\r\\n                 (.contains (str (class entry)) \\"reify\\") (R->generate-command entry) ; bad way to check condition\\r\\n                 (seq? entry) (apply R->generate-command entry) ;ignore unintitional seq wraps\\r\\n                 \:default  entry))))))\\r\\n\\r\\n(defn R->def [var value]\\r\\n     (reify\\r\\n       prot-R-command\\r\\n       (create-data-struct [_]\\r\\n         (internal-R-struct \:R->def [var value]))\\r\\n       (emit-exicute-code [_]\\r\\n         (str (name var) \\"<-\\" value))))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (reify \\r\\n    prot-R-command\\r\\n    (create-data-struct [_]\\r\\n     (internal-R-struct \:R->vector [(into [] values)]))\\r\\n    (emit-exicute-code [_]\\r\\n      (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (reify \\r\\n    prot-R-command\\r\\n    (create-data-struct [_]\\r\\n      (internal-R-struct \:R->mean\\r\\n                         (cond          \\r\\n                           (> (count data) 1)            [(apply R->vector data)]\\r\\n                           (apply vector? data)          [(apply R->vector (first data))]\\r\\n                           (and (apply map? data)\\r\\n                                (apply \:R-struct data))  [(first data)]\\r\\n                           (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                           \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))\\r\\n    (emit-exicute-code [_]\\r\\n      (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))))" "(R->generate (R->mean 1 2 3))" "(defn R->summary [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean\\r\\n                     (cond          \\r\\n                       (> (count data) 1)            [(apply R->vector data)]\\r\\n                       (apply vector? data)          [(apply R->vector (first data))]\\r\\n                       (and (apply map? data)\\r\\n                            (apply \:R-struct data))  [(first data)]\\r\\n                       (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                       \:default                      (throw (Exception. \\"Invalid element in function R->Mean.\\")))))" "(defn internal-R->summary [& data]\\r\\n     (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))" "(R->generate (R->summary 1 2 3))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))\\r\\n\\r\\n(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))" "(R->generate (R->summary 1 2 3))" "(R->generate (R->mean 1 2 3))" "(ns RC.core)" "(R->generate (R->mean 1 2 3))" "(R->generate-command (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply str (internal-R-post-proc (map R->generate-command R-rep))))" "(R->generate-command (R->mean 1 2 3))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply str (internal-R-post-proc (map R->generate-command R-rep))))" "(R->generate (R->mean 1 2 3))" "(R->generate-command (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (println (internal-R-post-proc (map R->generate-command R-rep))))" "(R->generate-command (R->mean 1 2 3))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply println (internal-R-post-proc (map R->generate-command R-rep))))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (println (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (str (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply str (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (println (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (str (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply str (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply str (interpose \\";\\" (map R->generate-command R-rep))))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))\\r\\n\\r\\n(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate (R->mean 1 2 3) (R->def \:car 2))" "(defn R->summary [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->summary\\r\\n                     (cond          \\r\\n                       (> (count data) 1)            [(apply R->vector data)]\\r\\n                       (apply vector? data)          [(apply R->vector (first data))]\\r\\n                       (and (apply map? data)\\r\\n                            (apply \:R-struct data))  [(first data)]\\r\\n                       (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n                       \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(defn internal-R->summary [& data]\\r\\n     (str \\"summary(\\" (apply str (interpose \\",\\" data)) \\")\\"))" "(R->generate (R->summary 1 2 3 4 ))" "(defn internal-R->summary [& data]\\r\\n     (str \\"summary(\\" (apply str (interpose \\",\\" data)) \\")\\"))" "(defn R->summary [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->summary\\r\\n                     (stnd-input-support data )))" "(defn stnd-input-support [data]\\r\\n  (cond          \\r\\n    (> (count data) 1)            [(apply R->vector data)]\\r\\n    (apply vector? data)          [(apply R->vector (first data))]\\r\\n    (and (apply map? data)\\r\\n         (apply \:R-struct data))  [(first data)]\\r\\n    (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n    \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\"))))" "(defn R->summary [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->summary\\r\\n                     (stnd-input-support data )))" "(R->generate (R->summary 1 2 3 4 ))" "\\r\\n;generations functions\\r\\n(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn internal-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"internal-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))\\r\\n\\r\\n(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (internal-R-post-proc (map R->generate-command R-rep)))\\r\\n\\r\\n; R DSL\\r\\n(defn R->def [var-name value]\\r\\n  (internal-R-struct \:R->def [var-name value]))\\r\\n\\r\\n(defn R->\= [var-name value]\\r\\n  (internal-R-struct \:R->\= [var-name value]))\\r\\n\\r\\n(defn R->vector [& values]\\r\\n  (internal-R-struct \:R->vector [(into [] values)]))\\r\\n\\r\\n(defn R->range [low-val high-val]\\r\\n  (internal-R-struct \:R->range  [low-val high-val]))\\r\\n\\r\\n(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->mean (stnd-input-support data )))\\r\\n\\r\\n(defn R->summary [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (internal-R-struct \:R->summary (stnd-input-support data )))\\r\\n\\r\\n(defn R->slurp [path]\\r\\n  (internal-R-struct \:R->slurp \:params [path]))\\r\\n\\r\\n(defn internal-R->def [var-name value]\\r\\n  (str (name var-name) \\"<-\\" value))\\r\\n\\r\\n(defn internal-R->\= [var-name value]\\r\\n  (str (name var-name) \\"\=\\" value))\\r\\n\\r\\n(defn internal-R->vector [values]\\r\\n  (str (reduce str \\"c(\\"  (interpose \\",\\" values)) \\")\\"))\\r\\n\\r\\n(defn internal-R->range [low-val high-val]\\r\\n  (str \\"(\\" low-val \\"\:\\" high-val \\")\\"))\\r\\n\\r\\n(defn internal-R->slurp [path]\\r\\n  (str \\"read.table(\\\\\\"\\" path \\"\\\\\\")\\"))\\r\\n\\r\\n(defn internal-R->mean [& data]\\r\\n     (str \\"mean(\\" (apply str (interpose \\",\\" data)) \\")\\"))\\r\\n\\r\\n(defn internal-R-post-proc [& data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn internal-R->summary [& data]\\r\\n     (str \\"summary(\\" (apply str (interpose \\",\\" data)) \\")\\"))\\r\\n\\r\\n(defn stnd-input-support [data]\\r\\n  (cond          \\r\\n    (> (count data) 1)            [(apply R->vector data)]\\r\\n    (apply vector? data)          [(apply R->vector (first data))]\\r\\n    (and (apply map? data)\\r\\n         (apply \:R-struct data))  [(first data)]\\r\\n    (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n    \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\"))))" "(R->generate (R->summary 1 2 3 4 5 56))" "(R->generate-command (R->summary 1 2 3 4 5 56))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (-> R-rep (map R->generate-command) internal-R-post-proc ))" "(R->generate-command (R->summary 1 2 3 4 5 56))" "(R->generate (R->summary 1 2 3 4 5 56))" "(defn R->generate [& R-rep]\\r\\n   \\"Mapping of clojure R representation to R language\\"\\r\\n  (->> R-rep (map R->generate-command) internal-R-post-proc ))" "(R->generate (R->summary 1 2 3 4 5 56))" "(defn internal-R-post-proc [data]\\r\\n  (println (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3 4 5 56))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3 4 5 56))" "(R->generate (R->summary 1 2 3))" "(R->generate-command (R->summary 1 2 3))" "(R->generate-command (R->summary 1 2 3) (R->def \:car 23))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (print (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (apply print (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  [(interpose \\";\\" data)])" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (first (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (second (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (concat (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (apply concat (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  ( concat (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (str (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3) (R->def \:car 23))" "(defn internal-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))" "(R->generate (R->summary 1 2 3 4))" "(R->generate (R->def \:stuf (R->summary 1 2 3 4))" "(R->generate (R->def \:stuf (R->summary 1 2 3 4)))" "(R->generate (R->def \:stuf (R->summary {\:x (R->vector 1 3 3 4 5)})))" "(macroexpand '(ns RC.RC-DSL\\r\\n  (\:require [[RC.RC-code-generation \:as gen]\\r\\n             [RC.RC-support \:as sup]])))" "(macroexpand '(ns RC.RC-code-generation))" "(macroexpand '(ns RC.core\\r\\n  (\:require [[DSL.primary-operations]\\r\\n             [DSL.composit-operations]])))" "(do (clojure.core/in-ns (quote RC.core)) (clojure.core/with-loading-context (clojure.core/refer (quote clojure.core)) (clojure.core/require (quote [[DSL.primary-operations] [DSL.composit-operations]]))) (if (.equals (quote RC.core) (quote clojure.core)) nil (do (clojure.core/dosync (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote RC.core))) nil)))" "(ns RC.core\\r\\n  (\:require [DSL.primary-operations composit-operations]))" "(ns RC.core\\r\\n  (\:require [DSL.primary-operations]))" "(ns RC.core\\r\\n  (\:require [DSL.composit-operations]))" "(ns RC.core\\r\\n  (\:require [DSL [primary-operations composit-operations]]))" "(macroexpand '(ns RC.core\\r\\n  (\:require 'DSL.primary-operations\\r\\n             'DSL.composit-operations)))" "(ns RC.core\\r\\n  (\:require 'DSL.primary-operations\\r\\n             'DSL.composit-operations))" "(ns RC.core\\r\\n  (\:require ['DSL.primary-operations\\r\\n             'DSL.composit-operations]\\n            ))" "(ns RC.core\\r\\n  (\:require [DSL.primary-operations\\r\\n             DSL.composit-operations]\\n            ))" "(ns RC.core\\r\\n  (\:require [[DSL.primary-operations \:as one]\\r\\n             [DSL.composit-operations \:as two]]))" "(ns primary)" "(ns RC.core)" "(ns-name)" "(ns DSL.composit-operations)" "(gen/R->generate(R->def \:cor 4))" "(R->def \:cor 4)" "(gen/R->generate-command\\n  (R->def \:cor 4))" "(defn gen-R-post-proc [data]\\r\\n  (apply str (interpose \\";\\" data)))\\r\\n\\r\\n(defn gen-R-struct [operation parms-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec})\\r\\n\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"gen-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))" "(R->generate-command\\n  (R->def \:cor 4))" "\\r\\n(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve (symbol (str \\"codeGeneration.gen-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))" "(R->generate-command\\n  (R->def \:cor 4))" "(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n    (apply \\r\\n      (resolve 'codeGeneration (symbol (str \\"gen-\\" (name (\:oper R-rep)))))\\r\\n      (for [entry (\:parms R-rep)]\\r\\n        (cond \\r\\n          (map? entry) (R->generate-command entry)\\r\\n          (seq? entry) (apply R->generate-command entry) \\r\\n          \:default  entry))))" "(R->generate-command\\n  (R->def \:cor 4))" "(ns-rs codeGeneration (symbol (str \\"gen-\\" (name (\:oper R-rep)))))" "(ns-resolve codeGeneration (symbol (str \\"gen-\\" (name (\:oper R-rep)))))" "(ns-resolve 'codeGeneration (symbol (str \\"gen-\\" (name (\:oper R-rep)))))" "(gen/R->generate-command (R->def \:oen 3))" " (R->def \:oen 3)" "(gen/R->generate-command primary_operations.clj)" "(gen/R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(ns user)" "ns" "*ns*" "(R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(codeGeneration/R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(codeGeneration.R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(codeGeneration.RC-code-generation/R->generate-command {\:R-struct true, \:oper \:R->def, \:parms [\:oen 3]})" "(ns DSL.primary-operations)" "(R->def \:one 3)" "(gen/R->generate-command (R->def \:one 3))" "(resolve (symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" )))" "(resolve (symbol (str \\"codeGeneration.RC-code-generationdsdfs/R->generate-command/gen-R->summary \\" )))" "((resolve (symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" ))) [1 2 3])" "((symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" ))[1 2 3])" "((symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" )) 55 5 [1 2 3])" "((symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" ))[1 2 3])" "(symbol (str \\"codeGeneration.RC-code-generation/R->generate-command/gen-R->summary \\" ))" "(codeGeneration.RC-code-generation/R->generate-command/gen-R->summary [1 2 3])" "(codeGeneration.RC-code-generation/gen-R->summary [1 2 3])" "((resolve (symbol (str \\"codeGeneration.RC-code-generation/gen-R->summary \\" ))) [1 2 3])" "((resolve (symbol (str \\"codeGeneration.RC-code-generation/gen-R->summary\\" ))) [1 2 3])" "(R->def \:one 2)" "(gen/R->generate-command (R->def \:one 2))" "(ns DSL.primary-operations\\r\\n  (\:require [codeGeneration.RC-code-generation \:as gen]))" "(R-def \:one 21)" "(R->def \:one 21)" "(R->def \:one 1)" "(gen/R->generate-command (R->def \:one 1))" "(seq 1 1)" "(defn tests [& data]\\n  (class data))" "(tests 1 2 3)" "(seq? (tests 1 2 3))" "(seq? (tests {\:q 1}))" "(tests {\:q 1})" "(defmacro stnd-input-support [^clojure.lang.ArraySeq data]\\r\\n  (cond          \\r\\n    (> (count data) 1)            [(apply dsl/R->vector data)]\\r\\n    (apply vector? data)          [(apply dsl/R->vector (first data))]\\r\\n    (and (apply map? data)\\r\\n         (apply \:R-struct data))  [(first data)]\\r\\n    (apply map? data)             (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n    \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\"))))" "(R->mean 1 1 1)" "(gen/R->generate-command (R->mean 1 1 1))" "(R->generate-command (R->def \:one 1))" "(R->generate-command (R->def \:themean(R->mean {\:x (R->vector 1 2 43 45) \:y (R->vector 543 65 87)})))" "(R->\= \\"one\\" \\"tw\\")" "(R->generate-command (R->def \:themean(R->mean {\:x (R->vector 1 2 43 45) \:y (R->vector 543 65 87)})))" "  (require '[codeGeneration.RC-code-generation \:refer [R->generate R->generate-command]]\\r\\n            '[dsl.primary-operations \:refer \:all]\\r\\n            '[dsl.composit-operations \:refer \:all]\\r\\n            )" "(R->generate-command (R->mean {\:x (R->vector 1 2 3 4 5)}))" "(require '[clojure.test \:refer \:all]\\r\\n            [rc.core \:refer \:all])" "(R->generate-command (R->vector 1 2 3))" "(R->mean 1 2 3)" "(R->generate-command (R->mean 1 1 3 3))" "(R->generate (R->mean 1 1 3 3))" "(R->generate (R->mean 1 1 3 3) (R->def \:one 1))" "(R->generate (R->mean 1 1 3 3) )" "(R->mean 1 1 3 3)" "(deftest mean-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->mean 1 1 3 3) \\r\\n            {\:R-struct true, \:oper \:R->mean, \:parms [{\:R-struct true, \:oper \:R->vector, \:parms [[1 1 3 3]]}]}))))" "mean-basic-test" "(mean-basic-test)" "(deftest mean-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->mean 1 1 3 3) \\r\\n            {\:R-struct true, \:one 1 \:oper \:R->mean, \:parms [{\:R-struct true, \:oper \:R->vector, \:parms [[1 1 3 3]]}]}))))" "(mean-basic-test)" "(R->mean 1 1 3 3)" "(R->generate (R->mean 1 1 3 3) )" "(deftest mean-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->mean 1 1 3 3) \\r\\n            {\:R-struct true, \:oper \:R->mean, \:parms [{\:R-struct true, \:oper \:R->vector, \:parms [[1 1 3 3]]}]})))\\r\\n    (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->mean 1 1 3 3) \\"mean(c(1,1,3,3))\\"))))" "(mean-basic-test)" "(deftest mean-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->mean 1 1 3 3) \\r\\n            {\:R-struct true, \:oper \:R->mean, \:parms [{\:R-struct true, \:oper \:R->vector, \:parms [[1 1 3 3]]}]})))\\r\\n    (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->generate (R->mean 1 1 3 3)) \\"mean(c(1,1,3,3))\\"))))" "(mean-basic-test)" "(R->vector 1 2 3 4 5)" "(R->generate (R->vector 1 2 3 4 5))" "(deftest vector-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->vector 1 2 3 4 5) \\r\\n            {\:R-struct true, \:oper \:R->vector, \:parms [[1 2 3 4 5]]})))\\r\\n    (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->generate (R->vector 1 2 3 4 5)) \\"c(1,2,3,4,5)\\"))))" "(vector-basic-test)" "(R->generate (R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)})))" "(R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)}))" "(deftest mean-complex-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\=  (R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)})) \\r\\n            {\:R-struct true, \:oper \:R->def, \:parms [\:mymean {\:R-struct true, \:oper \:R->mean, \:parms [{\:R-struct true, \:oper \:R->\=, \:parms [\:x {\:R-struct true, \:oper \:R->vector, \:parms [[1 2 3 4 5]]}]}]}]})))\\r\\n    (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is\\r\\n      (\=  \\r\\n        (R->generate (R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)})))\\r\\n        \\"mymean<-mean(x\=c(1,2,3,4,5))\\"))))" "(mean-complex-test)" "(R->generate (R->summary 1 2 3 4))" "(R->summary 1 2 3 4)" "(deftest summary-basic-test\\r\\n  (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\= (R->summary 1 2 3 4) \\r\\n           {\:R-struct true, \:oper \:R->summary, \:parms [{\:R-struct true, \:oper \:R->vector, \:parms [[1 2 3 4]]}]})))\\r\\n    (testing \\"Mean taking simple numbers failed\\"\\r\\n    (is (\= (R->generate (R->summary 1 2 3 4)) \\"summary(c(1,2,3,4))\\"))))" "(summary-basic-test)" "(deftest summary-complex-test\\r\\n  (testing \\"mean structure taking map and vector failed\\"\\r\\n    (is (\=  (R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)})) \\r\\n            {\:R-struct true, \:oper \:R->def, \:parms [\:mymean {\:R-struct true, \:oper \:R->summary, \:parms [{\:R-struct true, \:oper \:R->\=, \:parms [\:x {\:R-struct true, \:oper \:R->vector, \:parms [[1 2 3 4 5]]}]}]}]})))\\r\\n    (testing \\"Mean output taking map and vector numbers failed\\"\\r\\n    (is\\r\\n      (\=  \\r\\n        (R->generate (R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)})))\\r\\n        \\"mymean<-summary(x\=c(1,2,3,4,5))\\"))))" "(summary-complex-test)" "(R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)}))" "(R->def \:mymean (R->summary {\:x (R->vector 1 2 3 4 5)}))" "(R->generate (R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)})))" " (R->generate (R->def \:mymean (R->summaryean {\:x (R->vector 1 2 3 4 5)})))" "(R->generate (R->def \:mymean (R->summaryean {\:x (R->vector 1 2 3 4 5)})))" " (R->generate (R->def \:mymean (R->summaryean {\:x (R->vector 1 2 3 4 5)})))" " (R->generate\\n   (R->def \:mymean\\n           (R->summary {\:x (R->vector 1 2 3 4 5)})))" "(deftest summary-complex-test\\r\\n  (testing \\"mean structure taking map and vector failed\\"\\r\\n    (is (\=  (R->def \:mymean (R->summary {\:x (R->vector 1 2 3 4 5)})) \\r\\n            {\:R-struct true, \:oper \:R->def, \:parms [\:mymean {\:R-struct true, \:oper \:R->summary, \:parms [{\:R-struct true, \:oper \:R->\=, \:parms [\:x {\:R-struct true, \:oper \:R->vector, \:parms [[1 2 3 4 5]]}]}]}]})))\\r\\n    (testing \\"Mean output taking map and vector numbers failed\\"\\r\\n    (is\\r\\n      (\=  \\r\\n        (R->generate\\r\\n      (R->def \:mymean\\r\\n              (R->summary {\:x (R->vector 1 2 3 4 5)})))\\r\\n        \\"mymean<-summary(x\=c(1,2,3,4,5))\\"))))" "(summary-basic-test)" "(mean-complex-test)" "(contains? [\:num] \:num)" "(some \#(\= \:num %) [\:sdf \:num])" "(some \#(\= \:num %) [\:sdf \:numd])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n  \\"\:num allow numbers\\r\\n   \:vec allows vectors\\r\\n   \:map allows maps\\r\\n   \:r-str allow R structure\\"\\r\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1)\\r\\n      (some \#(\:num) options-vec))  [(apply dsl/R->vector data)]\\r\\n    (and \\r\\n      (apply vector? data) \\r\\n      (some \#(\:vec) options-vec))  [(apply dsl/R->vector (first data))]\\r\\n    (and \\r\\n      (apply map? data)\\r\\n      (apply \:R-struct data)\\r\\n      (some \#(\:r-str) options-vec))     [(first data)]\\r\\n    (and \\r\\n      (apply map? data) \\r\\n      (apply \:R-struct data)\\r\\n      (some \#(\:map) options-vec))         (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n    \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(require '[dsl.primary-operations \:as dsl])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n  \\"\:num allow numbers\\r\\n   \:vec allows vectors\\r\\n   \:map allows maps\\r\\n   \:r-str allow R structure\\"\\r\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1)\\r\\n      (some \#(\:num) options-vec))  [(apply dsl/R->vector data)]\\r\\n    (and \\r\\n      (apply vector? data) \\r\\n      (some \#(\:vec) options-vec))  [(apply dsl/R->vector (first data))]\\r\\n    (and \\r\\n      (apply map? data)\\r\\n      (apply \:R-struct data)\\r\\n      (some \#(\:r-str) options-vec))     [(first data)]\\r\\n    (and \\r\\n      (apply map? data) \\r\\n      (apply \:R-struct data)\\r\\n      (some \#(\:map) options-vec))         (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n    \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(run-all)" "(R->mean 1 1 3 3)" "(stnd-input-support '(1 2 3))" "(stnd-input-support [1 2 3])" "(stnd-input-support 1)" "(stnd-input-support [1 1 1])" "(stnd-input-support [1 2 3])" "(stnd-input-support [1 2 3] [\:mpa])" "\\r\\n(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))  [(apply dsl/R->vector data)]\\r\\n      (and \\r\\n        (apply vector? data) \\r\\n        (some \#(\:vec) options-vec))  [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))     [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:map) options-vec))         (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(stnd-input-support [1 1] [\:num])" "\\r\\n(defn stnd-input-support \\r\\n  ([ data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))  [(apply dsl/R->vector data)]\\r\\n      (and \\r\\n        (apply vector? data) \\r\\n        (some \#(\:vec) options-vec))  [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))     [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:map) options-vec))         (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                      (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(stnd-input-support [1 1] [\:num])" "(defn testm \\n  ([one] (println \\"testone\: \\" one))\\n  ([one two] (println \\"testtwo\: \\" one \\" \\" two)))" "(testm \\"first\\")" "(testm \\"first\\" \\"second\\")" "(defn testm \\n  ([one] (testm \\"another\\" one))\\n  ([one two] (println \\"testtwo\: \\" one \\" \\" two)))" "(testm \\"fire\\")" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]\\r\\n      (and \\r\\n        (apply vector? data) \\r\\n        (some \#(\:vec) options-vec))    [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:map) options-vec))    (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                         (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (println data))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]\\r\\n      (and \\r\\n        (apply vector? data) \\r\\n        (some \#(\:vec) options-vec))    [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:map) options-vec))    (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                         (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(stnd-input-support [1 2 3])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n   (print data options-vec)))" "(stnd-input-support [1 2 3])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]\\r\\n      (and \\r\\n        (apply vector? data) \\r\\n        (some \#(\:vec) options-vec))    [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:map) options-vec))    (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                         (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(stnd-input-support [1 2 3])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n   (print data options-vec)))" "(stnd-input-support [1 2 3])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]\\r\\n      (and \\r\\n        (apply vector? data) \\r\\n        (some \#(\:vec) options-vec))    [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:map) options-vec))    (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                         (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(stnd-input-support [1 2 3])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n   (print data options-vec)))" "(stnd-input-support [1 2 3])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n        (> (count data) 1)    [(apply dsl/R->vector data)]\\r\\n        (apply vector? data)     [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)) [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data))    (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                         (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(stnd-input-support [1 2 3])" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]\\r\\n        (apply vector? data)   [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data))   (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                         (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(stnd-input-support [1 2 3])" "(let [data [1 2 3]\\n      options-vec [ 1 2 3]]\\n  (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]\\r\\n        (apply vector? data)   [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data))   (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default ) )" "(let [data [1 2 3]\\n      options-vec [ 1 2 3]]\\n  (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]\\r\\n        (apply vector? data)   [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data))   (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default [1]) )" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]\\r\\n        (apply vector? data)   [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#(\:r-str) options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (apply \:R-struct data))   (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default [1]) )" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1)\\r\\n      (some \#(\:num) options-vec))    [(apply dsl/R->vector data)]))" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n      (> (count data) 1)   [(apply dsl/R->vector data)]))" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1)\\r\\n      (not (nil? (some \#(\:num) options-vec))))   [(apply dsl/R->vector data)]))" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1)\\r\\n      nil)   [(apply dsl/R->vector data)]))" "(stnd-input-support [1 2 3])" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1))   [(apply dsl/R->vector data)]))" "(stnd-input-support [1 2 3])" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1))   [(apply dsl/R->vector data)]))" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1)\\n      nil)   [(apply dsl/R->vector data)]))" "(let [data [1 2 3]\\n      options-vec [\:num \:r-str]]\\n  (cond          \\r\\n    (and \\r\\n      (> (count data) 1)\\n      (some \#(\:num) options-vec))   [(apply dsl/R->vector data)]))" "(some \#(\:num) [\:num \:d])" "(some \#{\:num} [\:num \:d])" "(R->mean 1 2 3)" "(run-all)" "(R->def \:mymean (R->mean {\:x (R->vector 1 2 3 4 5)}))" "(R->summary 1 2 3 4)" "(R->generate (R->summary 1 2 3 4))" "(R->generate (R->def \:mymean (R->summary {\:x (R->vector 1 2 3 4 5)})))" "(R->generate \\n  (R->def \:mymean \\n          (R->summary \\n            1 2 3 4 5)))" "(R->generate \\n                     (R->summary\\n                       {\:x (R->vector 1 2 3 4 5)}))" "(R->generate  (R->summary\\n                {\:x (R->vector 1 2 3 4 5)}))" "(R->generate  (R->mean\\n                {\:x (R->vector 1 2 3 4 5)}))" "(R->vector 1 1 1 )" "(R->vector [1 2] )" "(R->def \:one 1)" "(R->def \:one (R->vector 1 2 3))" "(R->generate(R->def \:one (R->vector 1 2 3)))" "(R->generate(R->mean {\:one 1}))" "  \\r\\n(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#{\:num} options-vec))    [(apply dsl/R->vector data)]\\r\\n      (and \\r\\n        (apply vector? data) \\r\\n        (some \#{\:vec} options-vec))    [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#{\:r-str} options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (some \#{\:map} options-vec))    (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                         (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (cond          \\r\\n      (and \\r\\n        (> (count data) 1)\\r\\n        (some \#{\:num} options-vec))    [(apply dsl/R->vector data)]\\r\\n      (and \\r\\n        (apply vector? data) \\r\\n        (some \#{\:vec} options-vec))    [(apply dsl/R->vector (first data))]\\r\\n      (and \\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data)\\r\\n        (some \#{\:r-str} options-vec))  [(first data)]\\r\\n      (and \\r\\n        (apply map? data) \\r\\n        (some \#{\:map} options-vec))    (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n      \:default                         (throw (Exception. \\"Invalid element in function R->summary.\\")))))" "(run-all)" "(defn R->dataframe [& data]\\r\\n  \\"attribute map\\"\\r\\n  (gen/gen-R-struct R->dataframe (sup/stnd-input-support data [\:map \:r-srt])))" "(R->dataframe {\:x (R->vector 1 2 3)})" "(R->generate \\n  (R->dataframe {\:x (R->vector 1 2 3)}))" "(R->generate \\n  (R->dataframe {\:x 1}))" "(R->dataframe {\:x (R->vector 1 2 3)})" "(defn R->dataframe [& data]\\r\\n  \\"attribute map\\"\\r\\n  (gen/gen-R-struct \:R->dataframe (sup/stnd-input-support data [\:map \:r-srt])))" "(R->dataframe {\:x (R->vector 1 2 3)})" "(R->generate \\n  (R->dataframe {\:x (R->vector 1 2 3)}))" "(R->generate \\n  (R->mean {\:x (R->vector 1 2 3)}))" "(R->generate \\n  (R->dataframe {\:x (R->vector 1 2 3)}))" "(R->generate (R->dataframe {\:x (R->vector 2 3 4)}))" "(R->generate (R->dataframe 1 2 3))" "(R->dataframe 1 2 3)" "(R->dataframe 1)" "(R->dataframe {})" "(sup/stnd-input-support\\n  {\:x 1} [\:map \:r-srt])" "(R->generate (R->dataframe 1 2 3))" "(R->dataframe 1 2 3)" "(R->dataframe [1 2 3]\\n              \\n              )" "(R->dataframe 1 2 3)" "(R->dataframe (R->vector 1 2 3))" "(R->dataframe {\:x (R->vector 1 2 3)})" "(R->dataframe {\:x 1})" "(R->mean 1 2 3)" "(R->dataframe {\:x 1})" "(R->dataframe {\:x (R->vector 1 2 3)})" "(R->generate (R->dataframe {\:x (R->vector 1 2 3)}))" "\\n(R->generate\\n  (R->dataframe {\:x (R->vector 1 2 3) \\n          \:y (R->vector 4 5 6)}))" "\\n(R->generate\\n  (R->mean \\n    (R->dataframe {\:x (R->vector 1 2 3) \\n                   \:y (R->vector 4 5 6)})))" "\\n(R->generate\\n  (R->summary\\n    (R->dataframe {\:x (R->vector 1 2 3) \\n                   \:y (R->vector 4 5 6)})))" "\\n(R->generate\\n  (R->def \\n    \:values\\n    (R->summary\\n      (R->dataframe {\:x (R->vector 1 2 3) \\n                     \:y (R->vector 4 5 6)}))))" "(R->generate \\"values\\")" "\\n(R->generate\\n  (R->def \\n    \:values\\n    (R->summary\\n      (R->dataframe {\:x (R->vector 1 2 3) \\n                     \:y (R->vector 4 5 6)})))\\n  (R->dataframe? \:values)" "\\n(R->generate\\n  (R->def \\n    \:values\\n    (R->summary\\n      (R->dataframe {\:x (R->vector 1 2 3) \\n                     \:y (R->vector 4 5 6)})))\\n  (R->dataframe? \:values))" "\\n(R->generate\\n  (R->def \\n    \:values\\n    (R->summary\\n      (R->dataframe {\:x (R->vector 1 2 3) \\n                     \:y (R->vector 4 5 6)})))\\n  (R->dataframe? \\"v\\"))" "\\n(R->generate\\n  (R->def \\n    \:values\\n    (R->summary\\n      (R->dataframe {\:x (R->vector 1 2 3) \\n                     \:y (R->vector 4 5 6)}))))" "\\n(R->generate\\n  (R->dataframe? \\"v\\") )" "\\n  (R->dataframe? \\"v\\")" "(R->dataframe? \\"car\\")" "(R->dataframe? \:car)" "(name \:test)" "(R->generate (R->dataframe? \:test))" "\\n(R->generate\\n  (R->def \\n    \:values\\n    (R->summary\\n      (R->dataframe {\:x (R->vector 1 2 3) \\n                     \:y (R->vector 4 5 6)})))\\n  (R->dataframe? \\"v\\"))" "\\n(R->generate\\n  (R->def \\n    \:values\\n    (R->summary\\n      (R->dataframe {\:x (R->vector 1 2 3) \\n                     \:y (R->vector 4 5 6)})))\\n  (R->dataframe? \\"values\\"))" "(ns rc.core)" "(R->vector? \:one)" "(R->generate (R->vector? \:one))" "(R->matrix {\:x (R->vector 12 2 3 )})" "(R->generate (R->matrix {\:x (R->vector 12 2 3 )}))" "(R->generate (R->matrix {\:x (R->vector 12 2 3 ) \:y (R->vector 12 2 3 )}))" "(R->generate (R->mean {\:x (R->vector 12 2 3 ) \:y (R->vector 12 2 3 )}))" "(R->generate (R->matrix {\:x (R->vector 1 2 4) \:y (R->vector 4 5 6)}))" "(R->generate\\n  (R->summary\\n    (R->matrix {\:x (R->vector 1 2 4) \\n                \:y (R->vector 4 5 6)})))" "(R->generate\\n  (R->mean\\n    (R->matrix {\:x (R->vector 1 2 4) \\n                \:y (R->vector 4 5 6)})))" "(R->generate\\n  (R->mean\\n    (R->matrix {\:data (R->vector 1 2 4 1 2 4 1 2 4) \:ncol 3})))" "(R->vector 1 2 3 4 5)" "(R->generate (R->vector 1 2 3 4))" "(name \:stuff)" "(R->stripchart 1 2 3)" "(R->generate (R->stripchart 1 2 3))" "(R->generate (R->stripchart (R->range 1 4)))" "(R->generate (R->stripchart (R->vector (R->range 1 4))))" "(R->stripchart \\n  (R->vector\\n    (R->range 1 4)))" "(R->generate\\n  (R->vector\\n    (R->range 1 4)))" "(R->generate\\n\\n    (R->range 1 4))" "(R->generate (R->stripchart (R->vector 1 1 2 5 4 2 1 2.3 4.3)))" "(defn R->stripchart [& data]\\r\\n  \\"attribute map\\"\\r\\n  (gen/gen-R-struct \:R->stripchart (sup/stnd-input-support data [\:map \:r-srt])))" "(ns rc.core)" "(R->stripchart 1 1 1)" "(R->stripchart (R->vector 1 1 1))" "(defn R->stripchart [& data]\\r\\n  \\"attribute map\\"\\r\\n  (gen/gen-R-struct \:R->stripchart \\n                    (sup/stnd-input-support data [\:r-srt \:vec])))" "(R->stripchart 1 12)" "(defn R->stripchart [& data]\\r\\n  \\"attribute map\\"\\r\\n  (gen/gen-R-struct \:R->stripchart \\n                    (sup/stnd-input-support data [\:r-srt \:num])))" "(R->stripchart 1 12)" "(R->stripchart 1 1 12 23 33 2  3 4)" "(R->generate (R->stripchart 1 1 12 23 33 2  3 4))" "(defn gen-R->stripchart [values]\\r\\n  (str (reduce str \\"stripchart(\\"  values\\")\\")))" "(R->generate (R->stripchart 1 1 12 23 33 2  3 4))" "(defn gen-R->stripchart [values]\\r\\n  (str str \\"stripchart(\\"  values\\")\\"))" "(R->generate (R->stripchart 1 1 12 23 33 2  3 4))" "(R->generate (R->stripchart [1 1 12 23 33 2  3 4]))" "(R->generate (R->stripchart (R->vector 1 1 12 23 33 2  3 4)))" "(R->vector 1 1 12 23 33 2  3 4)" "(let [tm  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count tm)]\\n        (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))  [(first data)])" "(let [tm  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count tm)\\n      options-vec [\:r-str]]\\n        (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))  [(first data)])" "(let [data  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count tm)\\n      options-vec [\:r-str]]\\n        (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))  [(first data)])" "(let [data  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count data)\\n      options-vec [\:r-str]]\\n        (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))  [(first data)])" "(let [data  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count data)\\n      options-vec [\:r-str]]\\n       (if (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))  [(first data)])\\n       \\"yes\\"\\n       \\"no\\")" "(let [data  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count data)\\n      options-vec [\:r-str]]\\n       (if (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n       ; (apply map? data)\\r\\n        (apply \:R-struct data))  [(first data)])\\n       \\"yes\\"\\n       \\"no\\")" "(let [data  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count data)\\n      options-vec [\:r-str]]\\n       (if (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))\\n       \\"yes\\"\\n       \\"no\\"))" "(let [data  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count data)\\n      options-vec [\:r-str]]\\n       (if (and \\r\\n       ; (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))\\n       \\"yes\\"\\n       \\"no\\"))" "(let [data  (seq {\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count data)\\n      options-vec [\:r-str]]\\n       (if (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n       ; (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))\\n       \\"yes\\"\\n       \\"no\\"))" "(let [data  '({\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count data)\\n      options-vec [\:r-str]]\\n       (if (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n       ; (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))\\n       \\"yes\\"\\n       \\"no\\"))" "(let [data  '({\:R-struct true, \:oper \:R->vector, \:parms [[1 1 12 23 33 2 3 4]]})\\n      cardinality (count data)\\n      options-vec [\:r-str]]\\n       (if (and \\r\\n        (some \#{\:r-str} options-vec)\\r\\n        (\= cardinality 1)\\r\\n        (apply map? data)\\r\\n        (apply \:R-struct data))\\n       \\"yes\\"\\n       \\"no\\"))" "(R->vector 1 1 12 23 33 2  3 4)" "(R->generate (R->stripchart (R->vector 1 1 12 23 33 2  3 4)))" "(R->generate (R->stripchart 12 3 54 65))" "(R->mean 1 2 3)" "(R->generate (R->mean (R->vector 1 1 12 23 33 2  3 4)))" "(defn R->stripchart [& data]\\r\\n  \\"attribute map\\"\\r\\n  (gen/gen-R-struct \:R->stripchart (sup/stnd-input-support data)))" "(R->generate (R->stripchart (R->vector 1 1 12 23 33 2  3 4)))" "(ns rc.core)" "(R->generate (R->stripchart (R->vector 1 1 12 23 33 2  3 4)))" "(R->generate (R->stripchart [1 2 3 4]))" "(R->generate (R->stripchart 3 4 4 5))" "(R->generate (R->stripchart {}))" "(R->generate (R->stripchart (R->vector 1 1 12 23 33 2  3 4)))" "(R->generate (R->stripchart (R->vector (R->range 1 40))))" "(ns rc.core)" "(R->generate (R->boxplot 1 2 3 4))" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n             (R->\= \:mean2 (R->mean 3 5 6 7)) \\n             (R->\= \:mean3 (R->mean 3 5 67)) \\n             (R->\= \:mean4 (R->mean 3 75 6 7))\\n             (R->boxplot \:mean1 \:mean2 \:mean3 \:mean4))" "(defn stnd-input-support \\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:num \:vec \:map \:r-str \:key]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)]\\r\\n      (cond \\r\\n        (and \\r\\n          (some \#{\:key} options-vec)\\r\\n          (apply keyword? data))\\r\\n         [(apply name data)]        \\r\\n        (and \\r\\n          (some \#{\:num} options-vec)\\r\\n          (> cardinality 1)) \\r\\n         [(apply dsl/R->vector data)]\\r\\n        (and \\r\\n          (some \#{\:vec} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply vector? data))    \\r\\n        [(apply dsl/R->vector (first data))]\\r\\n        (and \\r\\n          (some \#{\:r-str} options-vec)\\r\\n          (\=  1)\\r\\n          (apply map? data)\\r\\n          (apply \:R-struct data))\\r\\n        [(first data)]\\r\\n        (and \\r\\n          (some \#{\:map} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data))    \\r\\n        (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n        \:default                         \\r\\n        (throw (Exception. (str \\"Invalid element in function\\"\\r\\n                            \\"\\\\nData\: \\" data \\r\\n                            \\"\\\\noptions\: \\" options-vec\\r\\n                            \\"\\\\nCardinality\: \\" cardinality)))))))" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n             (R->\= \:mean2 (R->mean 3 5 6 7)) \\n             (R->\= \:mean3 (R->mean 3 5 67)) \\n             (R->\= \:mean4 (R->mean 3 75 6 7))\\n             (R->boxplot \:mean1 \:mean2 \:mean3 \:mean4))" "(ns rc.core)" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n             (R->\= \:mean2 (R->mean 3 5 6 7)) \\n             (R->\= \:mean3 (R->mean 3 5 67)) \\n             (R->\= \:mean4 (R->mean 3 75 6 7))\\n             (R->boxplot \:mean1 \:mean2 \:mean3 \:mean4))" "(ns rc.core)" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n             (R->\= \:mean2 (R->mean 3 5 6 7)) \\n             (R->\= \:mean3 (R->mean 3 5 67)) \\n             (R->\= \:mean4 (R->mean 3 75 6 7))\\n             (R->boxplot \:mean1 \:mean2 \:mean3 \:mean4))" "\\n             (R->boxplot \:mean1 \:mean2 \:mean3 \:mean4)" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n             (R->\= \:mean2 (R->mean 3 5 6 7)) \\n             (R->\= \:mean3 (R->mean 3 5 67)) \\n             (R->\= \:mean4 (R->mean 3 75 6 7)))" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n)" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n             (R->\= \:mean2 (R->mean 3 5 6 7)) \\n             (R->\= \:mean3 (R->mean 3 5 67)) \\n             (R->\= \:mean4 (R->mean 3 75 6 7)))" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n             (R->\= \:mean2 (R->mean 3 5 6 7)) \\n             (R->\= \:mean3 (R->mean 3 5 67)) \\n             (R->\= \:mean4 (R->mean 3 75 6 7))\\n             (R->boxplot \:mean1 \:mean2 \:mean3 \:mean4))" "(ns rc.core)" "(R->generate (R->\= \:mean1 (R->mean 1 2 4 5)) \\n             (R->\= \:mean2 (R->mean 3 5 6 7)) \\n             (R->\= \:mean3 (R->mean 3 5 67)) \\n             (R->\= \:mean4 (R->mean 3 75 6 7))\\n             (R->boxplot \:mean1 \:mean2 \:mean3 \:mean4))" "(ns rc.core)" "(R->sample 1 1 1 1)" "(R->generate (R->sample 1 1 1 1))" "(into [] '(1 2 3))" "(R->generate (R->sample 1 1 1 1))" "(ns rc.core)" "(R->generate (R->sample 1 1 1 1))" "(R->generate (R->sample (R->range 1 20) 1 1 1))" "(R->generate (R->sample 1 1 1 1))" "(R->generate (R->sample (R->range 1 20) 1 1 1))" "(R->\= \:one 2)" "(R->generate (R->\= \:one 2))" "(R->generate (R->def \:one 2))" "(R->generate (R->mean 1 1 1 2 3 4))" "(R->mean 1 1 1 2 3 4)" "(defn R->mean [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (gen/gen-R-struct \:R->mean data [\:vec \:num \:map \:r-str] [\:vec->rvec \:raw->vec \:map->\=]))" "(defn R->mean-new [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (gen/gen-R-struct \:R->mean data [\:vec \:num \:map \:r-str] [\:vec->rvec \:raw->vec \:map->\=]))" "(defn R->mean-new [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (gen-R-struct \:R->mean data [\:vec \:num \:map \:r-str] [\:vec->rvec \:raw->vec \:map->\=]))" "(defn gen-R-struct [operation parms-vec validate-vec behavior-vec]\\r\\n  {\:R-struct true \:oper operation \:parms parms-vec \:valid validate-vec \:behavior behavior-vec})" "(defn R->mean-new [& data]\\r\\n  \\"Takes vector, R-vector, numbers or attribute map\\"\\r\\n  (gen-R-struct \:R->mean data [\:vec \:num \:map \:r-str] [\:vec->rvec \:raw->vec \:map->\=]))" "(R->mean-new 1 2 3)" "(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\r\\n  (apply \\r\\n    (resolve \\r\\n      (symbol (str \\"codeGeneration.RC-code-generation/gen-\\" (name (\:oper R-rep))))) ; get code emittion function\\r\\n    (for [entry (\:parms R-rep)] ; process each parameter\\r\\n      (cond \\r\\n        (map? entry) (R->generate-command entry) ;if map requires proccessing\\r\\n        (seq? entry) (apply R->generate-command entry) ; if sequence unwrap and process each\\r\\n        \:default  entry))))" "(defn gen-R-struct [operation parms-vec validate-vec behavior-vec]\\r\\n  {\:R-struct true \:oper operation \:parms (into [] parms-vec) \:valid validate-vec \:behavior behavior-vec})" "(R->mean-new 1 2 3)" "(R->mean-new {\:x 1})" "(R->mean-new 1 2 3)" "(R->generate (R->mean 1 1 1 2 3 4))" "(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  ;preprocess\\n  (let [R-rep (behavior-process R-rep)]\\r\\n  (apply \\r\\n    (resolve \\r\\n      (symbol (str \\"codeGeneration.RC-code-generation/gen-\\" (name (\:oper R-rep))))) ; get code emittion function\\r\\n    (for [entry (\:parms R-rep)] ; process each parameter\\r\\n      (cond \\r\\n        (map? entry) (R->generate-command entry) ;if map requires proccessing\\r\\n        (seq? entry) (apply R->generate-command entry) ; if sequence unwrap and process each\\r\\n        \:default  entry)))))" "(defn behavior-process\\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (behavior-process data [\:num \:vec \:map \:r-str \:key]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)]\\r\\n      (try \\r\\n        (cond        \\r\\n          (and \\r\\n            (some \#{\:num} options-vec)\\r\\n            (> cardinality 1)) \\r\\n          [(apply dsl/R->vector \\r\\n                  (map (fn [x] (if (keyword? x) (name x) x)) data))]\\r\\n          (and \\r\\n            (some \#{\:vec} options-vec)\\r\\n            (\= cardinality 1)\\r\\n            (apply vector? data))    \\r\\n          [(apply dsl/R->vector (first data))]\\r\\n          (and \\r\\n            (some \#{\:r-str} options-vec)\\r\\n            (\=  1)\\r\\n            (apply map? data)\\r\\n            (apply \:R-struct data))\\r\\n          [(first data)]\\r\\n          (and \\r\\n            (some \#{\:map} options-vec)\\r\\n            (\= cardinality 1)\\r\\n            (apply map? data))    \\r\\n          (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n          \:default                         \\r\\n          (throw (Exception. (str \\"Invalid parameter type in function.\\"))))\\r\\n      (catch Exception e (str \\"exception in std-input-support occured\: \\" (.getMessage e)\\r\\n                              \\"\\\\nData\: \\" data \\r\\n                              \\"\\\\noptions\: \\" options-vec\\r\\n                              \\"\\\\nCardinality\: \\" cardinality))))))" "(defn behavior-process\\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (behavior-process data [\:num \:vec \:map \:r-str \:key]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)]\\r\\n      (try \\r\\n        (cond        \\r\\n          (and \\r\\n            (some \#{\:num} options-vec)\\r\\n            (> cardinality 1)) \\r\\n          [(apply R->vector \\r\\n                  (map (fn [x] (if (keyword? x) (name x) x)) data))]\\r\\n          (and \\r\\n            (some \#{\:vec} options-vec)\\r\\n            (\= cardinality 1)\\r\\n            (apply vector? data))    \\r\\n          [(apply dsl/R->vector (first data))]\\r\\n          (and \\r\\n            (some \#{\:r-str} options-vec)\\r\\n            (\=  1)\\r\\n            (apply map? data)\\r\\n            (apply \:R-struct data))\\r\\n          [(first data)]\\r\\n          (and \\r\\n            (some \#{\:map} options-vec)\\r\\n            (\= cardinality 1)\\r\\n            (apply map? data))    \\r\\n          (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n          \:default                         \\r\\n          (throw (Exception. (str \\"Invalid parameter type in function.\\"))))\\r\\n      (catch Exception e (str \\"exception in std-input-support occured\: \\" (.getMessage e)\\r\\n                              \\"\\\\nData\: \\" data \\r\\n                              \\"\\\\noptions\: \\" options-vec\\r\\n                              \\"\\\\nCardinality\: \\" cardinality))))))" "(defn behavior-process\\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (behavior-process data [\:num \:vec \:map \:r-str \:key]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)]\\r\\n      (try \\r\\n        (cond        \\r\\n          (and \\r\\n            (some \#{\:num} options-vec)\\r\\n            (> cardinality 1)) \\r\\n          [(apply R->vector \\r\\n                  (map (fn [x] (if (keyword? x) (name x) x)) data))]\\r\\n          (and \\r\\n            (some \#{\:vec} options-vec)\\r\\n            (\= cardinality 1)\\r\\n            (apply vector? data))    \\r\\n          [(apply R->vector (first data))]\\r\\n          (and \\r\\n            (some \#{\:r-str} options-vec)\\r\\n            (\=  1)\\r\\n            (apply map? data)\\r\\n            (apply \:R-struct data))\\r\\n          [(first data)]\\r\\n          (and \\r\\n            (some \#{\:map} options-vec)\\r\\n            (\= cardinality 1)\\r\\n            (apply map? data))    \\r\\n          (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n          \:default                         \\r\\n          (throw (Exception. (str \\"Invalid parameter type in function.\\"))))\\r\\n      (catch Exception e (str \\"exception in std-input-support occured\: \\" (.getMessage e)\\r\\n                              \\"\\\\nData\: \\" data \\r\\n                              \\"\\\\noptions\: \\" options-vec\\r\\n                              \\"\\\\nCardinality\: \\" cardinality))))))" "(defn behavior-process\\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (behavior-process data [\:num \:vec \:map \:r-str \:key]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)]\\r\\n      (try \\r\\n        (cond        \\r\\n          (and \\r\\n            (some \#{\:num} options-vec)\\r\\n            (> cardinality 1)) \\r\\n          [(apply R->vector \\r\\n                  (map (fn [x] (if (keyword? x) (name x) x)) data))]\\r\\n          (and \\r\\n            (some \#{\:vec} options-vec)\\r\\n            (\= cardinality 1)\\r\\n            (apply vector? data))    \\r\\n          [(apply R->vector (first data))]\\r\\n          (and \\r\\n            (some \#{\:r-str} options-vec)\\r\\n            (\=  1)\\r\\n            (apply map? data)\\r\\n            (apply \:R-struct data))\\r\\n          [(first data)]\\r\\n          (and \\r\\n            (some \#{\:map} options-vec)\\r\\n            (\= cardinality 1)\\r\\n            (apply map? data))    \\r\\n          (into [] (->> data  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))\\r\\n          \:default                         \\r\\n          (throw (Exception. (str \\"Invalid parameter type in function.\\"))))\\r\\n      (catch Exception e (str \\"exception in std-input-support occured\: \\" (.getMessage e)\\r\\n                              \\"\\\\nData\: \\" data \\r\\n                              \\"\\\\noptions\: \\" options-vec\\r\\n                              \\"\\\\nCardinality\: \\" cardinality))))))" "(defn R->generate-command [R-rep]\\r\\n  \\"Mapping of clojure R representation to R language\\"\\n  ;preprocess\\n  (let [R-rep (behavior-process R-rep)]\\r\\n  (apply \\r\\n    (resolve \\r\\n      (symbol (str \\"codeGeneration.RC-code-generation/gen-\\" (name (\:oper R-rep))))) ; get code emittion function\\r\\n    (for [entry (\:parms R-rep)] ; process each parameter\\r\\n      (cond \\r\\n        (map? entry) (R->generate-command entry) ;if map requires proccessing\\r\\n        (seq? entry) (apply R->generate-command entry) ; if sequence unwrap and process each\\r\\n        \:default  entry)))))" "(R->generate (R->mean 1 1 1 2 3 4))" "(R->generate-command (R->mean 1 1 1 2 3 4))" "(R->mean (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(R->generate (R->mean (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) )))" "(R->generate-command (R->mean 1 1 1 2 3 4))" "(R->generate (R->mean (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) )))" "(ns rc.core)" "(R->generate (R->mean (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) )))" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(defn gen-R->vector [& data]\\r\\n    (str \\"c(\\" (apply str (interpose \\",\\" data)) \\")\\")" "(defn gen-R->vector [& data]\\r\\n    (str \\"c(\\" (apply str (interpose \\",\\" data)) \\")\\"))" "(gen-R->vector 1 2 3 4)" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(defn gen-R->vector [& data]\\r\\n    (str \\"c(\\"  data \\")\\"))" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(defn gen-R->vector [& data]\\r\\n    (str \\"c(\\"  data \\")\\"))" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) )" "(R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1))" "(ns rc.core)" "(R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1))" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(interose \\",\\" '(\\"1\\" \\"1\\"))" "(interpose \\",\\" '(\\"1\\" \\"1\\"))" "ns" "(ns)" "(ns codeGeneration.RC-code-generation)" "(defn gen-R->vector [& data]\\n  (do (print data)\\r\\n    (str (interpose \\",\\" data)) \\")\\"))" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(ns rc.core)" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(ns codeGeneration.RC-code-generation)" "(defn gen-R->vector [& data]\\n  (do (print data) (print (interpose \\",\\" data))\\r\\n    (str (interpose \\",\\" data)) \\")\\"))" "(ns rc.core)" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(ns codeGeneration.RC-code-generation)" "(defn gen-R->vector [& data]\\r\\n    (str (interpose \\",\\" data) \\")\\"))" "(ns rc.core)" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(ns codeGeneration.RC-code-generation)" "(defn gen-R->vector [& data]\\r\\n    (apply str (interpose \\",\\" data) \\")\\"))" "(ns rc.core)" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(ns codeGeneration.RC-code-generation)" "(defn gen-R->vector [& data]\\r\\n    (str (interpose \\",\\" data)))" "(ns rc.core)" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(ns codeGeneration.RC-code-generation)" "(defn gen-R->vector [& data]\\r\\n    (str (interpose \\",\\" \\n                    )))" "(str (interpose \\",\\" '(1 1 1)))" "(apply str (interpose \\",\\" '(1 1 1)))" "(str \\"c(\\" (apply str (interpose \\",\\" '(1 1 1))) \\")\\")" "(defn gen-R->vector [& data]\\r\\n    (str \\"c(\\" (apply str (interpose \\",\\" data)) \\")\\"))" "(ns rc.core)" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->number 1) ))" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))" "(R->keyword \:dog)" "(R->generate (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))" "(R->generate (R->mean (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) )))" "(R->generate (R->mean (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))" "(R->generate (R->mean \\n               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\n               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))" "(R->generate (R->def \:main1 (R->mean \\n                             (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\n                             (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) )))))" "(R->generate (R->def \:m1 (R->mean \\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->def \:m2 (R->mean \\r\\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->def \:m3 (R->mean \\r\\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->stripchart (R->keyword m1) (R->keyword m2) (R->keyword m3)))" "(R->generate (R->def \:m1 (R->mean \\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->def \:m2 (R->mean \\r\\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->def \:m3 (R->mean \\r\\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->stripchart (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3)))" "(R->generate (R->def \:m1 (R->mean \\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->def \:m2 (R->mean \\r\\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->def \:m3 (R->mean \\r\\n                          (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                          (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n             (R->stripchart (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3))))" "(R->generate \\n  (R->def \:dog 4)\\n  (R->def \:m1 (R->mean \\n                (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\n                (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n  (R->def \:m2 (R->mean \\r\\n                (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n  (R->def \:m3 (R->mean \\r\\n                (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\n  (R->stripchart (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3))))" "          (R->generate \\r\\n                 (R->def \:dog 4)\\r\\n                 (R->def \:m1 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\r\\n                 (R->def \:m2 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\r\\n                 (R->def \:m3 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\r\\n                 (R->stripchart (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3))))" "(R->generate (R->boxplot (R->\= \:x (R->vector 1 2 3)) (R->\= \:y (R->vector 1 2 3))))" "(ns dsl.composit-operations)" "(mean 1 2 3 4)" "(ns rc.core)" "  (require '[codeGeneration.RC-code-generation \:refer [R->generate]]\\r\\n            '[dsl.primary-operations \:refer \:all]\\r\\n            '[dsl.composit-operations \:refer \:all])" "(R->generate (mean 1 2 3))" "(R->generate (mean {\:x [1 2 3]}))" "(R->generate (mean {\:x (R->vector 1 2 3)}))" "(R->generate (mean 1 2 3))" "  (require '[codeGeneration.RC-code-generation \:refer [R->generate]]\\r\\n            '[dsl.primary-operations \:refer \:all]\\r\\n            '[dsl.composit-operations \:refer \:all]\\r\\n            )" "(R->generate (mean 1 2 3))" "(map (fn [x] (cond\\n               (number? x) (R->number x)\\n               (keyword? x) (R->keyword x)\\n               \:default (throw (Exception. (str \\"Invalid parameter type in function.\\"))))) [1 3 \:d 4])" "(R->generate (mean 1 2 3))" " (mean 1 2 3)" "(R->generate (mean 1 2 3))" "(R->generate (mean (R->vector 1 2 3)))" " (R->generate \\r\\n                 (R->def \:dog 4)\\r\\n                 (R->def \:m1 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\r\\n                 (R->def \:m2 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\r\\n                 (R->def \:m3 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))))\\r\\n                 (R->stripchart (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3))))" "(R->generate (mean (R->vector 1 2 3)))" " (mean (R->vector 1 2 3))" "  (require '[codeGeneration.RC-code-generation \:refer [R->generate]]\\r\\n            '[dsl.primary-operations \:refer \:all]\\r\\n            '[dsl.composit-operations \:refer \:all])" " (mean (R->vector 1 2 3))" "(R->vector 1 2 3)" " (mean (R->vector 1 2 3))" "(R->vector 1 2 3)" " (mean (R->vector 1 2 3))" "(R->vector 1 2 3)" " (mean 1 2 3)" "(R->generate (mean 1 2 3))" "(R->vector 1 2 3)" "(apply assoc '({\:R-struct true, \:oper \:R->vector, \:parms []}) \:parms (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}))))" "(defn convert-raw-value [data-coll]\\r\\n  (into []\\r\\n        (map (fn [x] (cond\\r\\n                 (number? x) (dsl/R->number x)\\r\\n                 (keyword? x) (dsl/R->keyword x)\\r\\n                 \:default (throw (Exception. (str \\"Invalid parameter type in function.\\"))))) data-coll)))" "(require '[dsl.primary-operations \:as dsl])" "(defn convert-raw-value [data-coll]\\r\\n  (into []\\r\\n        (map (fn [x] (cond\\r\\n                 (number? x) (dsl/R->number x)\\r\\n                 (keyword? x) (dsl/R->keyword x)\\r\\n                 \:default (throw (Exception. (str \\"Invalid parameter type in function.\\"))))) data-coll)))" "(apply assoc '({\:R-struct true, \:oper \:R->vector, \:parms []}) \:parms (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}))))" " (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]})))" "(assoc '({\:R-struct true, \:oper \:R->vector, \:parms []}) \\n       \:parms (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}))))" "(apply assoc '({\:R-struct true, \:oper \:R->vector, \:parms []}) \\n       \:parms (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}))))" "(assoc (first '({\:R-struct true, \:oper \:R->vector, \:parms []})) \\n       \:parms (convert-raw-value (apply \:parms '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}))))" " (-> '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}) first (assoc  \:parms \\n                                                                        \\n                                                                         (->> '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}) (apply \:parms) (convert-raw-value))))" " (-> '({\:R-struct true, \:oper \:R->vector, \:parms [1 2 3]}) first (assoc  \:parms \\n                                                                        \\n                                                                         (->> '({\:R-struct true, \:oper \:R->vector, \:parms [1 444 3]}) (apply \:parms) (convert-raw-value))))" " (mean (R->vector 1 2 3))" "(R->generate (mean (R->vector 1 2 3)))" "(R->stripchart 1 2 3)" "(R->stripchart (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3)))" "(R->generate (R->stripchart (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3))))" "(R->generate (R->mean (R->vector (R->keyword \:m1) (R->keyword \:m2) (R->keyword \:m3))))" "(require '[testDrivenDev.integration-test])" "  (require '[codeGeneration.RC-code-generation \:refer [R->generate]]\\r\\n            '[dsl.primary-operations \:refer \:all]\\r\\n            '[dsl.composit-operations \:refer \:all]\\r\\n            )" "(R->generate (R->mean 1 2 3))" "(R->generate (R->mean [1 2 3]))" "(R->generate (R->mean {\:x (R->vector 2 2 3)}))" "(R->generate (mean 1 2 3))" "(R->generate (mean {\:x (R->vector 2 2 3)}))" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(mean 1 2 3)" "(R->generate (mean 1 2 3))" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(into [] (->> {\:x (R->vector (R->number 1))}  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))" "(into [] (->> {\:x (R->vector (R->number 1))}  (apply seq) (map (fn [val] (R->\= (first val) (second val))))))" " (R->vector (R->number 1))" "(->> {\:x (R->vector (R->number 1))}  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))" "(->> {\\"x\\" (R->vector (R->number 1))}  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))" "(->> {\:x (R->vector (R->number 1))}  (apply seq))" "(->> {\\"x\\" (R->vector (R->number 1)) \:y (R->vector (R->number 1))}  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))" "(->> {\\"x\\" (R->vector (R->number 1)) \:y (R->vector (R->number 1))}  \\n  (apply seq) )" "(->> '({\\"x\\" (R->vector (R->number 1)) \:y (R->vector (R->number 1))})\\n  (apply seq) )" "(->> [{\\"x\\" (R->vector (R->number 1)) \:y (R->vector (R->number 1))}]\\n  (apply seq) )" "(->> [{\\"x\\" (R->vector (R->number 1)) \:y (R->vector (R->number 1))}]\\n  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val)))))" "(->> [{\\"x\\" (R->vector (R->number 1)) \:y (R->vector (R->number 1))}]\\n  (apply seq) (map (fn [val] (R->\= (first val) (second val)))))" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(defn stnd-input-support \\r\\n  \\"Resolves common parameter input conversions such and numbers vectors and maps\\"\\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:raw \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)]\\r\\n      (cond          \\r\\n        (and \\r\\n          (some \#{\:raw} options-vec)\\r\\n          (> cardinality 1)) \\r\\n        (apply dsl/R->vector (convert-raw-value data)) \\r\\n        (and \\r\\n          (some \#{\:vec} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply vector? data))    \\r\\n        (apply dsl/R->vector (convert-raw-value (first data)))\\r\\n        (and \\r\\n          (some \#{\:r-str} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data)\\r\\n          (apply \:R-struct data)) \\r\\n        (-> data first (assoc  \:parms (->> data (apply \:parms) (convert-raw-value))))\\r\\n        (and \\r\\n          (some \#{\:map} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data))    \\r\\n        (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n        \:default                       \\r\\n        (throw (Exception. \\"Invalid element in function R->summary.\\"))))))" " (require '[dsl.primary-operations \:as dsl])\\n(defn stnd-input-support \\r\\n  \\"Resolves common parameter input conversions such and numbers vectors and maps\\"\\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:raw \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)]\\r\\n      (cond          \\r\\n        (and \\r\\n          (some \#{\:raw} options-vec)\\r\\n          (> cardinality 1)) \\r\\n        (apply dsl/R->vector (convert-raw-value data)) \\r\\n        (and \\r\\n          (some \#{\:vec} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply vector? data))    \\r\\n        (apply dsl/R->vector (convert-raw-value (first data)))\\r\\n        (and \\r\\n          (some \#{\:r-str} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data)\\r\\n          (apply \:R-struct data)) \\r\\n        (-> data first (assoc  \:parms (->> data (apply \:parms) (convert-raw-value))))\\r\\n        (and \\r\\n          (some \#{\:map} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data))    \\r\\n        (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n        \:default                       \\r\\n        (throw (Exception. \\"Invalid element in function R->summary.\\"))))))" "(defn convert-raw-value [data-coll]\\r\\n  \\"Converts raw numbers and keywords to R datastructs\\"\\r\\n  (into []\\r\\n        (map (fn [x] (cond\\r\\n                       (number? x) (dsl/R->number x)\\r\\n                       (keyword? x) (dsl/R->keyword x)\\r\\n                       \:default (throw (Exception. (str \\"Invalid parameter type in function.\\"))))) data-coll)))" " (require '[dsl.primary-operations \:as dsl])\\n(defn stnd-input-support \\r\\n  \\"Resolves common parameter input conversions such and numbers vectors and maps\\"\\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:raw \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)]\\r\\n      (cond          \\r\\n        (and \\r\\n          (some \#{\:raw} options-vec)\\r\\n          (> cardinality 1)) \\r\\n        (apply dsl/R->vector (convert-raw-value data)) \\r\\n        (and \\r\\n          (some \#{\:vec} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply vector? data))    \\r\\n        (apply dsl/R->vector (convert-raw-value (first data)))\\r\\n        (and \\r\\n          (some \#{\:r-str} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data)\\r\\n          (apply \:R-struct data)) \\r\\n        (-> data first (assoc  \:parms (->> data (apply \:parms) (convert-raw-value))))\\r\\n        (and \\r\\n          (some \#{\:map} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data))    \\r\\n        (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n        \:default                       \\r\\n        (throw (Exception. \\"Invalid element in function R->summary.\\"))))))" "(defn stnd-input-support \\r\\n  \\"Resolves common parameter input conversions such and numbers vectors and maps\\"\\r\\n  ([^clojure.lang.ArraySeq data]\\r\\n    (stnd-input-support data [\:raw \:vec \:map \:r-str]))\\r\\n  ([^clojure.lang.ArraySeq data options-vec]\\r\\n    \\"\:num allow numbers\\r\\n     \:vec allows vectors\\r\\n     \:map allows maps\\r\\n     \:r-str allow R structure\\"\\r\\n    (let [cardinality (count data)\\n          _ (println \\"success\\")]\\r\\n      (cond          \\r\\n        (and \\r\\n          (some \#{\:raw} options-vec)\\r\\n          (> cardinality 1)) \\r\\n        (apply dsl/R->vector (convert-raw-value data)) \\r\\n        (and \\r\\n          (some \#{\:vec} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply vector? data))    \\r\\n        (apply dsl/R->vector (convert-raw-value (first data)))\\r\\n        (and \\r\\n          (some \#{\:r-str} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data)\\r\\n          (apply \:R-struct data)) \\r\\n        (-> data first (assoc  \:parms (->> data (apply \:parms) (convert-raw-value))))\\r\\n        (and \\r\\n          (some \#{\:map} options-vec)\\r\\n          (\= cardinality 1)\\r\\n          (apply map? data))    \\r\\n        (into [] (->> data  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val))))))\\r\\n        \:default                       \\r\\n        (throw (Exception. \\"Invalid element in function R->summary.\\"))))))" "(mean 1 2 3)" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(->> '({\:x {\:R-struct true, \:oper \:R->vector, \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}}) \\n  (apply seq))" "(->> '({\:x {\:R-struct true, \:oper \:R->vector, \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}}) \\n  (apply seq) (map (fn [val] (dsl/R->\= (first val) (second val)))))" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(->> '({\:x {\:R-struct true, \:oper \:R->vector, \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}}) \\n  (apply seq) (map (fn [val] (dsl/R->\= (R->keyword (first val)) (second val)))))" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(->> '({\:x {\:R-struct true, \:oper \:R->vector, \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}}) \\n  (apply seq) (map (fn [val] (dsl/R->\= (R->keyword (first val)) (second val)))))" "(->> \\n  '({\:x {\:R-struct true, \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \\n                  \:parms [1]}]}}) \\n  (apply seq) (map (fn [val] \\n                     (dsl/R->\= (R->keyword (first val)) (second val)))))" "(->> \\n  '({\:x {\:R-struct true, \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \\n                  \:parms [1]}]}}) \\n  (apply seq))" "(->> \\n  '({\:x {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \\n                  \:parms [1]}]}}\\n     {\:y {\:R-struct true, \\r\\n         \:oper \:R->vector, \\r\\n         \:parms [{\:R-struct true, \:oper \:R->number, \\r\\n                  \:parms [1]}]}}) \\n  (apply seq))" "(->> \\n  '({\:x {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \\n                  \:parms [1]}]}\\n     \:y {\:R-struct true, \\r\\n         \:oper \:R->vector, \\r\\n         \:parms [{\:R-struct true, \:oper \:R->number, \\r\\n                  \:parms [1]}]}}) \\n  (apply seq))" "(->> '({\:x \\n        {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}}) \\n  (apply seq) (map (fn [val] (dsl/R->\= (R->keyword (first val)) (second val)))))" "(->> '({\:x \\n        {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}}) \\n  (apply seq) (map (fn [val] (println (first val) (second val)))))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}}\\n  (apply seq) (map (fn [val] (println (first val) (second val)))))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}}\\n  (apply seq))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n  (apply seq))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq)" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (map (fn [val] (println (first val) (second val)))))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (dsl/R->\=  (dsl/R->keyword (first val)) (second val)))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq )" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (map (fn [val] (println val))))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (map (fn [val] (println \\"\\"))))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (map (fn [val] (println val))))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (dsl/R->\=  (dsl/R->keyword (first val)) (second val)))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (dsl/R->\=  (first val) (second val)))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (map (dsl/R->\=  (dsl/R->keyword (first val)) (second val))))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (map (print (first val)) (second val)))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (map (dsl/R->\=  (dsl/R->keyword (first val)) (second val))))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq )" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   seq (map (fn [val] (dsl/R->\=  (dsl/R->keyword (first val)) (second val)))))" "(->> '({\:x \\n        {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n        \:y 1})\\n   seq \\n   (map (fn [val] \\n          (dsl/R->\=  \\n            (dsl/R->keyword (first val)) \\n            (second val)))))" "(->> '({\:x \\n        {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n        \:y 1}))" "(->> {\:x \\n      {\:R-struct true, \\n       \:oper \:R->vector, \\n       \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n      \:y 1}\\n   (apply seq ))" "(->> '({\:x \\n        {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n        \:y 1})\\n   (apply seq ))" "(->> '({\:x \\n        {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n        \:y 1})\\n   (apply seq)\\n   (map (fn [val] \\n          (dsl/R->\=  \\n            (dsl/R->keyword (first val)) \\n            (second val)))))" "(->> '({\:x \\n        {\:R-struct true, \\n         \:oper \:R->vector, \\n         \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n        \:y 1})\\n   (apply seq)\\n   (map (fn [val] \\n          (dsl/R->\=  \\n             (first val)\\n            (second val)))))" "(R->generate (->> '({\:x \\n             {\:R-struct true, \\n              \:oper \:R->vector, \\n              \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n             \:y 1})\\n       (apply seq)\\n       (map (fn [val] \\n              (dsl/R->\=  \\n                 (first val)\\n                (second val))))))" "(apply R->generate (->> '({\:x \\n                  {\:R-struct true, \\n                   \:oper \:R->vector, \\n                   \:parms [{\:R-struct true, \:oper \:R->number, \:parms [1]}]}\\n                  \:y 1})\\n       (apply seq)\\n       (map (fn [val] \\n              (dsl/R->\=  \\n                 (first val)\\n                (second val))))))" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" " \\n  (mean {\:x (R->vector (R->number 1))})" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(R->generate \\n  (summary {\:x (R->vector (R->number 1))}))" "(R->generate \\n  (summary 1 2 32  ))" "(R->generate \\n  (summary [1 2 32]))" "(R->generate \\n  (mean [1 2 32]))" "(R->generate \\n  (summary [1 2 32]))" "(R->generate \\n  (summary (R->vector 1 2 3)))" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(R->generate  (R->def \:m3 (R->mean \\r\\n                               (R->\= \:x (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= \:y (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) )))))" "(R->generate  (R->def \:m3 (R->mean \\r\\n                               (R->\= (R->keyword \:x) (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= (R->keyword \:y) (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) )))))" "InheritableThreadLocal" "(R->generate  (R->def \:m3 (R->mean \\r\\n                               (R->\= (R->keyword \:x) (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) ))\\r\\n                               (R->\= (R->keyword \:y) (R->vector (R->number 1) (R->number 1) (R->number 1) (R->keyword \:dog) )))))" "(R->generate \\n  (summary (R->vector 1 2 3)))" "(R->generate \\n  (mean {\:x (R->vector (R->number 1))}))" "(R->generate (mean 1 2 3))" "(+ 1 1)" "(mean [1 1 1])" "(R->mean [1 1 1])" "(dsl.primary-operations/R->mean [1 1 1])" "(dsl.primary-operations/R->mean 1 1 1)" "(dsl.primary-operations/R->range 1 10)" "(dsl.composit-operations/" "(dsl.composit-operations/mean [1 1 1])" "(dsl.composit-operations/summary [1 1 1])" "(dsl.composit-operations/summary {\:x [1 1 1]})" "(dsl.composit-operations/summary {\:x (dsl.primary-operations/R->vector 1 1 1 )})" "(dsl.composit-operations/summary {\:x (dsl.composit-operations/ 1 1 1 )})" "(dsl.composit-operations/summary {\:x (dsl.composit-operations/dataframe 1 1 1 )})" " (dsl.primary-operations/R->vector 1 1 1 )" "(dsl.primary-operations/" "(dsl.primary-operations/R->boxplot 1 1 1 1)" "(dsl.primary-operations/R->boxplot [1 1 1 1])" "(dsl.primary-operations/R->rownames car)" "(dsl.primary-operations/R->rownames \\"car\\")" "(dsl.primary-operations/R->rownames 'car)" "(dsl.primary-operations/R->rownames \\"one\\" \\"two\\")" "(dsl.primary-operations/R->rownames \\"one\\")" "(codeGeneration.RC-code-generation/R->generate (dsl.composit-operations/mean 1 1 1))" "(codeGeneration.RC-code-generation/R->generate (dsl.composit-operations/matrix 1 1 1))" "(codeGeneration.RC-code-generation/R->generate (dsl.composit-operations/matrix [1 1 1]))" "(codeGeneration.RC-code-generation/R->generate (dsl.primary-operations/R->def \\"test\\" 1))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.primary-operations/R->def \\"test\\" \\n                                 (dsl.primary-operations/R->vector 1 1 1)))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.primary-operations/R->def\\n    \\"test\\" \\n    (dsl.primary-operations/R->vector [1 1 1])))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.primary-operations/R->def\\n    \\"test\\" \\n    (dsl.primary-operations/R->vector 1 1 1)))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.composit-operations/mean\\n    (dsl.primary-operations/R->def\\n        \\"test\\" \\n        (dsl.primary-operations/R->vector 1 1 1))))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.composit-operations/mean\\n    {(dsl.primary-operations/R->def\\n         \\"test\\" \\n         (dsl.primary-operations/R->vector 1 1 1))}))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.composit-operations/mean\\n    (dsl.primary-operations/R->def\\n        \\"test\\" \\n        (dsl.primary-operations/R->vector 1 1 1))))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.primary-operations/R->def \\"test\\" \\n                                 (dsl.primary-operations/R->vector 1 1 1)))" "(dsl.primary-operations/R->matrix 1 1 1)" "(codeGeneration.RC-code-generation (dsl.primary-operations/R->matrifx 1 1 1))" "(codeGeneration.RC-code-generation/ (dsl.primary-operations/R->matrifx 1 1 1))" "(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.primary-operations/R->matrifx 1 1 1))" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->matrifx 1 1 1))" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->matrix 1 1 1))" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->matrix (dsl.primary-operations/R->\= \\"x\\" 1)))" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->matrix \\n    (dsl.primary-operations/R->\= \\"x\\" \\n                                 (dsl.primary-operations/R->vector 1 1 1 1))))" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->matrix\\n    (dsl.primary-operations/R->\= \\"nrow\\" 2)\\n    (dsl.primary-operations/R->\= \\"ncol\\" 2)\\n    (dsl.primary-operations/R->\= \\"x\\" \\n                                 (dsl.primary-operations/R->vector 1 1 1 1))))" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->\=\\n    \\"myMatrix\\"\\n    (dsl.primary-operations/R->matrix\\n              (dsl.primary-operations/R->\= \\"nrow\\" 2)\\n              (dsl.primary-operations/R->\= \\"ncol\\" 2)\\n              (dsl.primary-operations/R->\= \\"x\\" \\n                                           (dsl.primary-operations/R->vector 1 1 1 1)))))" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->def\\n    \\"myMatrix\\"\\n    (dsl.primary-operations/R->matrix\\n              (dsl.primary-operations/R->\= \\"nrow\\" 2)\\n              (dsl.primary-operations/R->\= \\"ncol\\" 2)\\n              (dsl.primary-operations/R->\= \\"x\\" \\n                                           (dsl.primary-operations/R->vector 1 1 1 1)))))" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->def\\n    \\"myMatrix\\"\\n    (dsl.primary-operations/R->matrix\\n              (dsl.primary-operations/R->\= \\"nrow\\" 2)\\n              (dsl.primary-operations/R->\= \\"ncol\\" 2)\\n              (dsl.primary-operations/R->\= \\"data\\" \\n                                           (dsl.primary-operations/R->vector 1 1 1 1)))))" "(codeGeneration.RC-code-generation/R->generate\\r\\n  (dsl.primary-operations/R->def\\r\\n    \\"myMatrix\\"\\r\\n    (dsl.primary-operations/R->matrix\\r\\n      (dsl.primary-operations/R->\= \\"nrow\\" 2)\\r\\n      (dsl.primary-operations/R->\= \\"ncol\\" 2)\\r\\n      (dsl.primary-operations/R->\= \\r\\n        \\"data\\" \\r\\n        (dsl.primary-operations/R->vector 1 1 1 1)))))" "(defn matrix [num-row num-col data-vec]\\r\\n    (dsl.primary-operations/R->matrix\\r\\n      (dsl.primary-operations/R->\= \\"nrow\\" num-row)\\r\\n      (dsl.primary-operations/R->\= \\"ncol\\" num-col)\\r\\n      (dsl.primary-operations/R->\= \\r\\n        \\"data\\" \\r\\n        (dsl.primary-operations/R->vector data-vec))))" "(matrix 2 2 [1 2 3 4 5])" "(codeGeneration.RC-code-generation/R->generate (matrix 2 2 [1 2 3 4 5]))" "(defn matrix [num-row num-col data-vec]\\r\\n    (dsl.primary-operations/R->matrix\\r\\n      (dsl.primary-operations/R->\= \\"nrow\\" num-row)\\r\\n      (dsl.primary-operations/R->\= \\"ncol\\" num-col)\\r\\n      (dsl.primary-operations/R->\= \\r\\n        \\"data\\" \\r\\n        (apply dsl.primary-operations/R->vector data-vec))))" "(codeGeneration.RC-code-generation/R->generate (matrix 2 2 [1 2 3 4 5]))" "(defn matrix [num-row num-col data-vec]\\r\\n  (dsl.primary-operations/R->matrix\\r\\n    (dsl.primary-operations/R->\= \\"nrow\\" num-row)\\r\\n    (dsl.primary-operations/R->\= \\"ncol\\" num-col)\\r\\n    (dsl.primary-operations/R->\= \\r\\n      \\"data\\" \\r\\n      (apply dsl.primary-operations/R->vector data-vec))))" "(defn matrix [& data]\\r\\n  \\"attribute map\\"\\r\\n  (apply R/R->matrix (sup/stnd-input-support data [\:map \:r-srt])))" "(matrix 1 1 1 )" "(r-matrix nrow\=3 ncol\=4 (r-vec 1 2 3))" "(codeGeneration.base-operators/R->\= \\"one\\" 1)" "(codeGeneration.RC-code-generation/R->generate\\n  (dsl.primary-operations/R->def\\n    \\"myMatrix\\"\\n    (dsl.primary-operations/R->matrix\\n              (dsl.primary-operations/R->\= \\"nrow\\" 2)\\n              (dsl.primary-operations/R->\= \\"ncol\\" 2)\\n              (dsl.primary-operations/R->\= \\"x\\" \\n                                           (dsl.primary-operations/R->vector 1 1 1 1)))))" "(codeGeneration.RC-code-generation/R->generate\\r\\n  (dsl.primary-operations/R->def\\r\\n    \\"myMatrix\\"\\r\\n    (dsl.primary-operations/R->matrix\\r\\n      (dsl.primary-operations/R->\= \\"nrow\\" 2)\\r\\n      (dsl.primary-operations/R->\= \\"ncol\\" 2)\\r\\n      (dsl.primary-operations/R->\= \\r\\n        \\"data\\" \\r\\n        (dsl.primary-operations/R->vector 1 1 1 1)))))" "(codeGeneration.RC-code-generation/R->generate\\r\\n  (dsl.primary-operations/R->def\\r\\n    \\"myMatrix\\"\\r\\n    (codeGeneration.base-operators/R->matrix\\r\\n      (codeGeneration.base-operators/R->\= \\"nrow\\" 2)\\r\\n      (codeGeneration.base-operators/R->\= \\"ncol\\" 2)\\r\\n      (codeGeneration.base-operators/R->\= \\r\\n        \\"data\\" \\r\\n        (codeGeneration.base-operators/R->vector 1 1 1 1)))))" "(codeGeneration.RC-code-generation/R->generate\\r\\n  (codeGeneration.base-operators/R->def\\r\\n    \\"myMatrix\\"\\r\\n    (codeGeneration.base-operators/R->matrix\\r\\n      (codeGeneration.base-operators/R->\= \\"nrow\\" 2)\\r\\n      (codeGeneration.base-operators/R->\= \\"ncol\\" 2)\\r\\n      (codeGeneration.base-operators/R->\= \\r\\n        \\"data\\" \\r\\n        (codeGeneration.base-operators/R->vector 1 1 1 1)))))" "(defn quick-matrix [num-row num-col data-vec]\\r\\n  (codeGeneration.base-operators/R->matrix\\r\\n    (codeGeneration.base-operators/R->\= \\"nrow\\" num-row)\\r\\n    (codeGeneration.base-operators/R->\= \\"ncol\\" num-col)\\r\\n    (codeGeneration.base-operators/R->\= \\r\\n      \\"data\\" \\r\\n      (apply codeGeneration.base-operators/R->vector data-vec))))" "(quick-matrix 20 20 [3 3 3])" "(quick-matrix 20 20 (range 1 10))" "(codeGeneration.RC-code-generation/R->generate (quick-matrix 20 20 (range 1 10)))" "(codeGeneration.RC-code-generation/R->generate (quick-matrix 20 20 (R->vector 2 3 4 5)))" "(R->vector 2 3 4 5)" "(codeGeneration.RC-code-generation/R->generate (quick-matrix 20 20 (R->vector 2 3 4 5)))" "(defn matrix-simple [num-row num-col data-vec]\\r\\n  (R/R->matrix\\r\\n    (R/R->\= \\"nrow\\" num-row)\\r\\n    (R/R->\= \\"ncol\\" num-col)\\r\\n    (R/R->\= \\r\\n      \\"data\\" \\n      (cond \\n        (or (vector? data-vec) (set? data-vec)) \\r\\n        (apply R/R->vector data-vec)\\n        (\:R-struct data-vec)\\n         data-vec))))" "(require [codeGeneration.base-operators \:as R])" "(require '[codeGeneration.base-operators \:as R])" "(defn matrix-simple [num-row num-col data-vec]\\r\\n  (R/R->matrix\\r\\n    (R/R->\= \\"nrow\\" num-row)\\r\\n    (R/R->\= \\"ncol\\" num-col)\\r\\n    (R/R->\= \\r\\n      \\"data\\" \\n      (cond \\n        (or (vector? data-vec) (set? data-vec)) \\r\\n        (apply R/R->vector data-vec)\\n        (\:R-struct data-vec)\\n         data-vec))))" "(codeGeneration.RC-code-generation/R->generate (quick-matrix 20 20 (R->vector 2 3 4 5)))" "(codeGeneration.RC-code-generation/R->generate \\n  (quick-matrix 20 \\n                20 \\n                (R->vector 2 3 4 5)))" "(defn matrix-simple [num-row num-col data-vec]\\r\\n  (R/R->matrix\\r\\n    (R/R->\= \\"nrow\\" num-row)\\r\\n    (R/R->\= \\"ncol\\" num-col)\\r\\n    (R/R->\= \\r\\n      \\"data\\" \\n      (cond \\n        (or (vector? data-vec) (set? data-vec)) \\r\\n        (do (println \\"one\\" ) (apply R/R->vector data-vec))\\n        (\:R-struct data-vec)\\n         (do (println \\"two\\") data-vec)))))" "(codeGeneration.RC-code-generation/R->generate \\n  (quick-matrix 20 \\n                20 \\n                (R->vector 2 3 4 5)))" "(defn matrix-simple [num-row num-col data-vec]\\r\\n  (R/R->matrix\\r\\n    (R/R->\= \\"nrow\\" num-row)\\r\\n    (R/R->\= \\"ncol\\" num-col)\\r\\n    (R/R->\= \\r\\n      \\"data\\" \\n      (cond \\n        (or (vector? data-vec) (set? data-vec)) \\r\\n        (do (println \\"one\\" ) (apply R/R->vector data-vec))\\n        (\:R-struct data-vec)\\n         (do (println \\"two\\") data-vec)))))" "(codeGeneration.RC-code-generation/R->generate (matrix-simple 20 20 (R->vector 2 3 4 5)))" "(codeGeneration.RC-code-generation/R->generate (matrix-simple 20 20 [1 1 3 4]))" "(codeGeneration.RC-code-generation/R->generate (matrix-simple 20 20 \#{1 1 3 4}))" "(codeGeneration.RC-code-generation/R->generate (matrix-simple 20 20 {1 1 3 4}))" "(codeGeneration.RC-code-generation/R->generate (matrix-simple 20 20 \#(1 1 3 4)))" "(codeGeneration.RC-code-generation/R->generate (matrix-simple 20 20 \#{1 1 3 4}))" "(codeGeneration.RC-code-generation/R->generate (matrix-simple 20 20 \#{1  3 4}))" "(defn matrix-simple [num-row num-col data-vec]\\r\\n  \\"Creates a matrix with num-rows, num-cols and data as vector, set or R vector\\"\\r\\n  (R/R->matrix\\r\\n    (R/R->\= \\"nrow\\" num-row)\\r\\n    (R/R->\= \\"ncol\\" num-col)\\r\\n    (R/R->\= \\r\\n      \\"data\\" \\r\\n      (cond \\r\\n        (or (vector? data-vec) (set? data-vec)) \\r\\n        (apply R/R->vector data-vec)\\r\\n        (\:R-struct data-vec) \\r\\n        data-vec\\r\\n        \:default\\r\\n        (throw (Exception. (str \\"Invalid data type to matrix\\")))))))" "(codeGeneration.RC-code-generation/R->generate (matrix-simple 20 20 \#{1  3 4}))" "\\r\\n(testing \\"mean structure taking map and vector failed\\"\\r\\n         (is\\r\\n           (\= \\"matrix(nrow\=20,ncol\=20,data\=c(1,4,3))\\" \\r\\n              (gen/R->generate (mat/matrix-simple 20 20 [1  3 4])))))" "(defn matrix-configured [attribute-map]\\n  (map \#(codeGeneration.base-operators/R->\= (first %) (second %)) attribute-map))" "(matrix-configured {\:one 1 \:two 2})" "(defn matrix-configured [attribute-map]\\n  (map \#(codeGeneration.base-operators/R->\= (name (first %)) (second %)) attribute-map))" "(matrix-configured {\:one 1 \:two 2})" "(defn matrix-configured [attribute-map]\\n  (R/R-matrix \\n    (map \#(codeGeneration.base-operators/R->\= (name (first %)) (second %)) attribute-map)))" "(mat/matrix-configured {\:rnum 20 \:cnum 20 \:data (R/R->vector 1 4 3)})" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (R/R->vector 1 4 3)})" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (R->vector 1 4 3)})" "(defn matrix-configured [attribute-map]\\n  (R/R-matrix \\n    (map \#(codeGeneration.base-operators/R->\= (name (first %)) (second %)) attribute-map)))" "(mat/matrix-configured {\:rnum 20 \:cnum 20 \:data (R/R->vector 1 4 3)})" "(defn matrix-configured [attribute-map]\\r\\n  (R/R->matrix \\r\\n    (map \#(R/R->\= (name (first %)) (second %)) attribute-map)))" "(mat/matrix-configured {\:rnum 20 \:cnum 20 \:data (R/R->vector 1 4 3)})" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (R/R->vector 1 4 3)})" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (R->vector 1 4 3)})" "(matrix-configured {\:one 1 \:two 2})" "\\r\\n(defn matrix-configured [attribute-map]\\r\\n  (apply R/R->matrix \\r\\n    (map \#(fn [x] (R/R->\= (name (first x)) (second x))) attribute-map)))" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (R->vector 1 4 3)})" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (codeGeneration.base-operators/R->vector 1 4 3)})" "(matrix-configured {\:rnum 20 \:cnum 20 \:data 1})" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (codeGeneration.base-operators/R->vector 1 4 3)})" "(map \#(println (first %) (second %)) {\:one 1})" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (codeGeneration.base-operators/R->vector 1 4 3)})" "(defn matrix-configured [attribute-map]\\r\\n  (apply codeGeneration.base-operators/R->matrix \\r\\n    (map (fn [v] (codeGeneration.base-operators/R->\= (name (first v)) (second v))) attribute-map)))" "(matrix-configured {\:rnum 20 \:cnum 20 \:data (codeGeneration.base-operators/R->vector 1 4 3)})" "(codeGeneration.RC-code-generation/R->generate\\n  (matrix-configured {\:rnum 20 \:cnum 20 \:data (codeGeneration.base-operators/R->vector 1 4 3)}))" "(codeGeneration.base-operators/R->mean [1 1])" "(defn mean-simple [& data] \\n  (codeGeneration.base-operators/R->mean\\n    (cond \\n      (> (count data) 1)\\n      (" "(codeGeneration.base-operators/R->vector 1)" "(codeGeneration.base-operators/R->vector 1 1)" "(apply codeGeneration.base-operators/R->vector [1 1])" "(apply codeGeneration.base-operators/R->vector [1 1 5 4])" "(defn mean-simple [& data] \\n    (cond\\n      (> (count data) 1)\\n      (apply codeGeneration.base-operators/R->mean data)\\n      (or (vector? (first data)) (set? (first data)))\\n      (apply codeGeneration.base-operators/R->mean (first data))))" "(mean-simple 1 3 4)" "(codeGeneration.RC-code-generation/R->generate (mean-simple 1 3 4))" "(codeGeneration.RC-code-generation/R->generate (mean-simple [1 3 4]))" "(codeGeneration.RC-code-generation/R->generate (mean-simple \#{1 3 4}))" "(codeGeneration.RC-code-generation/R->generate (mean-simple (codeGeneration.base-operators/R->vector 1 1 1)))" "(defn mean-simple [& data] \\n    (cond\\n      (> (count data) 1)\\n      (apply codeGeneration.base-operators/R->mean data)\\n      (or (vector? (first data)) (set? (first data)))\\n      (apply codeGeneration.base-operators/R->mean (first data))\\n      (\:R-struct (first data))\\n      (codeGeneration.base-operators/R->mean (first data))))" "(codeGeneration.RC-code-generation/R->generate (mean-simple (codeGeneration.base-operators/R->vector 1 1 1)))" "(defn mean-simple [& data] \\r\\n  \\"Gets mean of data, data can be numbers, vector, set or r-vector\\"\\r\\n    (cond\\r\\n      (> (count data) 1)\\r\\n      (apply codeGeneration.base-operators/R->mean data)\\r\\n      (or (vector? (first data)) (set? (first data)))\\r\\n      (apply codeGeneration.base-operators/R->mean (first data))\\r\\n      (\:R-struct (first data))\\r\\n      (codeGeneration.base-operators/R->mean (first data))))" "(codeGeneration.RC-code-generation/R->generate (mean-simple (codeGeneration.base-operators/R->vector 1 1 1)))" "(mean-simple 1 1 1)" "(codeGeneration.RC-code-generation/R->generate (mean-simple (codeGeneration.base-operators/R->vector 1 1 1)))" "(codeGeneration.RC-code-generation/R->generate (mean-simple 1 1 1))" "(defn mean-simple [& data] \\r\\n  \\"Gets mean of data, data can be numbers, vector, set or r-vector\\"\\r\\n    (cond\\r\\n      (> (count data) 1)\\r\\n      (codeGeneration.base-operators/R->mean \\r\\n       (apply codeGeneration.base-operators/R->vector data))\\r\\n      (or (vector? (first data)) (set? (first data)))\\r\\n      (codeGeneration.base-operators/R->mean \\r\\n        (apply codeGeneration.base-operators/R->vector (first data)))\\r\\n      (\:R-struct (first data))\\r\\n      (codeGeneration.base-operators/R->mean (first data))))" "(codeGeneration.RC-code-generation/R->generate (mean-simple 1 1 1))" "mean-simple 1 1 1)" "(mean-simple 1 1 1)" "(codeGeneration.base-operators/R->mean 1 1 1)" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->mean 1 1 1))" "(codeGeneration.base-operators/R->mean 1 1 1)" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->mean 1 1 1))" "(mat/matrix-configured {\:nrow 20 \:ncol 20 \:data (R/R->vector 1 4 3)}" "(mat/matrix-configured {\:nrow 20 \:ncol 20 \:data (R/R->vector 1 4 3)})" "(dsl.dsl-matrix/matrix-configured {\:nrow 20 \:ncol 20 \:data (R/R->vector 1 4 3)})" "\\r\\n(defn R->raw [data]\\r\\n  (gen/gen-R-struct \:R->mean [ data]))" "(mat/matrix-configured {\:nrow 20 \:ncol 20 \:data (R/R->vector 1 4 3)})" "(dsl.dsl-matrix/matrix-configured {\:nrow 20 \:ncol 20 \:data (R/R->vector 1 4 3)})" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->mean 1 1 1))" "(codeGeneration.RC-code-generation/R->generate (mean-simple 1 1 1))" "(mat/matrix-configured {\:nrow 20 \:ncol 20 \:data (R/R->vector 1 4 3)})" "(codeGeneration.RC-code-generation/R->generate (dsl.dsl-matrix/matrix-simple 20 20 \#{1 4 3}))" "(dsl.dsl-matrix/matrix-simple 20 20 \#{1 4 3})" "(codeGeneration.RC-code-generation/R->generate (dsl.dsl-matrix/matrix-simple 20 20 \#{1 4 3}))" "(dsl.dsl-matrix/matrix-simple 20 20 \#{1 4 3})" "(codeGeneration.RC-code-generation/R->generate {\:R-struct true, \:oper \:R->matrix, \:parms [{\:R-struct true, \:oper \:R->\=, \:parms [{\:R-struct true, \:oper \:R->raw, \:parms [\\"nrow\\"]} {\:R-struct true, \:oper \:R->raw, \:parms [20]}]} {\:R-struct true, \:oper \:R->\=, \:parms [{\:R-struct true, \:oper \:R->raw, \:parms [\\"ncol\\"]} {\:R-struct true, \:oper \:R->raw, \:parms [20]}]} {\:R-struct true, \:oper \:R->\=, \:parms [{\:R-struct true, \:oper \:R->raw, \:parms [\\"data\\"]} {\:R-struct true, \:oper \:R->vector, \:parms [{\:R-struct true, \:oper \:R->raw, \:parms [1]} {\:R-struct true, \:oper \:R->raw, \:parms [4]} {\:R-struct true, \:oper \:R->raw, \:parms [3]}]}]}]})" "(codeGeneration.RC-code-generation/R->generate \\n  {\:R-struct true, \:oper \:R->matrix, \:parms [{\:R-struct true, \:oper \:R->\=, \:parms [{\:R-struct true, \:oper \:R->raw, \:parms [\\"nrow\\"]} {\:R-struct true, \:oper \:R->raw, \:parms [20]}]} {\:R-struct true, \:oper \:R->\=, \:parms [{\:R-struct true, \:oper \:R->raw, \:parms [\\"ncol\\"]} {\:R-struct true, \:oper \:R->raw, \:parms [20]}]} {\:R-struct true, \:oper \:R->\=, \:parms [{\:R-struct true, \:oper \:R->raw, \:parms [\\"data\\"]} {\:R-struct true, \:oper \:R->vector, \:parms [{\:R-struct true, \:oper \:R->raw, \:parms [1]} {\:R-struct true, \:oper \:R->raw, \:parms [4]} {\:R-struct true, \:oper \:R->raw, \:parms [3]}]}]}]})" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->\= 1 1))" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->\= \\n                                                 (codeGeneration.base-operators/R->raw 1)\\n                                                 (codeGeneration.base-operators/R->raw 1)))" " (codeGeneration.base-operators/R->\= \\n   (codeGeneration.base-operators/R->raw 1)\\n   (codeGeneration.base-operators/R->raw 1))" "\\r\\n(defn R->raw [data]\\r\\n  (assoc (gen/gen-R-struct \:R->raw [ data]) \:raw true))" "(R->raw 4)" "\\r\\n(defn R->raw [data]\\r\\n  (assoc (gen/gen-R-struct \:R->raw [ data]) \:raw true))" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->\= \\n                                                 (codeGeneration.base-operators/R->raw 1)\\n                                                 (codeGeneration.base-operators/R->raw 1)))" "(codeGeneration.base-operators/R->\= \\n  (codeGeneration.base-operators/R->raw 1)\\n  (codeGeneration.base-operators/R->raw 1))" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->\= \\n                                                 (codeGeneration.base-operators/R->raw 1)\\n                                                 (codeGeneration.base-operators/R->raw 1)))" "(codeGeneration.base-operators/R->\= \\n  (codeGeneration.base-operators/R->raw 1)\\n  (codeGeneration.base-operators/R->raw 1))" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->\= \\n                                                 (codeGeneration.base-operators/R->raw 1)\\n                                                 (codeGeneration.base-operators/R->raw 1)))" "(codeGeneration.RC-code-generation/R->generate\\n                                                (codeGeneration.base-operators/R->raw 1))" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->raw 1))" " (codeGeneration.base-operators/R->raw 1)" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->raw 1))" " (codeGeneration.base-operators/R->raw 1)" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->raw 1))" "(codeGeneration.RC-code-generation/R->generate (codeGeneration.base-operators/R->\= \\n                                                 (codeGeneration.base-operators/R->raw 1)\\n                                                 (codeGeneration.base-operators/R->raw 1)))" "(codeGeneration.RC-code-generation/R->generate (dsl.dsl-matrix/matrix-simple 20 20 \#{1 4 3}))" "(dsl.dsl-matrix/matrix-simple 10 10 [1 2 3])" "(codeGeneration.RC-code-generation/R->generate (dsl.dsl-matrix/matrix-simple 20 20 \#{1 4 3}))" "(codeGeneration.RC-code-generation/R->generate (dsl.dsl-matrix/matrix-simple 20 20 [1 4 3]))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.dsl-matrix/matrix-simple 20 20 (codeGeneration.base-operators/R->vector 1 2 3))" "(codeGeneration.RC-code-generation/R->generate \\n  (dsl.dsl-matrix/matrix-simple 20 20 (codeGeneration.base-operators/R->vector 1 2 3)))" "\\n  (dsl.dsl-matrix/matrix-simple 20 20 (codeGeneration.base-operators/R->vector 1 2 3))" "(dsl.dsl-vector 1 2 3)" "(dsl.dsl-vector/vector-simple 1 2 3)" "(codeGeneration.RC-code-generation/R->generate  (dsl.dsl-vector/vector-simple 1 2 3))" "(dsl.dsl-vector/vector-simple 1 2 3)" "(codeGeneration.RC-code-generation/R->generate  (dsl.dsl-vector/vector-simple 1 2 3))" "\\n  (dsl.dsl-matrix/matrix-simple 20 20 (dsl.dsl-vector/vector-simple 1 2 3))" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-simple 20 20 (dsl.dsl-vector/vector-simple 1 2 3)))" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured 20 20 (dsl.dsl-vector/vector-simple 1 2 3)))" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f 40}))" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)}))" "\\n;(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)})" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)}))" "\\n;(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)})" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)}))" "\\n;(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)})" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)}))" "\\n;(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)})" "(seq? {})" "\\n;(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)})" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)}))" "(dsl.dsl-mean (dsl.dsl-vector 1 2 34))" "(dsl.dsl-mean/mean-simple (dsl.dsl-vector 1 2 34))" "(dsl.dsl-mean/mean-simple (dsl.dsl-vector/vector-simple 1 2 34))" "(dsl.dsl-mean/mean-simple 1 2 3)" "\\n(codeGeneration.RC-code-generation/R->generate-command\\n  (dsl.dsl-matrix/matrix-configured {\:n 10 \:f (dsl.dsl-vector/vector-simple 1 1)}))" "(mean/mean-simple 1 1 1)" "(gen/R->generate (mean/mean-simple 1 1 1))" "(R->generate (mean/mean-simple 1 2 3))" "(R->generate (mean/mean-simple 1 2 3)(mean/mean-simple 1 2 3))" "(generate (mean/mean-simple 2 3 4))"]
eclipse.preferences.version=1
